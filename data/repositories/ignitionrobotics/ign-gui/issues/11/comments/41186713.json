{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gui/issues/11/comments/41186713.json"}, "html": {"href": "#!/ignitionrobotics/ign-gui/issues/11#comment-41186713"}}, "issue": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gui/issues/11.json"}}, "type": "issue", "id": 11, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gui.json"}, "html": {"href": "#!/ignitionrobotics/ign-gui"}, "avatar": {"href": "data/bytebucket.org/ravatar/{d80b97c2-f3f9-42b2-86b0-8c1fd4aa845f}ts=1406854"}}, "type": "repository", "name": "ign-gui", "full_name": "ignitionrobotics/ign-gui", "uuid": "{d80b97c2-f3f9-42b2-86b0-8c1fd4aa845f}"}, "title": "Consider using Qt's plugin framework instead of ignition's"}, "content": {"raw": "From the documentation of [QPluginLoader](http://doc.qt.io/qt-5/qpluginloader.html):\n\n> An instance of a QPluginLoader object operates on a single shared library file, which we call a plugin.\n\nNote that in Qt terminology, a \"plugin\" is equivalent to a \"shared library\".\n\n> Once loaded, plugins remain in memory until all instances of QPluginLoader has been unloaded, or until the application terminates.\n\nNote the use of the word \"unloaded\" here. It seems that \"unloaded\" means explicitly calling the `unload()` function.\n\nFrom the description of the `QPluginLoader` destructor:\n\n> Unless unload() was called explicitly, the plugin stays in memory until the application terminates.\n\nThis means that the burden of keeping track of whether a shared library is still in use falls on us. We can load a shared library, spawn a QWidget from it, and throw away its `QPluginLoader` without calling `unload()`, and that would ensure that the shared library used by the QWidget remains loaded forever. But that also means that we will never be able to unload the shared library once the widget is no longer in use. The only way we could ever safely unload a plugin's shared library is if we take responsibility for keeping track of all the widgets that use the library, and also hang onto the `QPluginLoader` that spawned them.\n\nI think if we care about being able to safely unload libraries that are no longer in use, we'll want to stick with the `ignition-common` implementation. If that's not a concern for the QWidgets, then the Qt Plugin framework should be fine, and it would make some implementation details simpler for us.\n\n(@chapulina Note that this is different than what I had said to you earlier. I thought the destructor of `QPluginLoader` would call its `unload()` function, but it does not; it just allows the plugin library to remain loaded forever if you never explicitly called `unload()`.)", "markup": "markdown", "html": "<p>From the documentation of <a data-is-external-link=\"true\" href=\"http://doc.qt.io/qt-5/qpluginloader.html\" rel=\"nofollow\">QPluginLoader</a>:</p>\n<blockquote>\n<p>An instance of a QPluginLoader object operates on a single shared library file, which we call a plugin.</p>\n</blockquote>\n<p>Note that in Qt terminology, a \"plugin\" is equivalent to a \"shared library\".</p>\n<blockquote>\n<p>Once loaded, plugins remain in memory until all instances of QPluginLoader has been unloaded, or until the application terminates.</p>\n</blockquote>\n<p>Note the use of the word \"unloaded\" here. It seems that \"unloaded\" means explicitly calling the <code>unload()</code> function.</p>\n<p>From the description of the <code>QPluginLoader</code> destructor:</p>\n<blockquote>\n<p>Unless unload() was called explicitly, the plugin stays in memory until the application terminates.</p>\n</blockquote>\n<p>This means that the burden of keeping track of whether a shared library is still in use falls on us. We can load a shared library, spawn a QWidget from it, and throw away its <code>QPluginLoader</code> without calling <code>unload()</code>, and that would ensure that the shared library used by the QWidget remains loaded forever. But that also means that we will never be able to unload the shared library once the widget is no longer in use. The only way we could ever safely unload a plugin's shared library is if we take responsibility for keeping track of all the widgets that use the library, and also hang onto the <code>QPluginLoader</code> that spawned them.</p>\n<p>I think if we care about being able to safely unload libraries that are no longer in use, we'll want to stick with the <code>ignition-common</code> implementation. If that's not a concern for the QWidgets, then the Qt Plugin framework should be fine, and it would make some implementation details simpler for us.</p>\n<p>(@chapulina Note that this is different than what I had said to you earlier. I thought the destructor of <code>QPluginLoader</code> would call its <code>unload()</code> function, but it does not; it just allows the plugin library to remain loaded forever if you never explicitly called <code>unload()</code>.)</p>", "type": "rendered"}, "created_on": "2017-11-13T21:29:06.520897+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-11-13T21:29:23.452418+00:00", "type": "issue_comment", "id": 41186713}