{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gui/pullrequests/186/comments/87921149.json"}, "html": {"href": "#!/ignitionrobotics/ign-gui/pull-requests/186/_/diff#comment-87921149"}}, "parent": {"id": 87857289, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gui/pullrequests/186/comments/87857289.json"}, "html": {"href": "#!/ignitionrobotics/ign-gui/pull-requests/186/_/diff#comment-87857289"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 186, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gui/pullrequests/186.json"}, "html": {"href": "#!/ignitionrobotics/ign-gui/pull-requests/186"}}, "title": "Get ign-gui plugin interface in case there are others"}, "content": {"raw": "I\u2019ve dug into this, and I think I roughly know the cause. This issue is something we\u2019ve been suspecting might come up for some time now, but since linkers are a bit mysterious to me, I wasn\u2019t sure when \\(or if\\) it would actually pose a problem. But I think we\u2019ve finally hit it.\n\nBasically, each plugin library has a function called `IgnitionPluginHook(~)` which gets loaded when `dlopen(~)` is called on the library. Ideally, each time a library is loaded, its version of `IgnitionPluginHook(~)` should overwrite whichever version of the function was already in use, and so the `ignition::plugin::Loader` class should get the plugin information from this most recently loaded library.\n\nSo far this has worked fine, but I suspect the linker might not be as accommodating when you\u2019re using debug symbols. It seems that when the plugin library is built in debug mode, it ends up writing its plugin information to the wrong static variable. Because of that, the plugin Loader \\(which was built in release mode\\) is not going to the correct spot in memory where the plugin library placed its plugin information.\n\nI think the solution to this is to do something similar to the `class_loader` library where `IgnitionPluginHook(~)` is a function that is only defined in the `ignition-plugin` library, and when a plugin library is loaded, it will call the `ignition-plugin` version of the library instead of calling its own.\n\nIt might be a little tricky to fix this while remaining backwards compatible, but I think it may be doable. I\u2019ll give it a try ASAP and report back. In the meantime, we might not have proper support for plugin libraries that are built in debug mode :sweat: ", "markup": "markdown", "html": "<p>I\u2019ve dug into this, and I think I roughly know the cause. This issue is something we\u2019ve been suspecting might come up for some time now, but since linkers are a bit mysterious to me, I wasn\u2019t sure when (or if) it would actually pose a problem. But I think we\u2019ve finally hit it.</p>\n<p>Basically, each plugin library has a function called <code>IgnitionPluginHook(~)</code> which gets loaded when <code>dlopen(~)</code> is called on the library. Ideally, each time a library is loaded, its version of <code>IgnitionPluginHook(~)</code> should overwrite whichever version of the function was already in use, and so the <code>ignition::plugin::Loader</code> class should get the plugin information from this most recently loaded library.</p>\n<p>So far this has worked fine, but I suspect the linker might not be as accommodating when you\u2019re using debug symbols. It seems that when the plugin library is built in debug mode, it ends up writing its plugin information to the wrong static variable. Because of that, the plugin Loader (which was built in release mode) is not going to the correct spot in memory where the plugin library placed its plugin information.</p>\n<p>I think the solution to this is to do something similar to the <code>class_loader</code> library where <code>IgnitionPluginHook(~)</code> is a function that is only defined in the <code>ignition-plugin</code> library, and when a plugin library is loaded, it will call the <code>ignition-plugin</code> version of the library instead of calling its own.</p>\n<p>It might be a little tricky to fix this while remaining backwards compatible, but I think it may be doable. I\u2019ll give it a try ASAP and report back. In the meantime, we might not have proper support for plugin libraries that are built in debug mode <img class=\"emoji\" src=\"data/pf-emoji-service--cdn.us-east-1.prod.public.atl-paas.net/standard/551c9814-1d37-4573-819d-afab3afeaf32/48x48/1f613.png\" alt=\"\ud83d\ude13\" title=\":sweat:\" data-emoji-short-name=\":sweat:\" /> </p>", "type": "rendered"}, "created_on": "2019-01-14T10:18:56.257696+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2019-01-14T10:18:56.274546+00:00", "type": "pullrequest_comment", "id": 87921149}