{"priority": "major", "kind": "proposal", "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-cmake.json"}, "html": {"href": "#!/ignitionrobotics/ign-cmake"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3e77bcf7-f260-4cec-a1a0-116b8e298901}ts=default"}}, "type": "repository", "name": "ign-cmake", "full_name": "ignitionrobotics/ign-cmake", "uuid": "{3e77bcf7-f260-4cec-a1a0-116b8e298901}"}, "links": {"attachments": {"href": "data/repositories/ignitionrobotics/ign-cmake/issues/18/attachments_page=1.json"}, "self": {"href": "data/repositories/ignitionrobotics/ign-cmake/issues/18.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-cmake/issues/18/watch"}, "comments": {"href": "data/repositories/ignitionrobotics/ign-cmake/issues/18/comments_page=1.json"}, "html": {"href": "#!/ignitionrobotics/ign-cmake/issues/18/proposal-adding-c-utilities-to-ign-cmake"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-cmake/issues/18/vote"}}, "reporter": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "title": "Proposal: Adding C++ utilities to ign-cmake", "component": null, "votes": 0, "watches": 1, "content": {"raw": "Apologies in advance for the wall-of-text.\r\n\r\nThe original motivation for creating `ign-cmake` was to systematically ensure consistent build behavior across all the ignition projects, in a way that is maintainable and scalable.\r\n\r\nEven though the `ign-cmake` package is still in development, it's had some very tangible benefits: we now have four projects (`ign-math`, `ign-common`, `ign-msgs`, and `ign-transport`) with robust build systems across all of our supported platforms and consistent package behavior across all of the projects. If we ever decide to change our packaging behavior or if we ever need to fix a build system bug, we can take care of it in `ign-cmake`, and all the ignition projects will benefit the next time they configure. Future and upcoming projects will experience these benefits as well.\r\n\r\nHowever, we want to have consistency across all the ignition projects in more ways than just their build system and packaging. The most obvious example is the PIMPL pattern, which is a design pattern that we aim to use across all the ignition projects to achieve maximum flexibility in our development cycles without needing to be concerned about breaking ABI.\r\n\r\nThe forcing function that prompted me to make this proposal was in a recent `ign-transport` pull request, we found ourselves repeatedly writing boilerplate move and copy constructors, plus move and copy assignment operators for just about every darn interface class (here's a sampling from that one pull request: [1](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/Batch.hhT44) [2](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/Descriptor.hhT109) [3](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/Log.hhT48) [4](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/MsgIter.hhT45) [5](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/MsgIter.hhT49) [6](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/MsgIter.hhT57) [7](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT85) [8](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT89) [9](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT152) [10](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT156) [11](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT198) [12](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT202) [13](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT242) [14](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT246) [15](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/Recorder.hhT57) [16](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/SqlStatement.hhT52) [17](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/SqlStatement.hhT56) [18](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/SqlStatement.hhT61) [19](#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/SqlStatement.hhT66)).\r\n\r\nThe worst part is, even with all that effort in manually creating all those constructors and assignment operators, some of the classes in that pull request *still* don't have proper copy and move semantics, simply because we have not yet noticed that their copy/move constructors/operators are missing.\r\n\r\nThat's when I remembered some [design utilities](http://oliora.github.io/2015/12/29/pimpl-and-rule-of-zero.html) promoted by Scott Meyers which makes the PIMPL pattern so very much more bearable. Here's a tl;dr of that article:\r\n\r\nInstead of using a plain `std::unique_ptr<Implementation>` to contain the implementation object, you can have a `impl_ptr<Implementation>` which takes care of creating the copy and move constructors for your interface class. To make that more concrete, your class definition would look like this:\r\n\r\n```\r\nclass MyClass\r\n{\r\n  public: /* Interface functions go here */\r\n\r\n  private: class Implementation;\r\n  private: ImplPtr<Implementation> dataPtr;\r\n};\r\n```\r\n\r\nThen in the source file, your constructor would look like this:\r\n\r\n```\r\nMyClass::MyClass( /* constructor args */ )\r\n  : dataPtr(MakeImpl<Implementation>(/* constructor args */))\r\n{\r\n  // Do nothing\r\n}\r\n```\r\n\r\nThis will allow `MyClass` to automatically create a copy constructor, move constructor, copy operator, and move operator, and all you have to do is replace `std::unique_ptr` with `ImplPtr` and `new Implementation` with `MakeImpl<Implementation>`. Note that we can also have a `UniqueImplPtr` which will allow moving but not copying, for classes that are not copyable. The catch, of course, is you need to have access to the header that defines `ImplPtr` and `MakeImpl`.\r\n\r\nSince it's a single header file, the brute force approach would be to write the header and then drop it into each project. That's a viable solution if we're confident that we'll never ever have to make any changes to the implementation, but that's a very risky assumption to make.\r\n\r\nIdeally, we would want the `ImplPtr` to be available in every project from a single source. We already have a project which is a required dependency of every ignition project: `ign-cmake`. If we were to consider the goal of `ign-cmake` to be achieving consistent, maintainable, scalable development (not just build+packaging behavior) across all the ignition projects, then it would make sense to have it provide a small set of C++ utilities that could be used across all projects to keep behavior and development consistent between them.\r\n\r\nI can think of three utilities which would make sense to share across all projects right away: (1) the pimpl class mentioned here, (2) the warning suppression system which is currently in `ign-common`, and (3) the Console utility currently in `ign-common`. These are things that all project would benefit from:\r\n\r\n1. Anything that can make PIMPL easier to stomach is a good thing.\r\n\r\n2. We're repeatedly dealing with the same compiler warnings across every project. This would give us a clean way to handle those consistently everywhere.\r\n\r\n3. Having the `Console` class and its error/warning macros as base utilities would allow us to have consistent status, warning, and error messaging behavior across all the libraries, instead of having some print proper messages while others print plain, unformatted messages.\r\n\r\nWe could also consider the `Filesystem` from `ign-common`, but I don't think that's as basic of a utility (and it will probably be replaced by the C++17 filesystem soon anyway).\r\n\r\n### Why not just use ign-common?\r\n\r\nRight now, `ign-common` would be more aptly named `ign-miscellaneous`. Most of its content is not common to all projects, and it would be unreasonable to have all projects depend on it, even after it's been split into components.\r\n\r\n`ign-cmake` is already a required dependency. Putting these utilities into `ign-cmake` will make them accessible to all projects right away, without introducing any new dependencies.\r\n\r\n### Then could we really call this project ign-cmake anymore?\r\n\r\nMaybe not.\r\n\r\nI would propose that we add these utilities to `ign-cmake` as a library called `ignition-utilities` (or maybe `ignition-utils`, or some variation on that). When each project calls `find_package(ignition-cmake1)` it will import a target for the `ignition-utilities` library, and `ign-cmake` can automatically link each project library against the utilities target. Consumer projects wouldn't have to change *anything* in their build scripts.\r\n\r\nThen, when we're approaching the hypothetical release of `ignition-cmake1`, we can decide whether we want to keep using the name `ignition-cmake`. Maybe by then, `ign-common` will be rid of its miscellaneous components, and we can have `ign-cmake` take over the name `ign-common`. Otherwise, we could consider renaming `ign-cmake` to something like `ign-utilities`, `ign-utils`, `ign-root`, `ign-base`, or any other suggestions that people have. Or we could just keep the name as `ign-cmake` and accept the slight misnomer of the project.", "markup": "markdown", "html": "<p>Apologies in advance for the wall-of-text.</p>\n<p>The original motivation for creating <code>ign-cmake</code> was to systematically ensure consistent build behavior across all the ignition projects, in a way that is maintainable and scalable.</p>\n<p>Even though the <code>ign-cmake</code> package is still in development, it's had some very tangible benefits: we now have four projects (<code>ign-math</code>, <code>ign-common</code>, <code>ign-msgs</code>, and <code>ign-transport</code>) with robust build systems across all of our supported platforms and consistent package behavior across all of the projects. If we ever decide to change our packaging behavior or if we ever need to fix a build system bug, we can take care of it in <code>ign-cmake</code>, and all the ignition projects will benefit the next time they configure. Future and upcoming projects will experience these benefits as well.</p>\n<p>However, we want to have consistency across all the ignition projects in more ways than just their build system and packaging. The most obvious example is the PIMPL pattern, which is a design pattern that we aim to use across all the ignition projects to achieve maximum flexibility in our development cycles without needing to be concerned about breaking ABI.</p>\n<p>The forcing function that prompted me to make this proposal was in a recent <code>ign-transport</code> pull request, we found ourselves repeatedly writing boilerplate move and copy constructors, plus move and copy assignment operators for just about every darn interface class (here's a sampling from that one pull request: <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/Batch.hhT44\" rel=\"nofollow\">1</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/Descriptor.hhT109\" rel=\"nofollow\">2</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/Log.hhT48\" rel=\"nofollow\">3</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/MsgIter.hhT45\" rel=\"nofollow\">4</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/MsgIter.hhT49\" rel=\"nofollow\">5</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/MsgIter.hhT57\" rel=\"nofollow\">6</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT85\" rel=\"nofollow\">7</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT89\" rel=\"nofollow\">8</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT152\" rel=\"nofollow\">9</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT156\" rel=\"nofollow\">10</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT198\" rel=\"nofollow\">11</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT202\" rel=\"nofollow\">12</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT242\" rel=\"nofollow\">13</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/QueryOptions.hhT246\" rel=\"nofollow\">14</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/Recorder.hhT57\" rel=\"nofollow\">15</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/SqlStatement.hhT52\" rel=\"nofollow\">16</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/SqlStatement.hhT56\" rel=\"nofollow\">17</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/SqlStatement.hhT61\" rel=\"nofollow\">18</a> <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/pull-requests/252/wip-ignition-tools-record-playback/diff#Llog/include/ignition/transport/log/SqlStatement.hhT66\" rel=\"nofollow\">19</a>).</p>\n<p>The worst part is, even with all that effort in manually creating all those constructors and assignment operators, some of the classes in that pull request <em>still</em> don't have proper copy and move semantics, simply because we have not yet noticed that their copy/move constructors/operators are missing.</p>\n<p>That's when I remembered some <a data-is-external-link=\"true\" href=\"http://oliora.github.io/2015/12/29/pimpl-and-rule-of-zero.html\" rel=\"nofollow\">design utilities</a> promoted by Scott Meyers which makes the PIMPL pattern so very much more bearable. Here's a tl;dr of that article:</p>\n<p>Instead of using a plain <code>std::unique_ptr&lt;Implementation&gt;</code> to contain the implementation object, you can have a <code>impl_ptr&lt;Implementation&gt;</code> which takes care of creating the copy and move constructors for your interface class. To make that more concrete, your class definition would look like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kr\">class</span> <span class=\"nx\">MyClass</span>\n<span class=\"p\">{</span>\n  <span class=\"kr\">public</span><span class=\"o\">:</span> <span class=\"cm\">/* Interface functions go here */</span>\n\n  <span class=\"kr\">private</span><span class=\"o\">:</span> <span class=\"kr\">class</span> <span class=\"nx\">Implementation</span><span class=\"p\">;</span>\n  <span class=\"kr\">private</span><span class=\"o\">:</span> <span class=\"nx\">ImplPtr</span><span class=\"o\">&lt;</span><span class=\"nx\">Implementation</span><span class=\"o\">&gt;</span> <span class=\"nx\">dataPtr</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</pre></div>\n\n\n<p>Then in the source file, your constructor would look like this:</p>\n<div class=\"codehilite\"><pre><span></span>MyClass::MyClass( /* constructor args */ )\n  : dataPtr(MakeImpl&lt;Implementation&gt;(/* constructor args */))\n{\n  // Do nothing\n}\n</pre></div>\n\n\n<p>This will allow <code>MyClass</code> to automatically create a copy constructor, move constructor, copy operator, and move operator, and all you have to do is replace <code>std::unique_ptr</code> with <code>ImplPtr</code> and <code>new Implementation</code> with <code>MakeImpl&lt;Implementation&gt;</code>. Note that we can also have a <code>UniqueImplPtr</code> which will allow moving but not copying, for classes that are not copyable. The catch, of course, is you need to have access to the header that defines <code>ImplPtr</code> and <code>MakeImpl</code>.</p>\n<p>Since it's a single header file, the brute force approach would be to write the header and then drop it into each project. That's a viable solution if we're confident that we'll never ever have to make any changes to the implementation, but that's a very risky assumption to make.</p>\n<p>Ideally, we would want the <code>ImplPtr</code> to be available in every project from a single source. We already have a project which is a required dependency of every ignition project: <code>ign-cmake</code>. If we were to consider the goal of <code>ign-cmake</code> to be achieving consistent, maintainable, scalable development (not just build+packaging behavior) across all the ignition projects, then it would make sense to have it provide a small set of C++ utilities that could be used across all projects to keep behavior and development consistent between them.</p>\n<p>I can think of three utilities which would make sense to share across all projects right away: (1) the pimpl class mentioned here, (2) the warning suppression system which is currently in <code>ign-common</code>, and (3) the Console utility currently in <code>ign-common</code>. These are things that all project would benefit from:</p>\n<ol>\n<li>\n<p>Anything that can make PIMPL easier to stomach is a good thing.</p>\n</li>\n<li>\n<p>We're repeatedly dealing with the same compiler warnings across every project. This would give us a clean way to handle those consistently everywhere.</p>\n</li>\n<li>\n<p>Having the <code>Console</code> class and its error/warning macros as base utilities would allow us to have consistent status, warning, and error messaging behavior across all the libraries, instead of having some print proper messages while others print plain, unformatted messages.</p>\n</li>\n</ol>\n<p>We could also consider the <code>Filesystem</code> from <code>ign-common</code>, but I don't think that's as basic of a utility (and it will probably be replaced by the C++17 filesystem soon anyway).</p>\n<h3 id=\"markdown-header-why-not-just-use-ign-common\">Why not just use ign-common?</h3>\n<p>Right now, <code>ign-common</code> would be more aptly named <code>ign-miscellaneous</code>. Most of its content is not common to all projects, and it would be unreasonable to have all projects depend on it, even after it's been split into components.</p>\n<p><code>ign-cmake</code> is already a required dependency. Putting these utilities into <code>ign-cmake</code> will make them accessible to all projects right away, without introducing any new dependencies.</p>\n<h3 id=\"markdown-header-then-could-we-really-call-this-project-ign-cmake-anymore\">Then could we really call this project ign-cmake anymore?</h3>\n<p>Maybe not.</p>\n<p>I would propose that we add these utilities to <code>ign-cmake</code> as a library called <code>ignition-utilities</code> (or maybe <code>ignition-utils</code>, or some variation on that). When each project calls <code>find_package(ignition-cmake1)</code> it will import a target for the <code>ignition-utilities</code> library, and <code>ign-cmake</code> can automatically link each project library against the utilities target. Consumer projects wouldn't have to change <em>anything</em> in their build scripts.</p>\n<p>Then, when we're approaching the hypothetical release of <code>ignition-cmake1</code>, we can decide whether we want to keep using the name <code>ignition-cmake</code>. Maybe by then, <code>ign-common</code> will be rid of its miscellaneous components, and we can have <code>ign-cmake</code> take over the name <code>ign-common</code>. Otherwise, we could consider renaming <code>ign-cmake</code> to something like <code>ign-utilities</code>, <code>ign-utils</code>, <code>ign-root</code>, <code>ign-base</code>, or any other suggestions that people have. Or we could just keep the name as <code>ign-cmake</code> and accept the slight misnomer of the project.</p>", "type": "rendered"}, "assignee": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "state": "new", "version": null, "edited_on": null, "created_on": "2018-02-02T23:58:46.576951+00:00", "milestone": null, "updated_on": "2018-02-03T16:04:46.634673+00:00", "type": "issue", "id": 18}