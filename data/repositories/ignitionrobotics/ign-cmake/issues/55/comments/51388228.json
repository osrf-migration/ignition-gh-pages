{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-cmake/issues/55/comments/51388228.json"}, "html": {"href": "#!/ignitionrobotics/ign-cmake/issues/55#comment-51388228"}}, "issue": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-cmake/issues/55.json"}}, "type": "issue", "id": 55, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-cmake.json"}, "html": {"href": "#!/ignitionrobotics/ign-cmake"}, "avatar": {"href": "data/bytebucket.org/ravatar/{3e77bcf7-f260-4cec-a1a0-116b8e298901}ts=default"}}, "type": "repository", "name": "ign-cmake", "full_name": "ignitionrobotics/ign-cmake", "uuid": "{3e77bcf7-f260-4cec-a1a0-116b8e298901}"}, "title": "Failing to build Target / does not exist"}, "content": {"raw": "> Will any package that has nodes that calls gazebo and has gazebo as a secondary dependency have this issue?\n\nOnly if you use the old-fashioned `catkin_make`. There are good reasons that `catkin_make_isolated` and `catkin build` are the recommended ways to build workspaces these days.\n\n> but since they don't have any nodes/libraries that call gazebo, they don't give me any errors.\n\nThe error happened because `vgazebo_plugins` had a public dependency on targets like `protobuf::libprotobuf`. In cmake, the public dependencies of library `L` will get inherited by any downstream library `D` that calls `target_link_libraries(D [PUBLIC|PRIVATE} L)`.\n\nThat means library `D` wanted to link against the target `protobuf::libprotobuf`. You got an error because the `CMakeLists.txt` for library `D` couldn't find a target named `protobuf::libprotobuf`. If each package were configured independently, then that error wouldn't happen. The error occurs because `catkin_make` unceremoniously smashes all the `CMakeLists.txt` of your workspace into one project configuration. The Gazebo config file is designed to only be invoked once per project configuration because otherwise there's a risk that it could get redundantly called numerous times, resulting in a needlessly slow configuration time. However, cmake targets don't have global scope (global imported targets aren't supported by cmake until [version 3.11](https://cmake.org/cmake/help/v3.11/prop_tgt/IMPORTED_GLOBAL.html)). Since the Gazebo config first gets loaded in the scope of library `L`'s CMakeLists.txt, its imported targets won't be visible in the scope of library `D`'s CMakeLists.txt because those scopes are parallel to each other. Nevertheless, the Gazebo config file won't reload in the scope of library `D` because it has already been loaded once for this project.\n\nBuilding the packages in isolated configurations is the safest and most sensible thing to do in all cases, not just in this particular case.", "markup": "markdown", "html": "<blockquote>\n<p>Will any package that has nodes that calls gazebo and has gazebo as a secondary dependency have this issue?</p>\n</blockquote>\n<p>Only if you use the old-fashioned <code>catkin_make</code>. There are good reasons that <code>catkin_make_isolated</code> and <code>catkin build</code> are the recommended ways to build workspaces these days.</p>\n<blockquote>\n<p>but since they don't have any nodes/libraries that call gazebo, they don't give me any errors.</p>\n</blockquote>\n<p>The error happened because <code>vgazebo_plugins</code> had a public dependency on targets like <code>protobuf::libprotobuf</code>. In cmake, the public dependencies of library <code>L</code> will get inherited by any downstream library <code>D</code> that calls <code>target_link_libraries(D [PUBLIC|PRIVATE} L)</code>.</p>\n<p>That means library <code>D</code> wanted to link against the target <code>protobuf::libprotobuf</code>. You got an error because the <code>CMakeLists.txt</code> for library <code>D</code> couldn't find a target named <code>protobuf::libprotobuf</code>. If each package were configured independently, then that error wouldn't happen. The error occurs because <code>catkin_make</code> unceremoniously smashes all the <code>CMakeLists.txt</code> of your workspace into one project configuration. The Gazebo config file is designed to only be invoked once per project configuration because otherwise there's a risk that it could get redundantly called numerous times, resulting in a needlessly slow configuration time. However, cmake targets don't have global scope (global imported targets aren't supported by cmake until <a data-is-external-link=\"true\" href=\"https://cmake.org/cmake/help/v3.11/prop_tgt/IMPORTED_GLOBAL.html\" rel=\"nofollow\">version 3.11</a>). Since the Gazebo config first gets loaded in the scope of library <code>L</code>'s CMakeLists.txt, its imported targets won't be visible in the scope of library <code>D</code>'s CMakeLists.txt because those scopes are parallel to each other. Nevertheless, the Gazebo config file won't reload in the scope of library <code>D</code> because it has already been loaded once for this project.</p>\n<p>Building the packages in isolated configurations is the safest and most sensible thing to do in all cases, not just in this particular case.</p>", "type": "rendered"}, "created_on": "2019-03-29T04:10:02.599993+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": null, "type": "issue_comment", "id": 51388228}