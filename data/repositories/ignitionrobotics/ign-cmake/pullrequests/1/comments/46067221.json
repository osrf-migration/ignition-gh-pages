{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-cmake/pullrequests/1/comments/46067221.json"}, "html": {"href": "#!/ignitionrobotics/ign-cmake/pull-requests/1/_/diff#comment-46067221"}}, "parent": {"id": 46065457, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-cmake/pullrequests/1/comments/46065457.json"}, "html": {"href": "#!/ignitionrobotics/ign-cmake/pull-requests/1/_/diff#comment-46065457"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-cmake/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-cmake/pull-requests/1"}}, "title": "First version of ignition-cmake"}, "content": {"raw": "~~We're already versioning all include paths, which is extremely important just to be able to install multiple major versions at a time. It would be extremely harmful to us (as developers) as well as end users to not use that practice.~~ (Edit: I probably misinterpreted \"version all include paths\". I agree that we should avoid having versions explicitly in the header paths that get included in source files. As [Shane already broke down](#!/ignitionrobotics/ign-cmake/pull-requests/1/first-version-of-ignition-cmake/diff#comment-46067933) it would be necessary if we wanted one target (along with the interfaces of its dependencies) to support multiple major versions, but I think it is fair to rule out that use case unless it becomes unavoidable.)\n\nVersioning namespaces would only be necessary if we wanted a single target to be able to build against multiple versions of the same library, which is certainly something that would be unusual, and which I would not at all encourage, because that would hurt the process of migrating dependent code to new versions.\n\nAs far as versioning the cmake variables is concerned, I don't think it's an unusual practice at all. In fact, what's less usual is having inconsistency between the name of the package and the variables it produces. E.g. `find_package(ignition-math3)` should conventionally produce variables of the form `ignition-math3_FOUND` (which is auto-generated by cmake), `ignition-math3_LIBRARIES`, `ignition-math3_INCLUDE_DIRS`, etc. Instead, our setup up until now has produced variables of the form `IGNITION-MATH_LIBRARIES` and `IGNITION-MATH_INCLUDE_DIRS`, which is inconsistent with the package name. If we want all uppercase variables, we should also make the package name all uppercase.\n\nFor one example of a notable library exercising this practice, `Qt` made the switch from versionless variables to versioned variables, as you can see [in this post](https://www.kdab.com/using-cmake-with-qt-5/). Granted, their system also involves module names which aren't exactly relevant to us, but the versioned variable concept is still there. I can look for more examples if desired. Admittedly, this may be a relatively new practice, but it has emerged out of necessity as people realize that sufficiently complex projects are likely to run into this issue.\n\nI'm not really clear on what the disadvantage of versioning the variables would be. Is the hope that keeping the variables unversioned would reduce friction in migrating to a new version? There are some pretty simple solutions to that, like using a cmake variable to specify which version you are using, so you only have to specify the desired version once.", "markup": "markdown", "html": "<p><del>We're already versioning all include paths, which is extremely important just to be able to install multiple major versions at a time. It would be extremely harmful to us (as developers) as well as end users to not use that practice.</del> (Edit: I probably misinterpreted \"version all include paths\". I agree that we should avoid having versions explicitly in the header paths that get included in source files. As <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-cmake/pull-requests/1/first-version-of-ignition-cmake/diff#comment-46067933\" rel=\"nofollow\">Shane already broke down</a> it would be necessary if we wanted one target (along with the interfaces of its dependencies) to support multiple major versions, but I think it is fair to rule out that use case unless it becomes unavoidable.)</p>\n<p>Versioning namespaces would only be necessary if we wanted a single target to be able to build against multiple versions of the same library, which is certainly something that would be unusual, and which I would not at all encourage, because that would hurt the process of migrating dependent code to new versions.</p>\n<p>As far as versioning the cmake variables is concerned, I don't think it's an unusual practice at all. In fact, what's less usual is having inconsistency between the name of the package and the variables it produces. E.g. <code>find_package(ignition-math3)</code> should conventionally produce variables of the form <code>ignition-math3_FOUND</code> (which is auto-generated by cmake), <code>ignition-math3_LIBRARIES</code>, <code>ignition-math3_INCLUDE_DIRS</code>, etc. Instead, our setup up until now has produced variables of the form <code>IGNITION-MATH_LIBRARIES</code> and <code>IGNITION-MATH_INCLUDE_DIRS</code>, which is inconsistent with the package name. If we want all uppercase variables, we should also make the package name all uppercase.</p>\n<p>For one example of a notable library exercising this practice, <code>Qt</code> made the switch from versionless variables to versioned variables, as you can see <a data-is-external-link=\"true\" href=\"https://www.kdab.com/using-cmake-with-qt-5/\" rel=\"nofollow\">in this post</a>. Granted, their system also involves module names which aren't exactly relevant to us, but the versioned variable concept is still there. I can look for more examples if desired. Admittedly, this may be a relatively new practice, but it has emerged out of necessity as people realize that sufficiently complex projects are likely to run into this issue.</p>\n<p>I'm not really clear on what the disadvantage of versioning the variables would be. Is the hope that keeping the variables unversioned would reduce friction in migrating to a new version? There are some pretty simple solutions to that, like using a cmake variable to specify which version you are using, so you only have to specify the desired version once.</p>", "type": "rendered"}, "created_on": "2017-09-28T18:46:09.101513+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-09-28T19:16:46.773687+00:00", "type": "pullrequest_comment", "id": 46067221}