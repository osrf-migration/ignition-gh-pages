{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-math/pullrequests/141/comments/30655566.json"}, "html": {"href": "#!/ignitionrobotics/ign-math/pull-requests/141/_/diff#comment-30655566"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 141, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-math/pullrequests/141.json"}, "html": {"href": "#!/ignitionrobotics/ign-math/pull-requests/141"}}, "title": "Graph"}, "content": {"raw": "I've been doing some research based on the feedback and before going too far I'd like to describe some of the API options:\n\nFor the shake of simplicity, let's focus on a function that creates a vertex and returns some handler (pointer, reference, etc.) to the vertex created. We can extrapolate the conclusions to the rest of the functions.\n \n\n**1.  std::shared_ptr (current approach):**\n\nFunction signature: \n```\n#!c++\n\nstd::shared_ptr<Vertex<V>> AddVertex(...);\n```\n How to use it: \n\n\n```\n#!c++\n\nauto v0 = graph.AddVertex(0, \"0\");\nif (v0)\n  std::cout << v0->Name();\n```\n\nPros: \n\n  * If the vertex cannot be created (e.g.: incorrect Id) you can return `nullptr`. \n  * If needed, it's possible to return a `std::vector` of `std::shared_ptr` (e.g.: `Vertexes()` function).\n\nCons:\n\n  * We're sharing ownership of the vertex with the client which we shouldn't.\n  * As all pointers, if used incorrectly can lead to a segfault.\n\n**2.  Reference to a vertex:**\n\nFunction signature: \n```\n#!c++\n\nVertex<V>& AddVertex(...);\n```\n How to use it: \n\n\n```\n#!c++\n\nauto v0 = graph.AddVertex(0, \"0\");\nstd::cout << v0.Name();\n```\n\nPros: \n\n  * No risk of segfault.\n  * Nice API.\n\nCons:\n\n  * There's no way to notify that the vertex cannot be created (e.g.: incorrect Id), we have to return a reference to an actual vertex (and maybe we don't have any).\n  * It's not possible to return a `std::vector` of `std::shared_ptr` (e.g.: `Vertexes()` function).\n\n\n**3.  std::reference_wrapper<Vertex<V>>:** I discover `std::reference_wrapper` doing this research. Apparently is a wrapper that allows to copy references and store them in STL containers.\n\nFunction signature: \n```\n#!c++\n\nstd::pair<bool, std::reference_wrapper<Vertex<V>>> AddVertex(...);\n```\n How to use it: \n\n\n```\n#!c++\n\nauto res = graph.AddVertex(0, \"0\");\nif (res.first)\n{\n  auto v = res.second.get();\n  std::cout << v0.Name();\n}\n```\n\nPros: \n\n  * If needed, it's possible to return a `std::vector` of `std::reference_wrapper`.\n  * No pointers, users cannot use them wrong.\n\nCons:\n\n  * Not so nice API.\n  * We can notify whether the vertex was created with the first boolean element of the returned tuple. However, we still need to return a reference to some vertex.\n\n**4.  std::weak_ptr:** \n\nFunction signature: \n```\n#!c++\n\nstd::weak_ptr<Vertex<V>> AddVertex(...);\n```\n How to use it: \n\n\n```\n#!c++\n\nauto wpV0 = graph.AddVertex(0, \"0\");\nauto v0 = wpV0.lock();\nif (v0)\n{\n  std::cout << v0->Name();\n}\n```\n\nPros: \n\n  * If the vertex cannot be created (e.g.: incorrect Id) you can return `nullptr`. \n  * If needed, it's possible to return a `std::vector` of `std::weak_ptr` (e.g.: `Vertexes()` function).\n\nCons:\n\n  * Slightly uglier API.\n  * As all pointers, if used incorrectly can lead to a segfault.\n\n@nkoenig and @chapulina suggested to use references but there are a few issues. I feel that option (4) is the one that fits better although I confess that the API is not my favorite. Opinions or other comments/ideas?", "markup": "markdown", "html": "<p>I've been doing some research based on the feedback and before going too far I'd like to describe some of the API options:</p>\n<p>For the shake of simplicity, let's focus on a function that creates a vertex and returns some handler (pointer, reference, etc.) to the vertex created. We can extrapolate the conclusions to the rest of the functions.</p>\n<p><strong>1.  std::shared_ptr (current approach):</strong></p>\n<p>Function signature: </p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">shared_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">Vertex</span><span class=\"o\">&lt;</span><span class=\"n\">V</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">AddVertex</span><span class=\"p\">(...);</span>\n</pre></div>\n\n\n<p>How to use it: </p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"k\">auto</span> <span class=\"n\">v0</span> <span class=\"o\">=</span> <span class=\"n\">graph</span><span class=\"p\">.</span><span class=\"n\">AddVertex</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"s\">&quot;0&quot;</span><span class=\"p\">);</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v0</span><span class=\"p\">)</span>\n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">v0</span><span class=\"o\">-&gt;</span><span class=\"n\">Name</span><span class=\"p\">();</span>\n</pre></div>\n\n\n<p>Pros: </p>\n<ul>\n<li>If the vertex cannot be created (e.g.: incorrect Id) you can return <code>nullptr</code>. </li>\n<li>If needed, it's possible to return a <code>std::vector</code> of <code>std::shared_ptr</code> (e.g.: <code>Vertexes()</code> function).</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>We're sharing ownership of the vertex with the client which we shouldn't.</li>\n<li>As all pointers, if used incorrectly can lead to a segfault.</li>\n</ul>\n<p><strong>2.  Reference to a vertex:</strong></p>\n<p>Function signature: </p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"n\">Vertex</span><span class=\"o\">&lt;</span><span class=\"n\">V</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">AddVertex</span><span class=\"p\">(...);</span>\n</pre></div>\n\n\n<p>How to use it: </p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"k\">auto</span> <span class=\"n\">v0</span> <span class=\"o\">=</span> <span class=\"n\">graph</span><span class=\"p\">.</span><span class=\"n\">AddVertex</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"s\">&quot;0&quot;</span><span class=\"p\">);</span>\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">v0</span><span class=\"p\">.</span><span class=\"n\">Name</span><span class=\"p\">();</span>\n</pre></div>\n\n\n<p>Pros: </p>\n<ul>\n<li>No risk of segfault.</li>\n<li>Nice API.</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>There's no way to notify that the vertex cannot be created (e.g.: incorrect Id), we have to return a reference to an actual vertex (and maybe we don't have any).</li>\n<li>It's not possible to return a <code>std::vector</code> of <code>std::shared_ptr</code> (e.g.: <code>Vertexes()</code> function).</li>\n</ul>\n<p><strong>3.  std::reference_wrapper&lt;Vertex&lt;V&gt;&gt;:</strong> I discover <code>std::reference_wrapper</code> doing this research. Apparently is a wrapper that allows to copy references and store them in STL containers.</p>\n<p>Function signature: </p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">pair</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">reference_wrapper</span><span class=\"o\">&lt;</span><span class=\"n\">Vertex</span><span class=\"o\">&lt;</span><span class=\"n\">V</span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">AddVertex</span><span class=\"p\">(...);</span>\n</pre></div>\n\n\n<p>How to use it: </p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"k\">auto</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">graph</span><span class=\"p\">.</span><span class=\"n\">AddVertex</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"s\">&quot;0&quot;</span><span class=\"p\">);</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">.</span><span class=\"n\">first</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">auto</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">res</span><span class=\"p\">.</span><span class=\"n\">second</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span>\n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">v0</span><span class=\"p\">.</span><span class=\"n\">Name</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>Pros: </p>\n<ul>\n<li>If needed, it's possible to return a <code>std::vector</code> of <code>std::reference_wrapper</code>.</li>\n<li>No pointers, users cannot use them wrong.</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>Not so nice API.</li>\n<li>We can notify whether the vertex was created with the first boolean element of the returned tuple. However, we still need to return a reference to some vertex.</li>\n</ul>\n<p><strong>4.  std::weak_ptr:</strong> </p>\n<p>Function signature: </p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">weak_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">Vertex</span><span class=\"o\">&lt;</span><span class=\"n\">V</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">AddVertex</span><span class=\"p\">(...);</span>\n</pre></div>\n\n\n<p>How to use it: </p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"k\">auto</span> <span class=\"n\">wpV0</span> <span class=\"o\">=</span> <span class=\"n\">graph</span><span class=\"p\">.</span><span class=\"n\">AddVertex</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"s\">&quot;0&quot;</span><span class=\"p\">);</span>\n<span class=\"k\">auto</span> <span class=\"n\">v0</span> <span class=\"o\">=</span> <span class=\"n\">wpV0</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">();</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v0</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">v0</span><span class=\"o\">-&gt;</span><span class=\"n\">Name</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>Pros: </p>\n<ul>\n<li>If the vertex cannot be created (e.g.: incorrect Id) you can return <code>nullptr</code>. </li>\n<li>If needed, it's possible to return a <code>std::vector</code> of <code>std::weak_ptr</code> (e.g.: <code>Vertexes()</code> function).</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>Slightly uglier API.</li>\n<li>As all pointers, if used incorrectly can lead to a segfault.</li>\n</ul>\n<p>@nkoenig and @chapulina suggested to use references but there are a few issues. I feel that option (4) is the one that fits better although I confess that the API is not my favorite. Opinions or other comments/ideas?</p>", "type": "rendered"}, "created_on": "2017-01-31T22:32:04.612730+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "updated_on": "2017-01-31T22:32:04.666240+00:00", "type": "pullrequest_comment", "id": 30655566}