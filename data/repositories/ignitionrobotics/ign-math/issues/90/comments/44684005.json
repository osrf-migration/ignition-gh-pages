{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-math/issues/90/comments/44684005.json"}, "html": {"href": "#!/ignitionrobotics/ign-math/issues/90#comment-44684005"}}, "issue": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-math/issues/90.json"}}, "type": "issue", "id": 90, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-math.json"}, "html": {"href": "#!/ignitionrobotics/ign-math"}, "avatar": {"href": "data/bytebucket.org/ravatar/{18503e50-08ea-4d88-ab99-110fde3c7256}ts=1533305"}}, "type": "repository", "name": "ign-math", "full_name": "ignitionrobotics/ign-math", "uuid": "{18503e50-08ea-4d88-ab99-110fde3c7256}"}, "title": "Add sphere and cylinder shapes"}, "content": {"raw": "To elaborate a little more on my thoughts, I definitely agree that mathematical representations of various shapes are valuable. Putting that into `ign-math` makes a lot of sense, since it would give various ignition projects an upstream way of communicating about geometry information.\n\nThe design concerns that I have in mind right now are the following:\n\n### Do we want to have geometry abstraction? And if so, what library does it belong in?\n\nIt can be very useful to have an abstraction for the concept of a \"geometric shape\". For example, it's useful if you can pass an arbitrary shape (whether it's a `Circle`, `Cylinder`, `Box`, `Mesh`, etc) to a collision detection engine or a rendering engine and expect it to handle the shape correctly. It's especially valuable if this is clean and extensible, e.g.:\n\n```\nclass CollisionDetector\n{\npublic:\n  CollisionObjectPtr AddShape(const Shape& shape);\n};\n```\n\nwhere `Shape` can be any of a number of types, instead of something like:\n\n```\nclass CollisionDetector\n{\npublic:\n\n  CollisionObjectPtr AddShape(const Sphere& sphere);\n\n  CollisionObjectPtr AddShape(const Box& box);\n\n  CollisionObjectPtr AddShape(const Cylinder& cylinder);\n\n  // ... and so on ...\n};\n```\n\nThis would require the `Shape` class to provide a pure virtual interface for the various shape types to inherit and implement. That means these shape types would have virtual functions and have some level of sophistication, which we should carefully design.\n\nIt sounds like your proposal is to have relatively plain data types for `Sphere` and `Cylinder` that only contain the minimal parameters needed to describe a \"sphere\" or \"cylinder\" concept. I think it makes a *lot* of sense to provide such classes, and I'm definitely in favor of doing so.\n\nHowever, the idea of more sophisticated abstract shape classes could be useful to both physics and rendering (and maybe other projects?), so it might make sense for them to share the implementation of that inside of `ign-math`. In that case, we would probably want `ignition::math::Sphere` to be the more sophisticated abstracted shape type instead of a simple class that just holds a radius parameter. Maybe we would actually want the plain sphere parameter class to be named something like `ignition::math::SphereParameters` or `ignition::math::Sphere::Parameters`. If we consistently use the nested `::Parameters` class pattern across all of the shape types, it would allow us (and users) to do some really fancy template programming. However, these things would be painful to introduce if those class names are already occupied (in fact, I think there would already be some pain caused by the existence of the `ignition::math::Box` class).\n\n### Do we want to template the shape classes for 2D vs 3D?\n\nThe Feature System proposal in `ign-physics` would allow us to very easily and cleanly support physics interfaces that can be shared between 2D and 3D simulation frameworks. However, it will require that our mathematical representations are templated for 2D and 3D information. This is very straightforward to implement using a template library like `Eigen`, and we could offer shape classes like:\n\n```\ntemplate<typename Precision, unsigned int Dimension>\nclass Ball : public Shape<Precision, Dimension>\n{\n  public: Precision& Radius() { return radius; }\n  public: const Precision& Radius() const { return radius; }\n\n  private: Precision radius;\n};\n\nusing Ball3d = Ball<double, 3>;\nusing Ball2d = Ball<double, 2>;\nusing Sphere = Ball3d;\nusing Circle = Ball2d;\n\ntemplate<typename Precision, unsigned int Dimension>\nclass Box : public Shape<Precision, Dimension>\n{\n  public: Precision& operator[](unsigned int i) { return parameters[i]; }\n\n  public: Precision& XLength() { return parameters[0]; }\n  public: Precision& YLength() { return parameters[1]; }\n  \n  // Template magic that makes this only compile when Dimension==3\n  public : Precision& ZLength() { return parameters[2]; }\n\n  private: Eigen::Matrix<Precision, Dimension, 1> parameters;\n};\n\nusing Box3d = Box<double, 3>;\nusing Box2d = Box<double, 2>;\n```", "markup": "markdown", "html": "<p>To elaborate a little more on my thoughts, I definitely agree that mathematical representations of various shapes are valuable. Putting that into <code>ign-math</code> makes a lot of sense, since it would give various ignition projects an upstream way of communicating about geometry information.</p>\n<p>The design concerns that I have in mind right now are the following:</p>\n<h3 id=\"markdown-header-do-we-want-to-have-geometry-abstraction-and-if-so-what-library-does-it-belong-in\">Do we want to have geometry abstraction? And if so, what library does it belong in?</h3>\n<p>It can be very useful to have an abstraction for the concept of a \"geometric shape\". For example, it's useful if you can pass an arbitrary shape (whether it's a <code>Circle</code>, <code>Cylinder</code>, <code>Box</code>, <code>Mesh</code>, etc) to a collision detection engine or a rendering engine and expect it to handle the shape correctly. It's especially valuable if this is clean and extensible, e.g.:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kr\">class</span> <span class=\"nx\">CollisionDetector</span>\n<span class=\"p\">{</span>\n<span class=\"kr\">public</span><span class=\"o\">:</span>\n  <span class=\"nx\">CollisionObjectPtr</span> <span class=\"nx\">AddShape</span><span class=\"p\">(</span><span class=\"kr\">const</span> <span class=\"nx\">Shape</span><span class=\"o\">&amp;</span> <span class=\"nx\">shape</span><span class=\"p\">);</span>\n<span class=\"p\">};</span>\n</pre></div>\n\n\n<p>where <code>Shape</code> can be any of a number of types, instead of something like:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kr\">class</span> <span class=\"nx\">CollisionDetector</span>\n<span class=\"p\">{</span>\n<span class=\"kr\">public</span><span class=\"o\">:</span>\n\n  <span class=\"nx\">CollisionObjectPtr</span> <span class=\"nx\">AddShape</span><span class=\"p\">(</span><span class=\"kr\">const</span> <span class=\"nx\">Sphere</span><span class=\"o\">&amp;</span> <span class=\"nx\">sphere</span><span class=\"p\">);</span>\n\n  <span class=\"nx\">CollisionObjectPtr</span> <span class=\"nx\">AddShape</span><span class=\"p\">(</span><span class=\"kr\">const</span> <span class=\"nx\">Box</span><span class=\"o\">&amp;</span> <span class=\"nx\">box</span><span class=\"p\">);</span>\n\n  <span class=\"nx\">CollisionObjectPtr</span> <span class=\"nx\">AddShape</span><span class=\"p\">(</span><span class=\"kr\">const</span> <span class=\"nx\">Cylinder</span><span class=\"o\">&amp;</span> <span class=\"nx\">cylinder</span><span class=\"p\">);</span>\n\n  <span class=\"c1\">// ... and so on ...</span>\n<span class=\"p\">};</span>\n</pre></div>\n\n\n<p>This would require the <code>Shape</code> class to provide a pure virtual interface for the various shape types to inherit and implement. That means these shape types would have virtual functions and have some level of sophistication, which we should carefully design.</p>\n<p>It sounds like your proposal is to have relatively plain data types for <code>Sphere</code> and <code>Cylinder</code> that only contain the minimal parameters needed to describe a \"sphere\" or \"cylinder\" concept. I think it makes a <em>lot</em> of sense to provide such classes, and I'm definitely in favor of doing so.</p>\n<p>However, the idea of more sophisticated abstract shape classes could be useful to both physics and rendering (and maybe other projects?), so it might make sense for them to share the implementation of that inside of <code>ign-math</code>. In that case, we would probably want <code>ignition::math::Sphere</code> to be the more sophisticated abstracted shape type instead of a simple class that just holds a radius parameter. Maybe we would actually want the plain sphere parameter class to be named something like <code>ignition::math::SphereParameters</code> or <code>ignition::math::Sphere::Parameters</code>. If we consistently use the nested <code>::Parameters</code> class pattern across all of the shape types, it would allow us (and users) to do some really fancy template programming. However, these things would be painful to introduce if those class names are already occupied (in fact, I think there would already be some pain caused by the existence of the <code>ignition::math::Box</code> class).</p>\n<h3 id=\"markdown-header-do-we-want-to-template-the-shape-classes-for-2d-vs-3d\">Do we want to template the shape classes for 2D vs 3D?</h3>\n<p>The Feature System proposal in <code>ign-physics</code> would allow us to very easily and cleanly support physics interfaces that can be shared between 2D and 3D simulation frameworks. However, it will require that our mathematical representations are templated for 2D and 3D information. This is very straightforward to implement using a template library like <code>Eigen</code>, and we could offer shape classes like:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"nx\">template</span><span class=\"o\">&lt;</span><span class=\"nx\">typename</span> <span class=\"nx\">Precision</span><span class=\"p\">,</span> <span class=\"nx\">unsigned</span> <span class=\"kr\">int</span> <span class=\"nx\">Dimension</span><span class=\"o\">&gt;</span>\n<span class=\"kr\">class</span> <span class=\"nx\">Ball</span> : <span class=\"kt\">public</span> <span class=\"nx\">Shape</span><span class=\"o\">&lt;</span><span class=\"nx\">Precision</span><span class=\"p\">,</span> <span class=\"nx\">Dimension</span><span class=\"o\">&gt;</span>\n<span class=\"p\">{</span>\n  <span class=\"kr\">public</span><span class=\"o\">:</span> <span class=\"nx\">Precision</span><span class=\"o\">&amp;</span> <span class=\"nx\">Radius() {</span> <span class=\"k\">return</span> <span class=\"nx\">radius</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n  <span class=\"kr\">public</span><span class=\"o\">:</span> <span class=\"kr\">const</span> <span class=\"nx\">Precision</span><span class=\"o\">&amp;</span> <span class=\"nx\">Radius</span><span class=\"p\">()</span> <span class=\"kr\">const</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"nx\">radius</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n\n  <span class=\"kr\">private</span><span class=\"o\">:</span> <span class=\"nx\">Precision</span> <span class=\"nx\">radius</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"nx\">using</span> <span class=\"nx\">Ball3d</span> <span class=\"o\">=</span> <span class=\"nx\">Ball</span><span class=\"o\">&lt;</span><span class=\"kr\">double</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n<span class=\"nx\">using</span> <span class=\"nx\">Ball2d</span> <span class=\"o\">=</span> <span class=\"nx\">Ball</span><span class=\"o\">&lt;</span><span class=\"kr\">double</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n<span class=\"nx\">using</span> <span class=\"nx\">Sphere</span> <span class=\"o\">=</span> <span class=\"nx\">Ball3d</span><span class=\"p\">;</span>\n<span class=\"nx\">using</span> <span class=\"nx\">Circle</span> <span class=\"o\">=</span> <span class=\"nx\">Ball2d</span><span class=\"p\">;</span>\n\n<span class=\"nx\">template</span><span class=\"o\">&lt;</span><span class=\"nx\">typename</span> <span class=\"nx\">Precision</span><span class=\"p\">,</span> <span class=\"nx\">unsigned</span> <span class=\"kr\">int</span> <span class=\"nx\">Dimension</span><span class=\"o\">&gt;</span>\n<span class=\"kr\">class</span> <span class=\"nx\">Box</span> : <span class=\"kt\">public</span> <span class=\"nx\">Shape</span><span class=\"o\">&lt;</span><span class=\"nx\">Precision</span><span class=\"p\">,</span> <span class=\"nx\">Dimension</span><span class=\"o\">&gt;</span>\n<span class=\"p\">{</span>\n  <span class=\"kr\">public</span><span class=\"o\">:</span> <span class=\"nx\">Precision</span><span class=\"o\">&amp;</span> <span class=\"nx\">operator</span><span class=\"p\">[](</span><span class=\"nx\">unsigned</span> <span class=\"kr\">int</span> <span class=\"nx\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"nx\">parameters</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">];</span> <span class=\"p\">}</span>\n\n  <span class=\"kr\">public</span><span class=\"o\">:</span> <span class=\"nx\">Precision</span><span class=\"o\">&amp;</span> <span class=\"nx\">XLength() {</span> <span class=\"k\">return</span> <span class=\"nx\">parameters</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span> <span class=\"p\">}</span>\n  <span class=\"kr\">public</span><span class=\"o\">:</span> <span class=\"nx\">Precision</span><span class=\"o\">&amp;</span> <span class=\"nx\">YLength() {</span> <span class=\"k\">return</span> <span class=\"nx\">parameters</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span> <span class=\"p\">}</span>\n\n  <span class=\"c1\">// Template magic that makes this only compile when Dimension==3</span>\n  <span class=\"kr\">public</span> <span class=\"o\">:</span> <span class=\"nx\">Precision</span><span class=\"o\">&amp;</span> <span class=\"nx\">ZLength() {</span> <span class=\"k\">return</span> <span class=\"nx\">parameters</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span> <span class=\"p\">}</span>\n\n  <span class=\"kr\">private</span><span class=\"o\">:</span> <span class=\"nx\">Eigen</span><span class=\"o\">::</span><span class=\"nx\">Matrix</span><span class=\"o\">&lt;</span><span class=\"nx\">Precision</span><span class=\"p\">,</span> <span class=\"nx\">Dimension</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span> <span class=\"nx\">parameters</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"nx\">using</span> <span class=\"nx\">Box3d</span> <span class=\"o\">=</span> <span class=\"nx\">Box</span><span class=\"o\">&lt;</span><span class=\"kr\">double</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n<span class=\"nx\">using</span> <span class=\"nx\">Box2d</span> <span class=\"o\">=</span> <span class=\"nx\">Box</span><span class=\"o\">&lt;</span><span class=\"kr\">double</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n</pre></div>", "type": "rendered"}, "created_on": "2018-04-14T00:39:17.624759+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": null, "type": "issue_comment", "id": 44684005}