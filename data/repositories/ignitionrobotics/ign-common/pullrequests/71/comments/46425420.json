{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-common/pullrequests/71/comments/46425420.json"}, "html": {"href": "#!/ignitionrobotics/ign-common/pull-requests/71/_/diff#comment-46425420"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 71, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-common/pullrequests/71.json"}, "html": {"href": "#!/ignitionrobotics/ign-common/pull-requests/71"}}, "title": "PluginPtrSemantics minus CRTP and SFINAE"}, "content": {"raw": "Naturally I have some concerns about removing the ~~SFINAE~~ (edit: We're actually using template specialization here, not SFINAE). From the perspective of the physics design, nearly every function that we call from a plugin is going to be masked by a call to `Interface<T>()`. A map lookup might not sound like much, but imagine replacing the cost of every function call in the physics pipeline with the cost of a map lookup. Of course we could dodge that by retrieving all the relevant interfaces from the plugin once when the plugin is loaded and then manually managing all of those interface pointers, but that would expose us to multiple-source-of-truth issues and it would be very bug prone, not to mention a major increase in maintenance effort. The plugin specialization framework effectively automates all of that interface management for us so that we get both clean semantics (single-source-of-truth) and high performance (no map lookups when they aren't necessary).\n\nThe `PluginPtr` can be replaced with `std::shared_ptr` if we take out the plugin specialization, but if we were to keep plugin specialization, we would need to keep the `PluginPtr` as well. (Believe me, I'd much prefer `std::shared_ptr` over our own custom smart pointer, but `std::shared_ptr` wouldn't jive with plugin specializations.)\n\n", "markup": "markdown", "html": "<p>Naturally I have some concerns about removing the <del>SFINAE</del> (edit: We're actually using template specialization here, not SFINAE). From the perspective of the physics design, nearly every function that we call from a plugin is going to be masked by a call to <code>Interface&lt;T&gt;()</code>. A map lookup might not sound like much, but imagine replacing the cost of every function call in the physics pipeline with the cost of a map lookup. Of course we could dodge that by retrieving all the relevant interfaces from the plugin once when the plugin is loaded and then manually managing all of those interface pointers, but that would expose us to multiple-source-of-truth issues and it would be very bug prone, not to mention a major increase in maintenance effort. The plugin specialization framework effectively automates all of that interface management for us so that we get both clean semantics (single-source-of-truth) and high performance (no map lookups when they aren't necessary).</p>\n<p>The <code>PluginPtr</code> can be replaced with <code>std::shared_ptr</code> if we take out the plugin specialization, but if we were to keep plugin specialization, we would need to keep the <code>PluginPtr</code> as well. (Believe me, I'd much prefer <code>std::shared_ptr</code> over our own custom smart pointer, but <code>std::shared_ptr</code> wouldn't jive with plugin specializations.)</p>", "type": "rendered"}, "created_on": "2017-10-04T17:08:06.097740+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-10-04T17:28:41.209187+00:00", "type": "pullrequest_comment", "id": 46425420}