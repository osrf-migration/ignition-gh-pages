{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-common/pullrequests/73/comments/49001320.json"}, "code": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-common/diff/ignitionrobotics/ign-common:67dc7b12b50f..76d416addd2f?path=src%2FPlugin.cc"}, "html": {"href": "#!/ignitionrobotics/ign-common/pull-requests/73/_/diff#comment-49001320"}}, "parent": {"id": 48999364, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-common/pullrequests/73/comments/48999364.json"}, "html": {"href": "#!/ignitionrobotics/ign-common/pull-requests/73/_/diff#comment-48999364"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 73, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-common/pullrequests/73.json"}, "html": {"href": "#!/ignitionrobotics/ign-common/pull-requests/73"}}, "title": "Slimmed down the Plugin pull request (no more template specializations)"}, "content": {"raw": "I wouldn't call it a bug in `std::unique_ptr`; I'd say that the earlier implementation of `PluginLoader` was abusing `std::unique_ptr`. What it boils down to is: We have no way of ensuring or enforcing that the interface type which we give to the `std::unique_ptr` has a virtual destructor, which means that if `delete` is called on a pointer to the interface, then the object will not get deleted correctly, and this could result in memory leaks or exceptions.\n\n`std::shared_ptr` allows us to get around this concern using aliasing, which is something that `std::unique_ptr` cannot offer. The `std::shared_ptr` internally (opaquely) contains a pointer to the most-derived address of the object, and it will call `delete` on that most-derived pointer, so it won't matter whether any of its interfaces' destructors are virtual.\n\nWe could tweak the way we use `std::unique_ptr` to give it a stateful destructor, but this would not solve the problem you're running into, and it would also eliminate the benefit of using a generic smart pointer type, because the stateful destructor becomes a part of the `std::unique_ptr`'s type information, making it no longer generic.\n\n> I think I was treating the PluginLoader as a factory and I didn't expect it to be responsible for the plugin's lifecycle. Can't it serve this purpose as well?\n\nIt does serve this purpose. `PluginLoader` itself is not responsible for the plugin's lifecycle; the smart pointer that it returns is responsible (either the `PluginPtr` or the `std::shared_ptr`).\n\nAdmittedly, if you're using pull request #61, then things get hairy if you load a factory which spawns objects that depend on the dynamically loaded library. In this current pull request, plugin libraries never get unloaded, so this isn't a concern right now. However, I don't really think that's acceptable behavior. I would view it as a kind of memory leak where we will forever (until the program quits) occupy memory space, regardless of whether the contents of that memory space are still needed. I don't think it would be a good idea to abandon rigorous memory management for the sake of developer convenience, since I would view that as a form of technical debt.\n\nTo determine how badly this affects your setup, maybe we can have a discussion some time about how exactly you're using (or expect to use) the `PluginLoader`. If you keep one persistent `PluginLoader` instance alive throughout the duration of your program, then the library management concerns should be a non-issue.", "markup": "markdown", "html": "<p>I wouldn't call it a bug in <code>std::unique_ptr</code>; I'd say that the earlier implementation of <code>PluginLoader</code> was abusing <code>std::unique_ptr</code>. What it boils down to is: We have no way of ensuring or enforcing that the interface type which we give to the <code>std::unique_ptr</code> has a virtual destructor, which means that if <code>delete</code> is called on a pointer to the interface, then the object will not get deleted correctly, and this could result in memory leaks or exceptions.</p>\n<p><code>std::shared_ptr</code> allows us to get around this concern using aliasing, which is something that <code>std::unique_ptr</code> cannot offer. The <code>std::shared_ptr</code> internally (opaquely) contains a pointer to the most-derived address of the object, and it will call <code>delete</code> on that most-derived pointer, so it won't matter whether any of its interfaces' destructors are virtual.</p>\n<p>We could tweak the way we use <code>std::unique_ptr</code> to give it a stateful destructor, but this would not solve the problem you're running into, and it would also eliminate the benefit of using a generic smart pointer type, because the stateful destructor becomes a part of the <code>std::unique_ptr</code>'s type information, making it no longer generic.</p>\n<blockquote>\n<p>I think I was treating the PluginLoader as a factory and I didn't expect it to be responsible for the plugin's lifecycle. Can't it serve this purpose as well?</p>\n</blockquote>\n<p>It does serve this purpose. <code>PluginLoader</code> itself is not responsible for the plugin's lifecycle; the smart pointer that it returns is responsible (either the <code>PluginPtr</code> or the <code>std::shared_ptr</code>).</p>\n<p>Admittedly, if you're using <a href=\"#!/ignitionrobotics/ign-common/pull-requests/61/automatically-unloading-libraries-when\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #61</a>, then things get hairy if you load a factory which spawns objects that depend on the dynamically loaded library. In this current pull request, plugin libraries never get unloaded, so this isn't a concern right now. However, I don't really think that's acceptable behavior. I would view it as a kind of memory leak where we will forever (until the program quits) occupy memory space, regardless of whether the contents of that memory space are still needed. I don't think it would be a good idea to abandon rigorous memory management for the sake of developer convenience, since I would view that as a form of technical debt.</p>\n<p>To determine how badly this affects your setup, maybe we can have a discussion some time about how exactly you're using (or expect to use) the <code>PluginLoader</code>. If you keep one persistent <code>PluginLoader</code> instance alive throughout the duration of your program, then the library management concerns should be a non-issue.</p>", "type": "rendered"}, "created_on": "2017-11-07T21:07:40.257363+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {"to": null, "from": null, "outdated": true, "path": "src/Plugin.cc"}, "updated_on": "2017-11-07T21:24:44.907179+00:00", "type": "pullrequest_comment", "id": 49001320}