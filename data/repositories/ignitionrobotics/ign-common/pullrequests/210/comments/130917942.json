{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-common/pullrequests/210/comments/130917942.json"}, "html": {"href": "#!/ignitionrobotics/ign-common/pull-requests/210/_/diff#comment-130917942"}}, "parent": {"id": 130752294, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-common/pullrequests/210/comments/130752294.json"}, "html": {"href": "#!/ignitionrobotics/ign-common/pull-requests/210/_/diff#comment-130752294"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 210, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-common/pullrequests/210.json"}, "html": {"href": "#!/ignitionrobotics/ign-common/pull-requests/210"}}, "title": "[Proposal] Custom paths for file URIs"}, "content": {"raw": "The use case is to support search paths that are defined by the user at load time. We typically do this with environment variables, which `SystemPaths` already supports. \n\nCustom callbacks are one way of finding files from outside of `ign-common`, but if we want to use that to expose environment variables for a downstream application such as `ign-gazebo`, we'd need to reimplement a lot of the logic already contained inside `common::SystemPaths`.\n\nThe piece currently missing here is that `ign-common`'s handling of URIs is limited to custom callbacks specific to URIs (added through `AddFindFileURICallback`). When it comes to paths added with `AddFilePaths` or coming from an environment variable, `SystemPaths` treats URIs as if they were relative paths. For example:\n\n~~~\n# IGN_FILE_PATH=/abc\nsystemPaths.AddFilePaths(\"/def\");\nsystemPaths.FindFile(\"model://filename\");\n// Searches for:\n// * /abc/model://filename\n// * /def/model://filename\n~~~\n\nWith this PR, the `model://` would be stripped and we'd search for `/abc/filename` and `/def/filename`.\n\nAs I mentioned above, maybe just ignoring the scheme is not great. But that's the least invasive way that I found to get URIs to play well with the rest of the API.\n\n---\n\n## Alternatives considered\n\n* Do something similar to SDF's [g_uriPathMap](https://bitbucket.org/osrf/sdformat/src/28e36804b35a4c3a844d49030e80c8721299c426/src/SDF.cc#lines-45). But I think a clean implementation for that would require the entire `SystemPaths` API to be scheme-aware. That is, every path added with `AddFilePaths` or an environment variable could have an optional scheme associated to them.\n* Implement a custom URI callback that strips the scheme and then calls `SystemPaths::FindFile` again with a relative path. I think it could work, but feels hacky when the path could just be handled from within `ign-common`.\n* Don't use URIs, only use relative paths. I think that's valid, but it would essentially mean that models that work with Gazebo-classic won't work with Ignition. I think that would significantly increase the migration efforts, but what worries me the most is that we wouldn't be able to reuse models across classic and Ignition.", "markup": "markdown", "html": "<p>The use case is to support search paths that are defined by the user at load time. We typically do this with environment variables, which <code>SystemPaths</code> already supports. </p>\n<p>Custom callbacks are one way of finding files from outside of <code>ign-common</code>, but if we want to use that to expose environment variables for a downstream application such as <code>ign-gazebo</code>, we'd need to reimplement a lot of the logic already contained inside <code>common::SystemPaths</code>.</p>\n<p>The piece currently missing here is that <code>ign-common</code>'s handling of URIs is limited to custom callbacks specific to URIs (added through <code>AddFindFileURICallback</code>). When it comes to paths added with <code>AddFilePaths</code> or coming from an environment variable, <code>SystemPaths</code> treats URIs as if they were relative paths. For example:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"err\">#</span> <span class=\"nt\">IGN_FILE_PATH</span><span class=\"o\">=/</span><span class=\"nt\">abc</span>\n<span class=\"nt\">systemPaths</span><span class=\"p\">.</span><span class=\"nc\">AddFilePaths</span><span class=\"o\">(</span><span class=\"s2\">&quot;/def&quot;</span><span class=\"o\">);</span>\n<span class=\"nt\">systemPaths</span><span class=\"p\">.</span><span class=\"nc\">FindFile</span><span class=\"o\">(</span><span class=\"s2\">&quot;model://filename&quot;</span><span class=\"o\">);</span>\n<span class=\"o\">//</span> <span class=\"nt\">Searches</span> <span class=\"nt\">for</span><span class=\"o\">:</span>\n<span class=\"o\">//</span> <span class=\"o\">*</span> <span class=\"o\">/</span><span class=\"nt\">abc</span><span class=\"o\">/</span><span class=\"nt\">model</span><span class=\"o\">://</span><span class=\"nt\">filename</span>\n<span class=\"o\">//</span> <span class=\"o\">*</span> <span class=\"o\">/</span><span class=\"nt\">def</span><span class=\"o\">/</span><span class=\"nt\">model</span><span class=\"o\">://</span><span class=\"nt\">filename</span>\n</pre></div>\n\n\n<p>With this PR, the <code>model://</code> would be stripped and we'd search for <code>/abc/filename</code> and <code>/def/filename</code>.</p>\n<p>As I mentioned above, maybe just ignoring the scheme is not great. But that's the least invasive way that I found to get URIs to play well with the rest of the API.</p>\n<hr />\n<h2 id=\"markdown-header-alternatives-considered\">Alternatives considered</h2>\n<ul>\n<li>Do something similar to SDF's <a data-is-external-link=\"true\" href=\"https://bitbucket.org/osrf/sdformat/src/28e36804b35a4c3a844d49030e80c8721299c426/src/SDF.cc#lines-45\" rel=\"nofollow\">g_uriPathMap</a>. But I think a clean implementation for that would require the entire <code>SystemPaths</code> API to be scheme-aware. That is, every path added with <code>AddFilePaths</code> or an environment variable could have an optional scheme associated to them.</li>\n<li>Implement a custom URI callback that strips the scheme and then calls <code>SystemPaths::FindFile</code> again with a relative path. I think it could work, but feels hacky when the path could just be handled from within <code>ign-common</code>.</li>\n<li>Don't use URIs, only use relative paths. I think that's valid, but it would essentially mean that models that work with Gazebo-classic won't work with Ignition. I think that would significantly increase the migration efforts, but what worries me the most is that we wouldn't be able to reuse models across classic and Ignition.</li>\n</ul>", "type": "rendered"}, "created_on": "2020-01-08T19:43:41.616325+00:00", "user": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}, "updated_on": "2020-01-08T19:43:41.626801+00:00", "type": "pullrequest_comment", "id": 130917942}