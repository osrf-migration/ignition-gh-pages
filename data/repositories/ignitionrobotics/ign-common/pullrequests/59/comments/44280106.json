{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-common/pullrequests/59/comments/44280106.json"}, "code": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-common/diff/ignitionrobotics/ign-common:065d8e626b60..2f74d2f0ebe5?path=include%2Fignition%2Fcommon%2FPluginPtr.hh"}, "html": {"href": "#!/ignitionrobotics/ign-common/pull-requests/59/_/diff#comment-44280106"}}, "parent": {"id": 44022585, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-common/pullrequests/59/comments/44022585.json"}, "html": {"href": "#!/ignitionrobotics/ign-common/pull-requests/59/_/diff#comment-44022585"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 59, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-common/pullrequests/59.json"}, "html": {"href": "#!/ignitionrobotics/ign-common/pull-requests/59"}}, "title": "Expanding the functionality of the plugin framework, and introducing PluginPtr and specializations"}, "content": {"raw": "The reason is admittedly kind of unintuitive, but it relates to \"casting\" between Plugin specializations.\n\nWe use the `Plugin` class as a completely generic object that provides access to the interfaces of a plugin instance that has been loaded by the `PluginLoader`. The generic `Plugin` class also serves as a base class for the many various `SpecializedPlugin<...>` classes that might get instantiated. We want to be able to \"cast\" a plugin from the generic `Plugin` type to the specialized (more-derived) `SpecializedPlugin<...>` types. `std::shared_ptr` offers the usual `static_cast` and `dynamic_cast`, but neither of those will work for us, because generally an instance of a `Plugin` is not secretly an instance of a `SpecializedPlugin<...>`. Moreover, an instance of a `SpecializedPlugin<A, B, C>` will not secretly be an instance of a `SpecializedPlugin<X, Y, Z>`, so we cannot use `static_cast` or `dynamic_cast` to \"cast\" between them (at this point, it should be clear why I've been putting quotes around my use of the word \"cast\").\n\nWhen we \"cast\" between different specializations of a plugin, we're really passing around the underlying plugin instance (which comes in the form of a `std::shared_ptr<void>` and is a member variable of `Plugin`)  between different `SpecializedPlugin<...>` instances, which may be of completely different types. The `PluginPtr` class facilitates this by redirecting its copy constructor and assignment operator to call `Plugin::PrivateCopyPluginInstance(~)` on the instance that the `PluginPtr` is holding. In other words, `PluginPtr` is just a little wrapper around the `Plugin` instances, and the actual `Plugin` instances never get moved between `PluginPtr`s, only the underlying `std::shared_ptr<void>` member variable that represents the *actual* plugin instance will ever get moved around (it should be carefully noted that \"`Plugin`\" refers to the class `ignition::common::Plugin` while \"plugin\" refers to a `std::shared_ptr<void>` which gets dynamically loaded from some other library).\n\nThis should raise the question of why we even have a `PluginPtr` object if the `Plugin` class is essentially acting as a smart pointer already. The answer to that boils down to semantics. I wanted to be able to make a distinction between a `const PluginPtr` and a `ConstPluginPtr`:\n\n * `const PluginPtr ptr` should imply that the plugin instance held by `ptr` cannot be swapped with another (or removed) after initialization.\n * `ConstPluginPtr ptr` should imply that `ptr` is referring to a const-qualified plugin instance, and you therefore can only request const-qualified interfaces from it, but you may swap (or remove) the plugin instance that is being held.\n\nThese two concepts are completely orthogonal to each other, so we need a way to express the external `const` and the internal `const` independently of each other. Therefore, we have an internal `Plugin` class which is wrapped by an external `PluginPtr` class, so we can apply `const` to each of them independently.\n\nThis also gives us dereference semantics, so you can call `ptr->GetInterface<SomeInterface>()` instead of `ptr.GetInterface<SomeInterface>()`. The latter would imply that the function is operating exclusively on this instance of the `PluginPtr`, but in reality it affects the underlying plugin instance, which may be shared by many `PluginPtr` instances. That kind of behavior is better to express with the dereference operators (`*` and `->`).", "markup": "markdown", "html": "<p>The reason is admittedly kind of unintuitive, but it relates to \"casting\" between Plugin specializations.</p>\n<p>We use the <code>Plugin</code> class as a completely generic object that provides access to the interfaces of a plugin instance that has been loaded by the <code>PluginLoader</code>. The generic <code>Plugin</code> class also serves as a base class for the many various <code>SpecializedPlugin&lt;...&gt;</code> classes that might get instantiated. We want to be able to \"cast\" a plugin from the generic <code>Plugin</code> type to the specialized (more-derived) <code>SpecializedPlugin&lt;...&gt;</code> types. <code>std::shared_ptr</code> offers the usual <code>static_cast</code> and <code>dynamic_cast</code>, but neither of those will work for us, because generally an instance of a <code>Plugin</code> is not secretly an instance of a <code>SpecializedPlugin&lt;...&gt;</code>. Moreover, an instance of a <code>SpecializedPlugin&lt;A, B, C&gt;</code> will not secretly be an instance of a <code>SpecializedPlugin&lt;X, Y, Z&gt;</code>, so we cannot use <code>static_cast</code> or <code>dynamic_cast</code> to \"cast\" between them (at this point, it should be clear why I've been putting quotes around my use of the word \"cast\").</p>\n<p>When we \"cast\" between different specializations of a plugin, we're really passing around the underlying plugin instance (which comes in the form of a <code>std::shared_ptr&lt;void&gt;</code> and is a member variable of <code>Plugin</code>)  between different <code>SpecializedPlugin&lt;...&gt;</code> instances, which may be of completely different types. The <code>PluginPtr</code> class facilitates this by redirecting its copy constructor and assignment operator to call <code>Plugin::PrivateCopyPluginInstance(~)</code> on the instance that the <code>PluginPtr</code> is holding. In other words, <code>PluginPtr</code> is just a little wrapper around the <code>Plugin</code> instances, and the actual <code>Plugin</code> instances never get moved between <code>PluginPtr</code>s, only the underlying <code>std::shared_ptr&lt;void&gt;</code> member variable that represents the <em>actual</em> plugin instance will ever get moved around (it should be carefully noted that \"<code>Plugin</code>\" refers to the class <code>ignition::common::Plugin</code> while \"plugin\" refers to a <code>std::shared_ptr&lt;void&gt;</code> which gets dynamically loaded from some other library).</p>\n<p>This should raise the question of why we even have a <code>PluginPtr</code> object if the <code>Plugin</code> class is essentially acting as a smart pointer already. The answer to that boils down to semantics. I wanted to be able to make a distinction between a <code>const PluginPtr</code> and a <code>ConstPluginPtr</code>:</p>\n<ul>\n<li><code>const PluginPtr ptr</code> should imply that the plugin instance held by <code>ptr</code> cannot be swapped with another (or removed) after initialization.</li>\n<li><code>ConstPluginPtr ptr</code> should imply that <code>ptr</code> is referring to a const-qualified plugin instance, and you therefore can only request const-qualified interfaces from it, but you may swap (or remove) the plugin instance that is being held.</li>\n</ul>\n<p>These two concepts are completely orthogonal to each other, so we need a way to express the external <code>const</code> and the internal <code>const</code> independently of each other. Therefore, we have an internal <code>Plugin</code> class which is wrapped by an external <code>PluginPtr</code> class, so we can apply <code>const</code> to each of them independently.</p>\n<p>This also gives us dereference semantics, so you can call <code>ptr-&gt;GetInterface&lt;SomeInterface&gt;()</code> instead of <code>ptr.GetInterface&lt;SomeInterface&gt;()</code>. The latter would imply that the function is operating exclusively on this instance of the <code>PluginPtr</code>, but in reality it affects the underlying plugin instance, which may be shared by many <code>PluginPtr</code> instances. That kind of behavior is better to express with the dereference operators (<code>*</code> and <code>-&gt;</code>).</p>", "type": "rendered"}, "created_on": "2017-09-05T17:48:16.840960+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {"to": null, "from": null, "outdated": true, "path": "include/ignition/common/PluginPtr.hh"}, "updated_on": "2017-09-05T19:50:21.627866+00:00", "type": "pullrequest_comment", "id": 44280106}