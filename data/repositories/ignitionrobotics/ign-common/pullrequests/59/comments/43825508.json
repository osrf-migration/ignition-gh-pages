{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-common/pullrequests/59/comments/43825508.json"}, "html": {"href": "#!/ignitionrobotics/ign-common/pull-requests/59/_/diff#comment-43825508"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 59, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-common/pullrequests/59.json"}, "html": {"href": "#!/ignitionrobotics/ign-common/pull-requests/59"}}, "title": "Expanding the functionality of the plugin framework, and introducing PluginPtr and specializations"}, "content": {"raw": "After creating a more rigorous performance test, I discovered that the compiler was not inlining some of the implementation as aggressively as I thought it was. The behavior was not noticeable for relatively simple specializations when compiled in release mode, but it became very noticeable for relatively large specializations (where 10-20 interfaces are specialized for) in debug mode. The implementation was scaling so badly that a plugin with 20 specializations could potentially perform worse than a generic plugin, depending on where in the list of specializations the interface is located (... the fact that performance would even depend on the interface's location in the specialization list is very bad and indicates that the compiler was not being as smart as I hoped it would be).\n\nI created a fix for this in 86dd7aa which **guarantees** that the appropriate specialized function call is identified at compile-time, and so performance for a specialized plugin will be the same *no matter* how many interfaces are specialized for or where those interfaces are located in the list of specializations. The exhaustive performance test introduced in 86dd7aa corroborates this.", "markup": "markdown", "html": "<p>After creating a more rigorous performance test, I discovered that the compiler was not inlining some of the implementation as aggressively as I thought it was. The behavior was not noticeable for relatively simple specializations when compiled in release mode, but it became very noticeable for relatively large specializations (where 10-20 interfaces are specialized for) in debug mode. The implementation was scaling so badly that a plugin with 20 specializations could potentially perform worse than a generic plugin, depending on where in the list of specializations the interface is located (... the fact that performance would even depend on the interface's location in the specialization list is very bad and indicates that the compiler was not being as smart as I hoped it would be).</p>\n<p>I created a fix for this in <a href=\"#!/ignitionrobotics/ign-common/commits/86dd7aa\" rel=\"nofollow\" class=\"ap-connect-link\">86dd7aa</a> which <strong>guarantees</strong> that the appropriate specialized function call is identified at compile-time, and so performance for a specialized plugin will be the same <em>no matter</em> how many interfaces are specialized for or where those interfaces are located in the list of specializations. The exhaustive performance test introduced in <a href=\"#!/ignitionrobotics/ign-common/commits/86dd7aa\" rel=\"nofollow\" class=\"ap-connect-link\">86dd7aa</a> corroborates this.</p>", "type": "rendered"}, "created_on": "2017-08-29T18:54:17.419571+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-08-29T18:56:16.831815+00:00", "type": "pullrequest_comment", "id": 43825508}