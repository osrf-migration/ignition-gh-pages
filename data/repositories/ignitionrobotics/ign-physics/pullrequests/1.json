{"rendered": {"description": {"raw": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "markup": "markdown", "html": "<h3 id=\"markdown-header-edit-this-has-been-broken-down-into-pull-request-3-cmake-pull-request-4-compositedata-pull-request-5-specifydata-and-this-one-template-metaprogramming-the-other-prs-should-be-reviewed-in-order-before-this-one-but-the-overview-given-in-the-description-below-might-still-be-a-useful-primer\">Edit: This has been broken down into <a href=\"#!/ignitionrobotics/ign-physics/pull-requests/3/changes-to-the-cmake-setup\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #3</a> (CMake), <a href=\"#!/ignitionrobotics/ign-physics/pull-requests/4/part-1-compositedata-implementation-and\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #4</a> (CompositeData), <a href=\"#!/ignitionrobotics/ign-physics/pull-requests/5/part-2-compositedata-specifydata\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #5</a> (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.</h3>\n<p>This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in <code>ignition-common</code>, because it's not really specific to physics.</p>\n<h2 id=\"markdown-header-compositedata\">CompositeData</h2>\n<ul>\n<li>CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:<ol>\n<li>It follows the <a data-is-external-link=\"true\" href=\"http://en.cppreference.com/w/cpp/language/rule_of_three\" rel=\"nofollow\">Rule of Zero, Rule of Three, or Rule of Five</a> (preferably zero or five)</li>\n<li>It contains the macro <code>IGN_PHYSICS_DATA_LABEL(some::unique::name)</code></li>\n</ol>\n</li>\n<li>Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.</li>\n<li>CompositeData has a pretty <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&amp;fileviewer=file-view-default#CompositeData.hh-56\" rel=\"nofollow\">thorough API</a><ul>\n<li><code>Get&lt;T&gt;()</code> returns a reference to <code>T</code>, which means if the data type did not exist in the <code>CompositeData</code>, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using <code>Query&lt;T&gt;()</code> (described below). The basic <code>CompositeData</code> class does not have a const-qualified version of <code>Get&lt;T&gt;()</code>, but the <code>RequireData&lt;T&gt;</code> extension (described below) does provide const-qualified <code>Get&lt;T&gt;()</code> using a bunch of template metaprogramming wizardry.</li>\n<li><code>Create&lt;T&gt;(args)</code> will create a <code>T</code> using <code>args</code>. If a <code>T</code> already existed, it will be overwritten.</li>\n<li><code>GetOrCreate&lt;T&gt;(args)</code> will do the same as <code>Get&lt;T&gt;()</code> unless the object didn't exist, in which case it will do the same as <code>Create&lt;T&gt;(args)</code>. <strong>We can absolutely get rid of this and change <code>Get&lt;T&gt;()</code> to accept <code>args</code> and exhibit this exact same behavior</strong>. The reason I chose to write a <code>GetOrCreate&lt;T&gt;()</code> separate from <code>Get&lt;T&gt;()</code> is because:<ul>\n<li>I suspect <code>Get&lt;T&gt;()</code>, in the way I designed it, is going to be the most desired use case of handling data within the <code>CompositeData</code> object.</li>\n<li>I'm worried that <code>Get&lt;T&gt;(args)</code> will make people think that they're looking up a <code>T</code> that matches <code>args</code> (rather than creating a <code>T</code> using <code>args</code> if the <code>T</code> was unavailable). For example, I don't want people to think <code>data.Get&lt;JointProperty&gt;(2)</code> is going to get the <code>JointProperty</code> of joint index <code>2</code> when really it would be constructing a <code>JointProperty</code> with the argument of <code>2</code>.</li>\n</ul>\n</li>\n<li><code>Remove&lt;T&gt;()</code> will remove the <code>T</code> object if it exists and it is not marked as required (explained below).</li>\n<li><code>Query&lt;T&gt;()</code> will return a pointer to <code>T</code> which will be <code>nullptr</code> if <code>T</code> is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version <code>Query&lt;T&gt;() const</code> is always available, regardless of requirements.</li>\n<li><code>Has&lt;T&gt;()</code> tests for existence. This can also be called silently.</li>\n<li><code>StatusOf&lt;T&gt;()</code> provides a struct that describes the metadata of <code>T</code>. This also has a silent mode.</li>\n<li><code>Unquery&lt;T&gt;()</code> only affects some metadata and has no impact on the actual data.</li>\n<li><code>MakeRequired&lt;T&gt;()</code> will mark <code>T</code> as required so that it can not be deleted until the end of the <code>CompositeData</code> object's lifespan. Explained more later.</li>\n<li><code>Copy(~)</code> can copy data between <code>CompositeData</code> objects, and there are some options to change the behavior of <code>Copy(~)</code> based on metadata. Note that <code>Copy(~)</code> is not allowed to delete data that is marked as required.</li>\n</ul>\n</li>\n<li>Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a <code>Copy</code> operation). If you have done all the work you intend to do on a <code>CompositeData</code> object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.</li>\n<li>Requirements are also tracked by the <code>CompositeData</code>. Data types can be marked as required by <code>MakeRequired&lt;T&gt;()</code>. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class <code>RequireData</code> (described below) can statically express and enforce requirements.</li>\n</ul>\n<h2 id=\"markdown-header-expectdatadata1-datan\">ExpectData&lt;Data1, ... , DataN&gt;</h2>\n<ul>\n<li><code>ExpectData</code> is an extension of <code>CompositeData</code> which has all the same functionality, but it provides extremely low-cost versions of the <code>CompositeData</code> API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.</li>\n<li>I created a <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&amp;fileviewer=file-view-default\" rel=\"nofollow\">performance test</a> which demonstrates that the <code>ExpectData</code> class improves access speed by roughly 2 <strong>orders of magnitude</strong> over the map lookup (~1ns per access rather than ~100ns per access).</li>\n<li>Types that get listed by <code>ExpectData</code> are still optional; this class has no impact on requirements.</li>\n<li>It's a variadic template, so any number of Data types can be given to it.</li>\n</ul>\n<h2 id=\"markdown-header-requiredatadata1-datan\">RequireData&lt;Data1, ..., DataN&gt;</h2>\n<ul>\n<li><code>RequireData</code> is an extension of <code>ExpectData</code> which additionally marks its Data types as required, both at compile time and at run time.</li>\n<li>As mentioned earlier, data types marked as required must exist and cannot be deleted until the <code>CompositeData</code> leaves scope.</li>\n<li>Because <code>RequireData&lt;T&gt;</code> enforces the existence of a <code>T</code> type at compile time, it also provides a const-qualified <code>Get&lt;T&gt;() const</code>.</li>\n</ul>\n<h2 id=\"markdown-header-specifydataspec1-specn\">SpecifyData&lt;Spec1, ... , SpecN&gt;</h2>\n<ul>\n<li><code>SpecifyData</code> is an extension of <code>CompositeData</code> which allows data specifications (e.g. <code>ExpectData</code> and <code>RequireData</code> or other <code>SpecifyData</code> mixtures) to be mixed and merged at compile time. Note that <code>RequireData</code> always takes precedence over <code>ExpectData</code>, so any <code>Data</code> that is listed as both <code>Expected</code> and <code>Required</code> will ultimately be <code>Required</code>.</li>\n<li>This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.</li>\n</ul>\n<h2 id=\"markdown-header-template-metaprogramming-and-static-analysis\">Template metaprogramming and static analysis</h2>\n<ul>\n<li>Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.</li>\n<li>Examples of this can be found in <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&amp;fileviewer=file-view-default\" rel=\"nofollow\">CanReadData</a> and <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&amp;fileviewer=file-view-default\" rel=\"nofollow\">CanWriteData</a>. These classes use CRTP to guarantee that the class which inherits them provides a <code>Read(T)</code> or <code>Write(T)</code> function for each of the expected or required (depending on which you select) data types in the specification that they are given.</li>\n<li>These classes are powered by <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&amp;fileviewer=file-view-default\" rel=\"nofollow\">OperateOnSpecifiedData</a> which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).</li>\n<li>If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.</li>\n</ul>\n<p>Altogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.</p>", "type": "rendered"}, "title": {"raw": "Part 3: CompositeData prototype summary", "markup": "markdown", "html": "<p>Part 3: CompositeData prototype summary</p>", "type": "rendered"}}, "type": "pullrequest", "description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-physics/pullrequests/1/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-physics/diffstat/ignitionrobotics/ign-physics:3bf87fe246a9%0Db2c4fb7e7730?from_pullrequest_id=1"}, "commits": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/commits.json"}, "self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "comments": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-physics/pullrequests/1/merge"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}, "activity": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-physics/diff/ignitionrobotics/ign-physics:3bf87fe246a9%0Db2c4fb7e7730?from_pullrequest_id=1"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-physics/pullrequests/1/approve"}, "statuses": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/statuses_page=1.json"}}, "title": "Part 3: CompositeData prototype summary", "close_source_branch": true, "reviewers": [{"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}], "id": 1, "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "created_on": "2017-08-24T23:23:08.427976+00:00", "summary": {"raw": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "markup": "markdown", "html": "<h3 id=\"markdown-header-edit-this-has-been-broken-down-into-pull-request-3-cmake-pull-request-4-compositedata-pull-request-5-specifydata-and-this-one-template-metaprogramming-the-other-prs-should-be-reviewed-in-order-before-this-one-but-the-overview-given-in-the-description-below-might-still-be-a-useful-primer\">Edit: This has been broken down into <a href=\"#!/ignitionrobotics/ign-physics/pull-requests/3/changes-to-the-cmake-setup\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #3</a> (CMake), <a href=\"#!/ignitionrobotics/ign-physics/pull-requests/4/part-1-compositedata-implementation-and\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #4</a> (CompositeData), <a href=\"#!/ignitionrobotics/ign-physics/pull-requests/5/part-2-compositedata-specifydata\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #5</a> (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.</h3>\n<p>This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in <code>ignition-common</code>, because it's not really specific to physics.</p>\n<h2 id=\"markdown-header-compositedata\">CompositeData</h2>\n<ul>\n<li>CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:<ol>\n<li>It follows the <a data-is-external-link=\"true\" href=\"http://en.cppreference.com/w/cpp/language/rule_of_three\" rel=\"nofollow\">Rule of Zero, Rule of Three, or Rule of Five</a> (preferably zero or five)</li>\n<li>It contains the macro <code>IGN_PHYSICS_DATA_LABEL(some::unique::name)</code></li>\n</ol>\n</li>\n<li>Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.</li>\n<li>CompositeData has a pretty <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&amp;fileviewer=file-view-default#CompositeData.hh-56\" rel=\"nofollow\">thorough API</a><ul>\n<li><code>Get&lt;T&gt;()</code> returns a reference to <code>T</code>, which means if the data type did not exist in the <code>CompositeData</code>, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using <code>Query&lt;T&gt;()</code> (described below). The basic <code>CompositeData</code> class does not have a const-qualified version of <code>Get&lt;T&gt;()</code>, but the <code>RequireData&lt;T&gt;</code> extension (described below) does provide const-qualified <code>Get&lt;T&gt;()</code> using a bunch of template metaprogramming wizardry.</li>\n<li><code>Create&lt;T&gt;(args)</code> will create a <code>T</code> using <code>args</code>. If a <code>T</code> already existed, it will be overwritten.</li>\n<li><code>GetOrCreate&lt;T&gt;(args)</code> will do the same as <code>Get&lt;T&gt;()</code> unless the object didn't exist, in which case it will do the same as <code>Create&lt;T&gt;(args)</code>. <strong>We can absolutely get rid of this and change <code>Get&lt;T&gt;()</code> to accept <code>args</code> and exhibit this exact same behavior</strong>. The reason I chose to write a <code>GetOrCreate&lt;T&gt;()</code> separate from <code>Get&lt;T&gt;()</code> is because:<ul>\n<li>I suspect <code>Get&lt;T&gt;()</code>, in the way I designed it, is going to be the most desired use case of handling data within the <code>CompositeData</code> object.</li>\n<li>I'm worried that <code>Get&lt;T&gt;(args)</code> will make people think that they're looking up a <code>T</code> that matches <code>args</code> (rather than creating a <code>T</code> using <code>args</code> if the <code>T</code> was unavailable). For example, I don't want people to think <code>data.Get&lt;JointProperty&gt;(2)</code> is going to get the <code>JointProperty</code> of joint index <code>2</code> when really it would be constructing a <code>JointProperty</code> with the argument of <code>2</code>.</li>\n</ul>\n</li>\n<li><code>Remove&lt;T&gt;()</code> will remove the <code>T</code> object if it exists and it is not marked as required (explained below).</li>\n<li><code>Query&lt;T&gt;()</code> will return a pointer to <code>T</code> which will be <code>nullptr</code> if <code>T</code> is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version <code>Query&lt;T&gt;() const</code> is always available, regardless of requirements.</li>\n<li><code>Has&lt;T&gt;()</code> tests for existence. This can also be called silently.</li>\n<li><code>StatusOf&lt;T&gt;()</code> provides a struct that describes the metadata of <code>T</code>. This also has a silent mode.</li>\n<li><code>Unquery&lt;T&gt;()</code> only affects some metadata and has no impact on the actual data.</li>\n<li><code>MakeRequired&lt;T&gt;()</code> will mark <code>T</code> as required so that it can not be deleted until the end of the <code>CompositeData</code> object's lifespan. Explained more later.</li>\n<li><code>Copy(~)</code> can copy data between <code>CompositeData</code> objects, and there are some options to change the behavior of <code>Copy(~)</code> based on metadata. Note that <code>Copy(~)</code> is not allowed to delete data that is marked as required.</li>\n</ul>\n</li>\n<li>Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a <code>Copy</code> operation). If you have done all the work you intend to do on a <code>CompositeData</code> object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.</li>\n<li>Requirements are also tracked by the <code>CompositeData</code>. Data types can be marked as required by <code>MakeRequired&lt;T&gt;()</code>. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class <code>RequireData</code> (described below) can statically express and enforce requirements.</li>\n</ul>\n<h2 id=\"markdown-header-expectdatadata1-datan\">ExpectData&lt;Data1, ... , DataN&gt;</h2>\n<ul>\n<li><code>ExpectData</code> is an extension of <code>CompositeData</code> which has all the same functionality, but it provides extremely low-cost versions of the <code>CompositeData</code> API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.</li>\n<li>I created a <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&amp;fileviewer=file-view-default\" rel=\"nofollow\">performance test</a> which demonstrates that the <code>ExpectData</code> class improves access speed by roughly 2 <strong>orders of magnitude</strong> over the map lookup (~1ns per access rather than ~100ns per access).</li>\n<li>Types that get listed by <code>ExpectData</code> are still optional; this class has no impact on requirements.</li>\n<li>It's a variadic template, so any number of Data types can be given to it.</li>\n</ul>\n<h2 id=\"markdown-header-requiredatadata1-datan\">RequireData&lt;Data1, ..., DataN&gt;</h2>\n<ul>\n<li><code>RequireData</code> is an extension of <code>ExpectData</code> which additionally marks its Data types as required, both at compile time and at run time.</li>\n<li>As mentioned earlier, data types marked as required must exist and cannot be deleted until the <code>CompositeData</code> leaves scope.</li>\n<li>Because <code>RequireData&lt;T&gt;</code> enforces the existence of a <code>T</code> type at compile time, it also provides a const-qualified <code>Get&lt;T&gt;() const</code>.</li>\n</ul>\n<h2 id=\"markdown-header-specifydataspec1-specn\">SpecifyData&lt;Spec1, ... , SpecN&gt;</h2>\n<ul>\n<li><code>SpecifyData</code> is an extension of <code>CompositeData</code> which allows data specifications (e.g. <code>ExpectData</code> and <code>RequireData</code> or other <code>SpecifyData</code> mixtures) to be mixed and merged at compile time. Note that <code>RequireData</code> always takes precedence over <code>ExpectData</code>, so any <code>Data</code> that is listed as both <code>Expected</code> and <code>Required</code> will ultimately be <code>Required</code>.</li>\n<li>This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.</li>\n</ul>\n<h2 id=\"markdown-header-template-metaprogramming-and-static-analysis\">Template metaprogramming and static analysis</h2>\n<ul>\n<li>Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.</li>\n<li>Examples of this can be found in <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&amp;fileviewer=file-view-default\" rel=\"nofollow\">CanReadData</a> and <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&amp;fileviewer=file-view-default\" rel=\"nofollow\">CanWriteData</a>. These classes use CRTP to guarantee that the class which inherits them provides a <code>Read(T)</code> or <code>Write(T)</code> function for each of the expected or required (depending on which you select) data types in the specification that they are given.</li>\n<li>These classes are powered by <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&amp;fileviewer=file-view-default\" rel=\"nofollow\">OperateOnSpecifiedData</a> which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).</li>\n<li>If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.</li>\n</ul>\n<p>Altogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.</p>", "type": "rendered"}, "source": {"commit": {"hash": "4297959e0921", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4297959e0921.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4297959e0921"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "comment_count": 78, "state": "MERGED", "task_count": 0, "participants": [{"role": "REVIEWER", "participated_on": null, "type": "participant", "approved": false, "user": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}}, {"role": "REVIEWER", "participated_on": "2018-05-18T16:24:49.971768+00:00", "type": "participant", "approved": true, "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}}, {"role": "PARTICIPANT", "participated_on": "2017-08-30T04:16:56.753182+00:00", "type": "participant", "approved": false, "user": {"display_name": "Ying Lu", "uuid": "{11ec131e-4af6-4228-beaf-167b1c8d1c2c}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B11ec131e-4af6-4228-beaf-167b1c8d1c2c%7D"}, "html": {"href": "https://bitbucket.org/%7B11ec131e-4af6-4228-beaf-167b1c8d1c2c%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:659bfe31-d941-44f5-aa6d-00058b070ea8/c88d5925-8a09-40c7-8684-c02aeafe0f59/128"}}, "nickname": "rosebudflyaway", "type": "user", "account_id": "557058:659bfe31-d941-44f5-aa6d-00058b070ea8"}}, {"role": "REVIEWER", "participated_on": "2018-05-16T23:20:19.609580+00:00", "type": "participant", "approved": true, "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}}, {"role": "PARTICIPANT", "participated_on": "2018-06-05T06:07:42.759789+00:00", "type": "participant", "approved": true, "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}}], "reason": "", "updated_on": "2018-06-06T09:34:36.996739+00:00", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "merge_commit": {"hash": "3bf87fe246a9", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/3bf87fe246a9.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/3bf87fe246a9"}}}, "closed_by": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}}