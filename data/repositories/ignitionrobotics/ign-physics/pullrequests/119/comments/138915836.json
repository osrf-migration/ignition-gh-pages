{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/119/comments/138915836.json"}, "code": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-physics/diff/ignitionrobotics/ign-physics:cc5ab29e1d8d..0feb6cdf616e?path=examples%2Fhello_world%2Fhello_world.cc"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/119/_/diff#comment-138915836"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 119, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/119.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/119"}}, "title": "Add simple example of physics plugin and loader"}, "content": {"raw": "I don't think it's good to encourage users to export the library location using CMake logic. That requires the loader to know the plugin's location at compile time, which is not necessary. In fact, the power of loading engines as plugins at runtime comes from the fact that the loader doesn't need to know about them beforehand.\n\nI'd even suggest compiling the plugin and the loader as two separate CMake projects to show how they can be independent. More concretely:\n\n* Separate `examples/hello_world` into `examples/hello_world_plugin` and `examples/hello_world_loader`.\n* On the loader side, accept the path to the plugin as an input argument, so it can be run as, for example: `./hello_world_loader ../../hello_world_plugin/build/libHelloWorldPlugin.so`\n\nKeeping them separate should also help avoid confusion in the future, when we need to point users to an example of writing a plugin, and it will be clear that they do not need to write a loader as well.\n\nFinally, I encourage us to **always** add READMEs to all our examples, with an explanation of what the example is showing, how to build, run, and what the user should expect to see.", "markup": "markdown", "html": "<p>I don't think it's good to encourage users to export the library location using CMake logic. That requires the loader to know the plugin's location at compile time, which is not necessary. In fact, the power of loading engines as plugins at runtime comes from the fact that the loader doesn't need to know about them beforehand.</p>\n<p>I'd even suggest compiling the plugin and the loader as two separate CMake projects to show how they can be independent. More concretely:</p>\n<ul>\n<li>Separate <code>examples/hello_world</code> into <code>examples/hello_world_plugin</code> and <code>examples/hello_world_loader</code>.</li>\n<li>On the loader side, accept the path to the plugin as an input argument, so it can be run as, for example: <code>./hello_world_loader ../../hello_world_plugin/build/libHelloWorldPlugin.so</code></li>\n</ul>\n<p>Keeping them separate should also help avoid confusion in the future, when we need to point users to an example of writing a plugin, and it will be clear that they do not need to write a loader as well.</p>\n<p>Finally, I encourage us to <strong>always</strong> add READMEs to all our examples, with an explanation of what the example is showing, how to build, run, and what the user should expect to see.</p>", "type": "rendered"}, "created_on": "2020-03-05T21:33:17.793258+00:00", "user": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}, "inline": {"to": 34, "from": null, "outdated": true, "path": "examples/hello_world/hello_world.cc"}, "updated_on": "2020-03-05T21:33:17.798968+00:00", "type": "pullrequest_comment", "id": 138915836}