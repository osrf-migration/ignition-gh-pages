{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/24/comments/69278320.json"}, "code": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-physics/diff/ignitionrobotics/ign-physics:994134779054..3bf87fe246a9?path=test%2FMockGetByName.hh"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/24/_/diff#comment-69278320"}}, "parent": {"id": 69269521, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/24/comments/69269521.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/24/_/diff#comment-69269521"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 24, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/24.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/24"}}, "title": "Feature System Part 1"}, "content": {"raw": "The object that we\u2019re returning is a proxy for *something* that exists in the physics engine. The physics engine doesn\u2019t have any knowledge or ownership over the life-cycle of this proxy object that we\u2019re returning; only the user is able to see it.\n\nTo take this particular line as an example, the physics engine might not have any concept of a \u201cWorld\u201d object, and even if it did, we can\u2019t give the user a pointer to the physics engine\u2019s native \u201cWorld\u201d object, because the API\\+ABI of \u201cWorld\u201d objects will differ between physics engines. At compile time, we have no way of knowing what physics engine will be used.\n\nSo the object we're handing to the user is a proxy \"Entity\" that refers to the physics engine's \"World\" using a unique integer value. The life-cycle of this proxy \"Entity\" needs to be managed, but only the user knows about the existence of this proxy object. Therefore, the user needs to be responsible for its life-cycle, but we take care of that by wrapping it in a `std::unique_ptr`.\n\nIf we were able to **know** that a valid \"World\" can be returned for every possible input that the user provides, then we could return a regular `World` proxy object instead of a `std::unique_ptr<World>` object. Alternatively, we could always return a `World` object, and throw an exception when the user gives bad input \\(instead of returning a `nullptr`\\), but the fact that a function might throw an exception can\u2019t be expressed through its function signature, so I don\u2019t favor that option \\(plus there are some potential performance concerns\\).\n\n`std::optional<World>` is really be the best fit here \\(at least in my opinion\\), because it will give us the best of:\n\n1. Explicitly expressing intent \\+ behavior\n2. Good performance\n3. Meaningful life-cycle management\n\nI just don\u2019t have C\\+\\+17 right now, and I can\u2019t risk upgrading to Bionic until July 16, because I have a live demo scheduled for the 13th.", "markup": "markdown", "html": "<p>The object that we\u2019re returning is a proxy for <em>something</em> that exists in the physics engine. The physics engine doesn\u2019t have any knowledge or ownership over the life-cycle of this proxy object that we\u2019re returning; only the user is able to see it.</p>\n<p>To take this particular line as an example, the physics engine might not have any concept of a \u201cWorld\u201d object, and even if it did, we can\u2019t give the user a pointer to the physics engine\u2019s native \u201cWorld\u201d object, because the API+ABI of \u201cWorld\u201d objects will differ between physics engines. At compile time, we have no way of knowing what physics engine will be used.</p>\n<p>So the object we're handing to the user is a proxy \"Entity\" that refers to the physics engine's \"World\" using a unique integer value. The life-cycle of this proxy \"Entity\" needs to be managed, but only the user knows about the existence of this proxy object. Therefore, the user needs to be responsible for its life-cycle, but we take care of that by wrapping it in a <code>std::unique_ptr</code>.</p>\n<p>If we were able to <strong>know</strong> that a valid \"World\" can be returned for every possible input that the user provides, then we could return a regular <code>World</code> proxy object instead of a <code>std::unique_ptr&lt;World&gt;</code> object. Alternatively, we could always return a <code>World</code> object, and throw an exception when the user gives bad input (instead of returning a <code>nullptr</code>), but the fact that a function might throw an exception can\u2019t be expressed through its function signature, so I don\u2019t favor that option (plus there are some potential performance concerns).</p>\n<p><code>std::optional&lt;World&gt;</code> is really be the best fit here (at least in my opinion), because it will give us the best of:</p>\n<ol>\n<li>Explicitly expressing intent + behavior</li>\n<li>Good performance</li>\n<li>Meaningful life-cycle management</li>\n</ol>\n<p>I just don\u2019t have C++17 right now, and I can\u2019t risk upgrading to Bionic until July 16, because I have a live demo scheduled for the 13th.</p>", "type": "rendered"}, "created_on": "2018-07-07T02:20:51.274200+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {"to": null, "from": null, "outdated": true, "path": "test/MockGetByName.hh"}, "updated_on": "2018-07-07T02:21:29.439037+00:00", "type": "pullrequest_comment", "id": 69278320}