{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/29/comments/71999392.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/29/_/diff#comment-71999392"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 29, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/29.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/29"}}, "title": "Feature System Part 6: Features for constructing objects from SDF data"}, "content": {"raw": "I'm thinking about the case when you provide an sdf world file and want to find a physics plugin that supports all the features expressed in that file. If you detect `revolute` and `ball` joints, for example, you append those to a feature list when requesting a plugin.\n\nTo support this, what do you think about making dummy features that aren't used in the actual model construction but signal which joint types can be constructed? A plugin could provide `ConstructWorld` and `ConstructModel` and then `CanConstructBallJoint`, `CanConstructRevoluteJoint`, etc. Those `CanConstruct*` features could be mostly empty; it's just their existence that signals the relevant information when requesting a compatible plugin.\n\nA similar approach could also be taken for shape types I think.", "markup": "markdown", "html": "<p>I'm thinking about the case when you provide an sdf world file and want to find a physics plugin that supports all the features expressed in that file. If you detect <code>revolute</code> and <code>ball</code> joints, for example, you append those to a feature list when requesting a plugin.</p>\n<p>To support this, what do you think about making dummy features that aren't used in the actual model construction but signal which joint types can be constructed? A plugin could provide <code>ConstructWorld</code> and <code>ConstructModel</code> and then <code>CanConstructBallJoint</code>, <code>CanConstructRevoluteJoint</code>, etc. Those <code>CanConstruct*</code> features could be mostly empty; it's just their existence that signals the relevant information when requesting a compatible plugin.</p>\n<p>A similar approach could also be taken for shape types I think.</p>", "type": "rendered"}, "created_on": "2018-08-04T00:51:31.602890+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2018-08-04T00:51:31.609109+00:00", "type": "pullrequest_comment", "id": 71999392}