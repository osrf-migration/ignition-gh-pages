{"pagelen": 50, "values": [{"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "03f057d3ba9e", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/03f057d3ba9e.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/03f057d3ba9e"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "967ab1414368", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/967ab1414368.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/967ab1414368"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "MERGED", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-07T23:49:38.375057+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"approval": {"date": "2018-09-07T23:49:30.230005+00:00", "pullrequest": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}, "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "03f057d3ba9e", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/03f057d3ba9e.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/03f057d3ba9e"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "967ab1414368", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/967ab1414368.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/967ab1414368"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-06T20:02:25.297407+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "03f057d3ba9e", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/03f057d3ba9e.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/03f057d3ba9e"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "de8817ec39b9", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/de8817ec39b9.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/de8817ec39b9"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-06T20:01:57.527465+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "03f057d3ba9e", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/03f057d3ba9e.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/03f057d3ba9e"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "de8817ec39b9", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/de8817ec39b9.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/de8817ec39b9"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-06T20:01:57.464188+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"approval": {"date": "2018-09-04T15:28:38.990448+00:00", "pullrequest": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}, "user": {"display_name": "Addisu Z. Taddese", "uuid": "{9d7fdc68-d270-4080-bf03-4df0d0dbf635}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B9d7fdc68-d270-4080-bf03-4df0d0dbf635%7D"}, "html": {"href": "https://bitbucket.org/%7B9d7fdc68-d270-4080-bf03-4df0d0dbf635%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:90bc87b0-2886-4377-a17c-3a6629a697ff/afbf9be5-1e4c-4810-89d4-e58831f34b11/128"}}, "nickname": "azeey", "type": "user", "account_id": "557058:90bc87b0-2886-4377-a17c-3a6629a697ff"}}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "490b2eff37c3", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/490b2eff37c3.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/490b2eff37c3"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "de8817ec39b9", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/de8817ec39b9.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/de8817ec39b9"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-04T08:46:00.446605+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31/comments/74739701.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31/_/diff#comment-74739701"}}, "parent": {"id": 74711226, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31/comments/74711226.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31/_/diff#comment-74711226"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}, "content": {"raw": "Strictly speaking it doesn't matter because the `Feature` class itself has no member variables \\(and this is a feature class, so it will never be inherited itself\\), but to be consistent with how we've been using `virtual` inheritance _everywhere_ in `ign-physics`, we may as well make this `virtual` too: 8908677", "markup": "markdown", "html": "<p>Strictly speaking it doesn't matter because the <code>Feature</code> class itself has no member variables (and this is a feature class, so it will never be inherited itself), but to be consistent with how we've been using <code>virtual</code> inheritance <em>everywhere</em> in <code>ign-physics</code>, we may as well make this <code>virtual</code> too: <a href=\"#!/ignitionrobotics/ign-physics/commits/8908677\" rel=\"nofollow\" class=\"ap-connect-link\">8908677</a></p>", "type": "rendered"}, "created_on": "2018-09-03T02:14:08.016652+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-09-03T02:14:08.025497+00:00", "type": "pullrequest_comment", "id": 74739701}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "490b2eff37c3", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/490b2eff37c3.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/490b2eff37c3"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "890867706f4a", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/890867706f4a.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/890867706f4a"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-03T02:13:40.849373+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31/comments/74711226.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31/_/diff#comment-74711226"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}, "content": {"raw": "Should this use virtual inheritance as well?", "markup": "markdown", "html": "<p>Should this use virtual inheritance as well?</p>", "type": "rendered"}, "created_on": "2018-08-31T20:48:51.389855+00:00", "user": {"display_name": "Addisu Z. Taddese", "uuid": "{9d7fdc68-d270-4080-bf03-4df0d0dbf635}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B9d7fdc68-d270-4080-bf03-4df0d0dbf635%7D"}, "html": {"href": "https://bitbucket.org/%7B9d7fdc68-d270-4080-bf03-4df0d0dbf635%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:90bc87b0-2886-4377-a17c-3a6629a697ff/afbf9be5-1e4c-4810-89d4-e58831f34b11/128"}}, "nickname": "azeey", "type": "user", "account_id": "557058:90bc87b0-2886-4377-a17c-3a6629a697ff"}, "inline": {}, "updated_on": "2018-08-31T20:48:51.397898+00:00", "type": "pullrequest_comment", "id": 74711226}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31/comments/74636856.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31/_/diff#comment-74636856"}}, "parent": {"id": 74602385, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31/comments/74602385.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31/_/diff#comment-74602385"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}, "content": {"raw": "Those warnings should be fixed by  b880b52", "markup": "markdown", "html": "<p>Those warnings should be fixed by  <a href=\"#!/ignitionrobotics/ign-physics/commits/b880b52\" rel=\"nofollow\" class=\"ap-connect-link\">b880b52</a></p>", "type": "rendered"}, "created_on": "2018-08-31T09:11:04.045712+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-08-31T09:11:04.056721+00:00", "type": "pullrequest_comment", "id": 74636856}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "490b2eff37c3", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/490b2eff37c3.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/490b2eff37c3"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4a6134d9b68a", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4a6134d9b68a.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4a6134d9b68a"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-08-31T09:10:26.586658+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "490b2eff37c3", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/490b2eff37c3.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/490b2eff37c3"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "ad4119816792", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/ad4119816792.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/ad4119816792"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-08-31T00:11:58.891180+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "490b2eff37c3", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/490b2eff37c3.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/490b2eff37c3"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "ad4119816792", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/ad4119816792.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/ad4119816792"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-08-31T00:11:58.763011+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31/comments/74602385.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31/_/diff#comment-74602385"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}, "content": {"raw": "after updating gtest in pull request #34, this build is now unstable, with just some compiler warnings\n\n* [![Build Status](https://build.osrfoundation.org/buildStatus/icon?job=ign_physics-pr-win&build=68)](https://build.osrfoundation.org/job/ign_physics-pr-win/68/) https://build.osrfoundation.org/job/ign_physics-pr-win/68/warnings43Result/", "markup": "markdown", "html": "<p>after updating gtest in <a href=\"#!/ignitionrobotics/ign-physics/pull-requests/34/feature-system-part-45-use-gz11-deps-and\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #34</a>, this build is now unstable, with just some compiler warnings</p>\n<ul>\n<li><a data-is-external-link=\"true\" href=\"https://build.osrfoundation.org/job/ign_physics-pr-win/68/\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://build.osrfoundation.org/buildStatus/icon?job=ign_physics-pr-win&amp;build=68\" /></a> <a href=\"https://build.osrfoundation.org/job/ign_physics-pr-win/68/warnings43Result/\" rel=\"nofollow\" class=\"ap-connect-link\">https://build.osrfoundation.org/job/ign_physics-pr-win/68/warnings43Result/</a></li>\n</ul>", "type": "rendered"}, "created_on": "2018-08-31T00:06:31.477416+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2018-08-31T00:07:43.929990+00:00", "type": "pullrequest_comment", "id": 74602385}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31/comments/74602400.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31/_/diff#comment-74602400"}}, "parent": {"id": 73401103, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31/comments/73401103.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31/_/diff#comment-73401103"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}, "content": {"raw": "I moved that to pull request #34, since it also needs an update to gtest, which made this PR too big", "markup": "markdown", "html": "<p>I moved that to <a href=\"#!/ignitionrobotics/ign-physics/pull-requests/34/feature-system-part-45-use-gz11-deps-and\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #34</a>, since it also needs an update to gtest, which made this PR too big</p>", "type": "rendered"}, "created_on": "2018-08-31T00:06:54.799580+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2018-08-31T00:06:54.807281+00:00", "type": "pullrequest_comment", "id": 74602400}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "490b2eff37c3", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/490b2eff37c3.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/490b2eff37c3"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "cfa75bca3e31", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/cfa75bca3e31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/cfa75bca3e31"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-08-30T23:30:20.264670+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "490b2eff37c3", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/490b2eff37c3.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/490b2eff37c3"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "a04cfb824091", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/a04cfb824091.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/a04cfb824091"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-08-30T23:30:00.173412+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "490b2eff37c3", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/490b2eff37c3.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/490b2eff37c3"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "a04cfb824091", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/a04cfb824091.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/a04cfb824091"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-08-30T23:30:00.134724+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "3ce7dd6c1999", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/3ce7dd6c1999.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/3ce7dd6c1999"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "a04cfb824091", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/a04cfb824091.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/a04cfb824091"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-08-30T06:40:10.494853+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31/comments/74433487.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31/_/diff#comment-74433487"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}, "content": {"raw": "homebrew mojave build [![Build Status](https://build.osrfoundation.org/buildStatus/icon?job=ignition_physics-ci-pr_any-homebrew-amd64-mojave&build=1)](https://build.osrfoundation.org/job/ignition_physics-ci-pr_any-homebrew-amd64-mojave/1/) https://build.osrfoundation.org/job/ignition_physics-ci-pr_any-homebrew-amd64-mojave/1/", "markup": "markdown", "html": "<p>homebrew mojave build <a data-is-external-link=\"true\" href=\"https://build.osrfoundation.org/job/ignition_physics-ci-pr_any-homebrew-amd64-mojave/1/\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://build.osrfoundation.org/buildStatus/icon?job=ignition_physics-ci-pr_any-homebrew-amd64-mojave&amp;build=1\" /></a> <a href=\"https://build.osrfoundation.org/job/ignition_physics-ci-pr_any-homebrew-amd64-mojave/1/\" rel=\"nofollow\" class=\"ap-connect-link\">https://build.osrfoundation.org/job/ignition_physics-ci-pr_any-homebrew-amd64-mojave/1/</a></p>", "type": "rendered"}, "created_on": "2018-08-29T18:22:47.699672+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2018-08-29T18:22:47.707489+00:00", "type": "pullrequest_comment", "id": 74433487}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "bc373d54b5be", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/bc373d54b5be.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/bc373d54b5be"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "cfcd993b3e93", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/cfcd993b3e93.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/cfcd993b3e93"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-08-27T10:00:20.555478+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "2424f2854c63", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/2424f2854c63.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/2424f2854c63"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "afdc90a32f19", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/afdc90a32f19.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/afdc90a32f19"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-08-27T06:40:56.872983+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "2424f2854c63", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/2424f2854c63.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/2424f2854c63"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "24d7c79b95f3", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/24d7c79b95f3.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/24d7c79b95f3"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-08-26T07:09:37.049818+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "2424f2854c63", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/2424f2854c63.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/2424f2854c63"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "24d7c79b95f3", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/24d7c79b95f3.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/24d7c79b95f3"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-08-26T07:09:34.635593+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "2424f2854c63", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/2424f2854c63.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/2424f2854c63"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "250070bc5398", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/250070bc5398.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/250070bc5398"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-08-26T06:56:57.165101+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "2424f2854c63", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/2424f2854c63.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/2424f2854c63"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b92bc74a8315", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b92bc74a8315.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b92bc74a8315"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-08-25T00:22:16.661213+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "ef089cfa8e8b", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/ef089cfa8e8b.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/ef089cfa8e8b"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "03a210718e8b", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/03a210718e8b.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/03a210718e8b"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-08-24T21:03:15.254858+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "ef089cfa8e8b", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/ef089cfa8e8b.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/ef089cfa8e8b"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "a7cce8d47c5b", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/a7cce8d47c5b.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/a7cce8d47c5b"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-08-24T20:48:51.669880+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "ef089cfa8e8b", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/ef089cfa8e8b.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/ef089cfa8e8b"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "e3ece93e425e", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/e3ece93e425e.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/e3ece93e425e"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-08-24T20:43:27.725291+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "ef089cfa8e8b", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/ef089cfa8e8b.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/ef089cfa8e8b"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "1bed2a2e6725", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1bed2a2e6725.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1bed2a2e6725"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-08-24T20:38:26.578936+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "ef089cfa8e8b", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/ef089cfa8e8b.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/ef089cfa8e8b"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "1bed2a2e6725", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1bed2a2e6725.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1bed2a2e6725"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-08-24T20:38:26.375115+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "ef089cfa8e8b", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/ef089cfa8e8b.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/ef089cfa8e8b"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "d96bc6313a58", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/d96bc6313a58.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/d96bc6313a58"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-08-24T08:53:41.128765+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "ef089cfa8e8b", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/ef089cfa8e8b.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/ef089cfa8e8b"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "60b8e67b3e44", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/60b8e67b3e44.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/60b8e67b3e44"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-08-24T01:01:11.249949+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "90f4f1fd6ac9", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/90f4f1fd6ac9.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/90f4f1fd6ac9"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "bab1d0fdafdf", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/bab1d0fdafdf.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/bab1d0fdafdf"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-08-23T10:09:42.627265+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "90f4f1fd6ac9", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/90f4f1fd6ac9.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/90f4f1fd6ac9"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "397b80d5c72f", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/397b80d5c72f.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/397b80d5c72f"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-08-23T07:12:27.332650+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "b4fcaabca049", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b4fcaabca049.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b4fcaabca049"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "faa52f1c433d", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/faa52f1c433d.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/faa52f1c433d"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-08-21T07:12:47.696745+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "b4fcaabca049", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b4fcaabca049.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b4fcaabca049"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "d2a3de17e37a", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/d2a3de17e37a.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/d2a3de17e37a"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-08-21T07:06:24.832478+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31/comments/73401103.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31/_/diff#comment-73401103"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}, "content": {"raw": "Also note that this change brings `ign-physics` into the gz11 realm, depending on all the gz11 branches.", "markup": "markdown", "html": "<p>Also note that this change brings <code>ign-physics</code> into the gz11 realm, depending on all the gz11 branches.</p>", "type": "rendered"}, "created_on": "2018-08-20T10:11:46.327957+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-08-20T10:11:46.336661+00:00", "type": "pullrequest_comment", "id": 73401103}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "641b4b34b861", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/641b4b34b861.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/641b4b34b861"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4a2271215ff9", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4a2271215ff9.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4a2271215ff9"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-08-20T10:11:10.363365+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}, {"update": {"description": "This PR continues builds on the Feature System by introducing the `EntityPtr`. I found that we have a tricky situation when it comes to handling entities. I considered both `std::unique_ptr` and `std::optional` as potential containers for our Entity objects, but I found the following issues:\r\n\r\n* `std::unique_ptr` requires allocating and deallocating memory. This is troublesome for us, because that means we need to perform allocations and deallocations any time a user wants to view an `ign-physics` object, even if no object or information is really being created or destroyed.\r\n* `std::optional` would violate logical const-correctness in our case. To illustrate this, we want a `ConstModelPtr` to only be able to access the const-qualified functions of the `Model` API. However, if we have `std::optional<const Model> constModel = /* get const model */`, then a user can simply do `std::optional<Model> nonConstModel = constModel`, and then suddenly the user has full access to the const-unqualified API of the object `constModel`. Note that `Model` is itself a proxy class, so making a \u201ccopy\u201d of a model object does not really copy the underlying data; it really creates a new reference to an object within the physics engine.\r\n\r\nTherefore, we need a container class that gives us the const semantics of `std::unique_ptr` with the performance of `std::optional`. That's exactly what `EntityPtr` does.\r\n\r\nNote that there are few pointer semantics functions that haven't been implemented yet for `EntityPtr` because they\u2019re low priority, but I left a TODO for myself in the code.", "title": "Feature System Part 5: EntityPtr", "destination": {"commit": {"hash": "641b4b34b861", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/641b4b34b861.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/641b4b34b861"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4a2271215ff9", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4a2271215ff9.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4a2271215ff9"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "EntityHandling"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-08-20T10:11:10.322712+00:00"}, "pull_request": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/31.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/31"}}, "title": "Feature System Part 5: EntityPtr"}}]}