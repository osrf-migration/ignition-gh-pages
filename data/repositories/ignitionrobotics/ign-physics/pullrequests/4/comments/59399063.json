{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/4/comments/59399063.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/4/_/diff#comment-59399063"}}, "parent": {"id": 59395257, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/4/comments/59395257.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/4/_/diff#comment-59395257"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/4.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/4"}}, "title": "Part 1: CompositeData implementation and tests"}, "content": {"raw": "> I'm having a hard time with these functions:\n\n`GetOrCreate()` would essentially map to `std::map::insert(~)`, which will return an iterator to an entry if one already existed, or else create an entry based on the input arguments (it also returns a boolean to indicate whether the entry was actually inserted). Other than that, the summary is correct. `std::map` doesn't keep track of when an entry gets queried, so the idea of \"unquerying\" an entry is meaningless to it.\n\nI'm definitely open to API changes, as long as we maintain these features, which are all currently being used in the prototype examples.\n\n> The QueryMode with Unquery also seems like a feature we can add later.\n\nProbably the most controversial feature will be the concept of keeping track of queries. This concept arose during the early design discussions between Steve, Ying, and I. The concern was that it would be easy for a plugin to either (1) be unable to handle some of the data types that it's given or (2) give data types that we can't do anything with, because compile-time knowledge of the data types is required in order to access them. This could result in silent issues that are difficult to debug where plugins aren't communicating with each other properly because they're handling different types of data. This motivates us to have a mechanism for identifying which data types each plugin is actually touching on versus which data types are being ignored. With that information, we can provide valuable sanity checks to make sure that these data structures are being handled properly and that plugins are actually utilizing the data that they're supposed to. This feature is already being used by the DART and ODE example plugins, and in fact it helped me immediately identify a mistake in my initial implementation of the DART plugin (there was a required data type that I was forgetting to handle).\n\n> Is it possible to eliminate GetOrCreate right now? We can always add back in later if the need arises.\n\nWe could merge together `Get()` and `GetOrCreate(~)` into one function that has the behavior of `GetOrCreate(~)`. I resisted doing this because I was afraid of cases like `data.Get<T>(5)` or `data.Get<T>(\"some string\")`. At first glance, this looks like you're asking for an object of type `T` at some integer or string key within a map. In actuality, what you're saying is \"get an object of type `T`, but if one doesn't already exist then create it with the constructor `T(5)` or `T(\"some string\")`\". So instead, I made it so that `Get<T>()` never accepts an argument, and a user needs to explicitly call `GetOrCreate<T>(...args...)` if they want to specify arguments to potentially construct the data type with when an entry for that type does not already exist. If that doesn't seem like a compelling rationale, I'm certainly open to merging the functions, but I would urge us to give it due consideration.\n\nNote that the behavior of `GetOrCreate(...)` is needed in order to support data types that don't have a default constructor. Otherwise, every time a user wants to \"get\" that data type, they would need to do something like \n\n```\nT* thing = data.Query<T>();\nif(!thing)\n  thing = &data.Create<T>(args);\n```\n\nwhich I think is way too much code for doing such a basic operation.\n\n> Adoption would be streamlined if an API similar to their is used here.\n\nUnfortunately, `operator[]` cannot accept template arguments, so we can't use that to streamline our API at all. We could rename some of the functions to be vaguely similar, like `GetOrCreate(...)` could be renamed `Insert(...)`, but that's the only obvious change that I can think of. I wouldn't suggest renaming `Query()` to `Find()` because it's not returning an iterator, and I wouldn't rename `Create()` to `Emplace()` since I think `Create()` is a much less intimidating function name.\n\nGiven that our overall API for CompositeData is drastically simpler than the overall `std::map` API, I'm skeptical that there will be much we can realistically do to streamline it further without crippling ourselves. I suspect the biggest barrier is that this API doesn't feel as familiar because it's not able to use the usual STL container idioms.\n\nIn most cases, plugin developers will be able to get away with just using `Get()` and `Has()`, while the rest of these functions are simply available for advanced and internal use. But again, I'm absolutely on board with streamlining the API if we can come up with a concrete way to do so without eliminating important features.", "markup": "markdown", "html": "<blockquote>\n<p>I'm having a hard time with these functions:</p>\n</blockquote>\n<p><code>GetOrCreate()</code> would essentially map to <code>std::map::insert(~)</code>, which will return an iterator to an entry if one already existed, or else create an entry based on the input arguments (it also returns a boolean to indicate whether the entry was actually inserted). Other than that, the summary is correct. <code>std::map</code> doesn't keep track of when an entry gets queried, so the idea of \"unquerying\" an entry is meaningless to it.</p>\n<p>I'm definitely open to API changes, as long as we maintain these features, which are all currently being used in the prototype examples.</p>\n<blockquote>\n<p>The QueryMode with Unquery also seems like a feature we can add later.</p>\n</blockquote>\n<p>Probably the most controversial feature will be the concept of keeping track of queries. This concept arose during the early design discussions between Steve, Ying, and I. The concern was that it would be easy for a plugin to either (1) be unable to handle some of the data types that it's given or (2) give data types that we can't do anything with, because compile-time knowledge of the data types is required in order to access them. This could result in silent issues that are difficult to debug where plugins aren't communicating with each other properly because they're handling different types of data. This motivates us to have a mechanism for identifying which data types each plugin is actually touching on versus which data types are being ignored. With that information, we can provide valuable sanity checks to make sure that these data structures are being handled properly and that plugins are actually utilizing the data that they're supposed to. This feature is already being used by the DART and ODE example plugins, and in fact it helped me immediately identify a mistake in my initial implementation of the DART plugin (there was a required data type that I was forgetting to handle).</p>\n<blockquote>\n<p>Is it possible to eliminate GetOrCreate right now? We can always add back in later if the need arises.</p>\n</blockquote>\n<p>We could merge together <code>Get()</code> and <code>GetOrCreate(~)</code> into one function that has the behavior of <code>GetOrCreate(~)</code>. I resisted doing this because I was afraid of cases like <code>data.Get&lt;T&gt;(5)</code> or <code>data.Get&lt;T&gt;(\"some string\")</code>. At first glance, this looks like you're asking for an object of type <code>T</code> at some integer or string key within a map. In actuality, what you're saying is \"get an object of type <code>T</code>, but if one doesn't already exist then create it with the constructor <code>T(5)</code> or <code>T(\"some string\")</code>\". So instead, I made it so that <code>Get&lt;T&gt;()</code> never accepts an argument, and a user needs to explicitly call <code>GetOrCreate&lt;T&gt;(...args...)</code> if they want to specify arguments to potentially construct the data type with when an entry for that type does not already exist. If that doesn't seem like a compelling rationale, I'm certainly open to merging the functions, but I would urge us to give it due consideration.</p>\n<p>Note that the behavior of <code>GetOrCreate(...)</code> is needed in order to support data types that don't have a default constructor. Otherwise, every time a user wants to \"get\" that data type, they would need to do something like </p>\n<div class=\"codehilite\"><pre><span></span>T* thing = data.Query&lt;T&gt;();\nif(!thing)\n  thing = &amp;data.Create&lt;T&gt;(args);\n</pre></div>\n\n\n<p>which I think is way too much code for doing such a basic operation.</p>\n<blockquote>\n<p>Adoption would be streamlined if an API similar to their is used here.</p>\n</blockquote>\n<p>Unfortunately, <code>operator[]</code> cannot accept template arguments, so we can't use that to streamline our API at all. We could rename some of the functions to be vaguely similar, like <code>GetOrCreate(...)</code> could be renamed <code>Insert(...)</code>, but that's the only obvious change that I can think of. I wouldn't suggest renaming <code>Query()</code> to <code>Find()</code> because it's not returning an iterator, and I wouldn't rename <code>Create()</code> to <code>Emplace()</code> since I think <code>Create()</code> is a much less intimidating function name.</p>\n<p>Given that our overall API for CompositeData is drastically simpler than the overall <code>std::map</code> API, I'm skeptical that there will be much we can realistically do to streamline it further without crippling ourselves. I suspect the biggest barrier is that this API doesn't feel as familiar because it's not able to use the usual STL container idioms.</p>\n<p>In most cases, plugin developers will be able to get away with just using <code>Get()</code> and <code>Has()</code>, while the rest of these functions are simply available for advanced and internal use. But again, I'm absolutely on board with streamlining the API if we can come up with a concrete way to do so without eliminating important features.</p>", "type": "rendered"}, "created_on": "2018-03-20T23:40:15.348145+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-03-20T23:47:42.360981+00:00", "type": "pullrequest_comment", "id": 59399063}