{"pagelen": 50, "values": [{"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64481317.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64481317"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "I added a few more tests for `ReadExpected`, `ReadRequired`, `WriteExpected` and `WriteRequired` in 8dbef68, 5c78b8f, 8235bab. Writing these tests helped clarify how the Read and Write operations work and when to expect nothing to happen", "markup": "markdown", "html": "<p>I added a few more tests for <code>ReadExpected</code>, <code>ReadRequired</code>, <code>WriteExpected</code> and <code>WriteRequired</code> in <a href=\"#!/ignitionrobotics/ign-physics/commits/8dbef68\" rel=\"nofollow\" class=\"ap-connect-link\">8dbef68</a>, <a href=\"#!/ignitionrobotics/ign-physics/commits/5c78b8f\" rel=\"nofollow\" class=\"ap-connect-link\">5c78b8f</a>, <a href=\"#!/ignitionrobotics/ign-physics/commits/8235bab\" rel=\"nofollow\" class=\"ap-connect-link\">8235bab</a>. Writing these tests helped clarify how the Read and Write operations work and when to expect nothing to happen</p>", "type": "rendered"}, "created_on": "2018-05-16T23:04:42.048042+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2018-05-16T23:04:42.062300+00:00", "type": "pullrequest_comment", "id": 64481317}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "8235babbf813", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/8235babbf813.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/8235babbf813"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-16T22:51:07.447321+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "148f221913e4", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/148f221913e4.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/148f221913e4"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-16T21:19:53.103785+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "fcc2c9b3fa5b", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/fcc2c9b3fa5b.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/fcc2c9b3fa5b"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-16T05:51:34.447253+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "f3081a10f45f", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/f3081a10f45f.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/f3081a10f45f"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-04T22:12:47.288878+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "f3081a10f45f", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/f3081a10f45f.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/f3081a10f45f"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-04T22:12:46.703825+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "3a41ea0c7e3d", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/3a41ea0c7e3d.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/3a41ea0c7e3d"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-04T22:08:33.208899+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b477f3a3865d", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b477f3a3865d.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b477f3a3865d"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "date": "2018-05-04T16:49:53.515232+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63418987.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63418987"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Can you add documentation that describes how the return value is computed, especially since it's unclear how `_value` is used without digging into the code.", "markup": "markdown", "html": "<p>Can you add documentation that describes how the return value is computed, especially since it's unclear how <code>_value</code> is used without digging into the code.</p>", "type": "rendered"}, "created_on": "2018-05-04T16:38:23.698549+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-04T16:38:23.706687+00:00", "type": "pullrequest_comment", "id": 63418987}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63418650.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63418650"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Same comment about describing how _options affect the results.", "markup": "markdown", "html": "<p>Same comment about describing how _options affect the results.</p>", "type": "rendered"}, "created_on": "2018-05-04T16:34:01.064931+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-04T16:34:01.088664+00:00", "type": "pullrequest_comment", "id": 63418650}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63418493.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63418493"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "It would be nice to describe how the _options parameters affect the write operation via the DataStatusMask.", "markup": "markdown", "html": "<p>It would be nice to describe how the _options parameters affect the write operation via the DataStatusMask.</p>", "type": "rendered"}, "created_on": "2018-05-04T16:32:21.562409+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-04T16:32:21.571467+00:00", "type": "pullrequest_comment", "id": 63418493}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63418316.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63418316"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Can you also document this enum and describe the types?", "markup": "markdown", "html": "<p>Can you also document this enum and describe the types?</p>", "type": "rendered"}, "created_on": "2018-05-04T16:30:12.279280+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-04T16:30:12.286111+00:00", "type": "pullrequest_comment", "id": 63418316}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63418095.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63418095"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "The remaining functions in this file could use documentation.", "markup": "markdown", "html": "<p>The remaining functions in this file could use documentation.</p>", "type": "rendered"}, "created_on": "2018-05-04T16:27:50.905143+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-04T16:27:50.914796+00:00", "type": "pullrequest_comment", "id": 63418095}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63417917.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63417917"}}, "parent": {"id": 63076852, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63076852.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63076852"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Actually, [\\copydoc ](https://www.stack.nl/~dimitri/doxygen/manual/commands.html#cmdcopydoc) might be better.", "markup": "markdown", "html": "<p>Actually, <a data-is-external-link=\"true\" href=\"https://www.stack.nl/~dimitri/doxygen/manual/commands.html#cmdcopydoc\" rel=\"nofollow\">\\copydoc </a> might be better.</p>", "type": "rendered"}, "created_on": "2018-05-04T16:25:48.222234+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-04T16:25:48.230268+00:00", "type": "pullrequest_comment", "id": 63417917}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63080316.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63080316"}}, "parent": {"id": 63078419, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63078419.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63078419"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Ahh, that's a good point. This might be another use case for doxygen \\ref (or some equivalent special command) in `include/ignition/physics/CanReadData.hh`", "markup": "markdown", "html": "<p>Ahh, that's a good point. This might be another use case for doxygen \\ref (or some equivalent special command) in <code>include/ignition/physics/CanReadData.hh</code></p>", "type": "rendered"}, "created_on": "2018-05-01T20:28:50.620599+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T20:28:50.626774+00:00", "type": "pullrequest_comment", "id": 63080316}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63078419.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63078419"}}, "parent": {"id": 63078209, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63078209.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63078209"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "When this warning is relevant, the compilation error that gets produced will point directly to this line of code.\n\nBut I do agree with having additional troubleshooting information somewhere other than this header.", "markup": "markdown", "html": "<p>When this warning is relevant, the compilation error that gets produced will point directly to this line of code.</p>\n<p>But I do agree with having additional troubleshooting information somewhere other than this header.</p>", "type": "rendered"}, "created_on": "2018-05-01T20:00:04.973868+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-05-01T20:00:04.987466+00:00", "type": "pullrequest_comment", "id": 63078419}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63078209.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63078209"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Can you add this type of information to a Troubleshooting section in `include/ignition/physics/CanReadData.hh`? This documentation will never appear in doxygen, and will be relatively difficult for the average user to find. The same goes for `details/CanWriteData.hh`.", "markup": "markdown", "html": "<p>Can you add this type of information to a Troubleshooting section in <code>include/ignition/physics/CanReadData.hh</code>? This documentation will never appear in doxygen, and will be relatively difficult for the average user to find. The same goes for <code>details/CanWriteData.hh</code>.</p>", "type": "rendered"}, "created_on": "2018-05-01T19:56:56.890154+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T19:56:56.899714+00:00", "type": "pullrequest_comment", "id": 63078209}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63077580.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63077580"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Can you clarify this documentation and the documentation for the SubOperate functions? Based on the documentation, I don't know when or why to use this function.", "markup": "markdown", "html": "<p>Can you clarify this documentation and the documentation for the SubOperate functions? Based on the documentation, I don't know when or why to use this function.</p>", "type": "rendered"}, "created_on": "2018-05-01T19:47:44.458246+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T19:47:44.467346+00:00", "type": "pullrequest_comment", "id": 63077580}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63077512.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63077512"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Can you add a description about what this function does?", "markup": "markdown", "html": "<p>Can you add a description about what this function does?</p>", "type": "rendered"}, "created_on": "2018-05-01T19:46:40.908718+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T19:46:40.917194+00:00", "type": "pullrequest_comment", "id": 63077512}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63077137.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63077137"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Add documentation to the parameters.", "markup": "markdown", "html": "<p>Add documentation to the parameters.</p>", "type": "rendered"}, "created_on": "2018-05-01T19:40:36.240462+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T19:40:36.250749+00:00", "type": "pullrequest_comment", "id": 63077137}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63077115.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63077115"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Is `CanOperateOnSpecifiedData` suppose to be `OperateOnSpecifiedData`?", "markup": "markdown", "html": "<p>Is <code>CanOperateOnSpecifiedData</code> suppose to be <code>OperateOnSpecifiedData</code>?</p>", "type": "rendered"}, "created_on": "2018-05-01T19:40:13.651091+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T19:40:13.659213+00:00", "type": "pullrequest_comment", "id": 63077115}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63076983.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63076983"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "The `false` here doesn't match the code below which uses `true` as the last parameter.", "markup": "markdown", "html": "<p>The <code>false</code> here doesn't match the code below which uses <code>true</code> as the last parameter.</p>", "type": "rendered"}, "created_on": "2018-05-01T19:38:13.238498+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T19:38:13.244837+00:00", "type": "pullrequest_comment", "id": 63076983}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63076852.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63076852"}}, "parent": {"id": 63053730, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63053730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63053730"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "You might be able to use [\\ref](https://www.stack.nl/~dimitri/doxygen/manual/commands.html#cmdref)", "markup": "markdown", "html": "<p>You might be able to use <a data-is-external-link=\"true\" href=\"https://www.stack.nl/~dimitri/doxygen/manual/commands.html#cmdref\" rel=\"nofollow\">\\ref</a></p>", "type": "rendered"}, "created_on": "2018-05-01T19:36:29.252796+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T19:36:29.260990+00:00", "type": "pullrequest_comment", "id": 63076852}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63053730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63053730"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "This block of text looks identical(?) to the one associated with `CanReadRequiredData`. I think there are doxygen macros that should allow you to insert documentation from other places, and prevent text duplication. I'll try to dig of that information.", "markup": "markdown", "html": "<p>This block of text looks identical(?) to the one associated with <code>CanReadRequiredData</code>. I think there are doxygen macros that should allow you to insert documentation from other places, and prevent text duplication. I'll try to dig of that information.</p>", "type": "rendered"}, "created_on": "2018-05-01T14:53:23.313950+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T14:53:23.322155+00:00", "type": "pullrequest_comment", "id": 63053730}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63053520.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63053520"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Also define CRTP here.", "markup": "markdown", "html": "<p>Also define CRTP here.</p>", "type": "rendered"}, "created_on": "2018-05-01T14:51:27.746836+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T14:51:27.756410+00:00", "type": "pullrequest_comment", "id": 63053520}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "eb432f91b6db", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/eb432f91b6db.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/eb432f91b6db"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "date": "2018-05-01T14:50:44.680419+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "eb432f91b6db", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/eb432f91b6db.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/eb432f91b6db"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "date": "2018-05-01T14:50:42.828049+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63053176.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63053176"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Document the parameters, here and elsewhere in this PR.", "markup": "markdown", "html": "<p>Document the parameters, here and elsewhere in this PR.</p>", "type": "rendered"}, "created_on": "2018-05-01T14:48:15.515427+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T14:48:15.523034+00:00", "type": "pullrequest_comment", "id": 63053176}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63052952.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63052952"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Should `MyClass` be the first template argument in this example?", "markup": "markdown", "html": "<p>Should <code>MyClass</code> be the first template argument in this example?</p>", "type": "rendered"}, "created_on": "2018-05-01T14:46:07.616717+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T14:46:07.623305+00:00", "type": "pullrequest_comment", "id": 63052952}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63052797.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63052797"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "`ReadRequiredData` should be `CanReadRequiredData`, or are you referring to something else?", "markup": "markdown", "html": "<p><code>ReadRequiredData</code> should be <code>CanReadRequiredData</code>, or are you referring to something else?</p>", "type": "rendered"}, "created_on": "2018-05-01T14:44:47.305876+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T14:44:47.314148+00:00", "type": "pullrequest_comment", "id": 63052797}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63052714.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63052714"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Can you add information as to why `CanReadExpectedData` is recommended?", "markup": "markdown", "html": "<p>Can you add information as to why <code>CanReadExpectedData</code> is recommended?</p>", "type": "rendered"}, "created_on": "2018-05-01T14:44:00.675167+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T14:44:00.681998+00:00", "type": "pullrequest_comment", "id": 63052714}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63052589.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63052589"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Can you define the `CRTP` acronym here?", "markup": "markdown", "html": "<p>Can you define the <code>CRTP</code> acronym here?</p>", "type": "rendered"}, "created_on": "2018-05-01T14:42:43.912679+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T14:42:43.922706+00:00", "type": "pullrequest_comment", "id": 63052589}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63052448.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63052448"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Document `_onlyUnqueried`.", "markup": "markdown", "html": "<p>Document <code>_onlyUnqueried</code>.</p>", "type": "rendered"}, "created_on": "2018-05-01T14:41:18.613719+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T14:41:18.622175+00:00", "type": "pullrequest_comment", "id": 63052448}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63052383.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63052383"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Can you add documentation about `ReadOptions`?", "markup": "markdown", "html": "<p>Can you add documentation about <code>ReadOptions</code>?</p>", "type": "rendered"}, "created_on": "2018-05-01T14:40:43.129682+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-05-01T14:40:43.139978+00:00", "type": "pullrequest_comment", "id": 63052383}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "0488d76bd743", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/0488d76bd743.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/0488d76bd743"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-01T00:29:45.033540+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "f4881e61ec55", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/f4881e61ec55.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/f4881e61ec55"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-04-30T21:06:43.660341+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "1a114cb7c50d", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1a114cb7c50d.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1a114cb7c50d"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-04-30T21:06:16.702768+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "1a114cb7c50d", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1a114cb7c50d.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1a114cb7c50d"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-04-30T21:06:16.632811+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "de0a1c276dcd", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/de0a1c276dcd.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/de0a1c276dcd"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "1a114cb7c50d", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1a114cb7c50d.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1a114cb7c50d"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-04-27T21:15:04.693864+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "6ff48e51730a", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/6ff48e51730a.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/6ff48e51730a"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "ac62dc4a2b0c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/ac62dc4a2b0c.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/ac62dc4a2b0c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-04-27T20:10:37.448572+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "6ff48e51730a", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/6ff48e51730a.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/6ff48e51730a"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "1e2cf367c59e", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1e2cf367c59e.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1e2cf367c59e"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-04-27T19:16:36.142761+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "1e3a9fc5f27e", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1e3a9fc5f27e.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1e3a9fc5f27e"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "a7d0af969eb9", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/a7d0af969eb9.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/a7d0af969eb9"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-04-27T19:08:09.077943+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "bbd85081c17e", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/bbd85081c17e.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/bbd85081c17e"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "13ad5b5e76e7", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/13ad5b5e76e7.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/13ad5b5e76e7"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-03-26T19:43:19.284104+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData Part 3: prototype summary", "destination": {"commit": {"hash": "bbd85081c17e", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/bbd85081c17e.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/bbd85081c17e"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "13ad5b5e76e7", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/13ad5b5e76e7.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/13ad5b5e76e7"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-03-23T07:57:53.109367+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData Part 3: prototype summary", "destination": {"commit": {"hash": "628283b31cee", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/628283b31cee.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/628283b31cee"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b24fa6211099", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b24fa6211099.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b24fa6211099"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-03-19T18:10:14.601390+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "628283b31cee", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/628283b31cee.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/628283b31cee"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b24fa6211099", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b24fa6211099.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b24fa6211099"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-03-14T23:06:56.657811+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "628283b31cee", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/628283b31cee.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/628283b31cee"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "12625db54fa7", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/12625db54fa7.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/12625db54fa7"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-03-14T23:06:42.167249+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/58862385.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-58862385"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "I think we could backport the removal of `IGN_PHYSICS_DATA_LABEL` from `experimental/dart` and update the pull request description. I can do this if @mxgrey doesn't mind", "markup": "markdown", "html": "<p>I think we could backport the removal of <code>IGN_PHYSICS_DATA_LABEL</code> from <code>experimental/dart</code> and update the pull request description. I can do this if @mxgrey doesn't mind</p>", "type": "rendered"}, "created_on": "2018-03-14T20:47:38.188462+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2018-03-14T20:47:38.199322+00:00", "type": "pullrequest_comment", "id": 58862385}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "f224ebb86a12", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/f224ebb86a12.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/f224ebb86a12"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "a4cc7f1d91ab", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/a4cc7f1d91ab.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/a4cc7f1d91ab"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-03-13T20:53:41.604392+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "89fb550667b4", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/89fb550667b4.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/89fb550667b4"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "f6def03f216f", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/f6def03f216f.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/f6def03f216f"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-01-18T20:01:33.357224+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}], "next": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/activity_ctx=Koet96fXhb.json"}