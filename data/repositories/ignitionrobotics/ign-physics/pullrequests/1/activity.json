{"pagelen": 50, "values": [{"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4297959e0921", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4297959e0921.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4297959e0921"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "MERGED", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-06-06T09:34:37.018683+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4297959e0921", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4297959e0921.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4297959e0921"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-06-05T11:01:19.692454+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4297959e0921", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4297959e0921.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4297959e0921"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-06-05T11:01:19.444865+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "562f9cd065b6", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/562f9cd065b6.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/562f9cd065b6"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-06-05T10:57:43.937435+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "562f9cd065b6", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/562f9cd065b6.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/562f9cd065b6"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-06-05T10:57:41.831956+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66151469.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66151469"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "I believe all reviewer feedback has been addressed. I'll merge this tomorrow if there are no objections (or feel free to merge it while I'm sleeping).", "markup": "markdown", "html": "<p>I believe all reviewer feedback has been addressed. I'll merge this tomorrow if there are no objections (or feel free to merge it while I'm sleeping).</p>", "type": "rendered"}, "created_on": "2018-06-05T06:08:24.009073+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-06-05T06:08:24.019728+00:00", "type": "pullrequest_comment", "id": 66151469}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"approval": {"date": "2018-06-05T06:07:42.759789+00:00", "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66151369.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66151369"}}, "parent": {"id": 63052714, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63052714.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63052714"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Recommendation explained here: 71fd3be", "markup": "markdown", "html": "<p>Recommendation explained here: <a href=\"#!/ignitionrobotics/ign-physics/commits/71fd3be\" rel=\"nofollow\" class=\"ap-connect-link\">71fd3be</a></p>", "type": "rendered"}, "created_on": "2018-06-05T06:07:02.954803+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-06-05T06:07:02.963822+00:00", "type": "pullrequest_comment", "id": 66151369}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66151346.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66151346"}}, "parent": {"id": 63077115, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63077115.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63077115"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Correct, fixed here: 2c5423e", "markup": "markdown", "html": "<p>Correct, fixed here: <a href=\"#!/ignitionrobotics/ign-physics/commits/2c5423e\" rel=\"nofollow\" class=\"ap-connect-link\">2c5423e</a></p>", "type": "rendered"}, "created_on": "2018-06-05T06:06:40.888874+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-06-05T06:06:40.895537+00:00", "type": "pullrequest_comment", "id": 66151346}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66151329.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66151329"}}, "parent": {"id": 63077137, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63077137.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63077137"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Parameters are added here: 5c2bb8e", "markup": "markdown", "html": "<p>Parameters are added here: <a href=\"#!/ignitionrobotics/ign-physics/commits/5c2bb8e\" rel=\"nofollow\" class=\"ap-connect-link\">5c2bb8e</a></p>", "type": "rendered"}, "created_on": "2018-06-05T06:06:21.135548+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-06-05T06:06:21.143316+00:00", "type": "pullrequest_comment", "id": 66151329}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66151287.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66151287"}}, "parent": {"id": 63077512, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63077512.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63077512"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Elaborated here: d715cd0", "markup": "markdown", "html": "<p>Elaborated here: <a href=\"#!/ignitionrobotics/ign-physics/commits/d715cd0\" rel=\"nofollow\" class=\"ap-connect-link\">d715cd0</a></p>", "type": "rendered"}, "created_on": "2018-06-05T06:05:45.648505+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-06-05T06:05:45.655726+00:00", "type": "pullrequest_comment", "id": 66151287}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66151265.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66151265"}}, "parent": {"id": 63080316, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63080316.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63080316"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "I made some changes in 10796af and 5c2bb8e\n\nThe result is that this block of text will be given its own page of documentation (which normally wouldn't happen for this function, because `ReadDataOperation` is in the `detail` namespace), and that page of documentation will be referenced by the docs of `CanReadRequiredData` and `CanWriteRequiredData`.", "markup": "markdown", "html": "<p>I made some changes in <a href=\"#!/ignitionrobotics/ign-physics/commits/10796af\" rel=\"nofollow\" class=\"ap-connect-link\">10796af</a> and <a href=\"#!/ignitionrobotics/ign-physics/commits/5c2bb8e\" rel=\"nofollow\" class=\"ap-connect-link\">5c2bb8e</a></p>\n<p>The result is that this block of text will be given its own page of documentation (which normally wouldn't happen for this function, because <code>ReadDataOperation</code> is in the <code>detail</code> namespace), and that page of documentation will be referenced by the docs of <code>CanReadRequiredData</code> and <code>CanWriteRequiredData</code>.</p>", "type": "rendered"}, "created_on": "2018-06-05T06:05:14.041374+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-06-05T06:05:14.047630+00:00", "type": "pullrequest_comment", "id": 66151265}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66151098.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66151098"}}, "parent": {"id": 63417917, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63417917.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63417917"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "I cut down on the redundancy here: 1da4dbb\n\nBy explicitly mentioning the class name that's being referred to, doxygen creates a hyperlink to it.", "markup": "markdown", "html": "<p>I cut down on the redundancy here: <a href=\"#!/ignitionrobotics/ign-physics/commits/1da4dbb\" rel=\"nofollow\" class=\"ap-connect-link\">1da4dbb</a></p>\n<p>By explicitly mentioning the class name that's being referred to, doxygen creates a hyperlink to it.</p>", "type": "rendered"}, "created_on": "2018-06-05T06:02:23.426557+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-06-05T06:02:23.433854+00:00", "type": "pullrequest_comment", "id": 66151098}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "1da4dbb4121d", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1da4dbb4121d.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1da4dbb4121d"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-06-05T05:55:19.416880+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66149895.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66149895"}}, "parent": {"id": 63418095, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63418095.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63418095"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Their documentation can be found in the header where they're declared.", "markup": "markdown", "html": "<p>Their documentation can be found in the header where they're declared.</p>", "type": "rendered"}, "created_on": "2018-06-05T05:47:17.083754+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-06-05T05:47:17.094901+00:00", "type": "pullrequest_comment", "id": 66149895}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66149752.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66149752"}}, "parent": {"id": 63418493, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63418493.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63418493"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Same as [here](#!/ignitionrobotics/ign-physics/pull-requests/1/part-3-compositedata-prototype-summary/activity#comment-66149729).", "markup": "markdown", "html": "<p>Same as <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/pull-requests/1/part-3-compositedata-prototype-summary/activity#comment-66149729\" rel=\"nofollow\">here</a>.</p>", "type": "rendered"}, "created_on": "2018-06-05T05:44:46.310330+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-06-05T05:44:46.318925+00:00", "type": "pullrequest_comment", "id": 66149752}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66149729.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66149729"}}, "parent": {"id": 63418650, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63418650.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63418650"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Added: 10796af and f49401e", "markup": "markdown", "html": "<p>Added: <a href=\"#!/ignitionrobotics/ign-physics/commits/10796af\" rel=\"nofollow\" class=\"ap-connect-link\">10796af</a> and <a href=\"#!/ignitionrobotics/ign-physics/commits/f49401e\" rel=\"nofollow\" class=\"ap-connect-link\">f49401e</a></p>", "type": "rendered"}, "created_on": "2018-06-05T05:44:32.701821+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-06-05T05:44:32.710885+00:00", "type": "pullrequest_comment", "id": 66149729}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "f49401e2e662", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/f49401e2e662.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/f49401e2e662"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-06-05T05:43:30.918112+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66149414.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66149414"}}, "parent": {"id": 66109623, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66109623.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66109623"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Privatized: fbc0af5", "markup": "markdown", "html": "<p>Privatized: <a href=\"#!/ignitionrobotics/ign-physics/commits/fbc0af5\" rel=\"nofollow\" class=\"ap-connect-link\">fbc0af5</a></p>", "type": "rendered"}, "created_on": "2018-06-05T05:39:23.863694+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-06-05T05:39:23.872694+00:00", "type": "pullrequest_comment", "id": 66149414}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "71fd3be4ce78", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/71fd3be4ce78.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/71fd3be4ce78"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-06-05T05:38:36.316601+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66109623.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66109623"}}, "parent": {"id": 66043181, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66043181.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66043181"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "making it private sounds find to me", "markup": "markdown", "html": "<p>making it private sounds find to me</p>", "type": "rendered"}, "created_on": "2018-06-04T17:45:57.101565+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-06-04T17:45:57.108060+00:00", "type": "pullrequest_comment", "id": 66109623}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/66043181.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-66043181"}}, "parent": {"id": 64736280, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64736280.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64736280"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "`CanReadData` and `CanWriteData` use the `Operate` function rather than the `SubOperate`.\n\nWe could consider making `SubOperate` private to indicate that we expect users to only call `Operate`.", "markup": "markdown", "html": "<p><code>CanReadData</code> and <code>CanWriteData</code> use the <code>Operate</code> function rather than the <code>SubOperate</code>.</p>\n<p>We could consider making <code>SubOperate</code> private to indicate that we expect users to only call <code>Operate</code>.</p>", "type": "rendered"}, "created_on": "2018-06-04T09:07:11.279184+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-06-04T09:07:11.288536+00:00", "type": "pullrequest_comment", "id": 66043181}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64736290.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64736290"}}, "parent": {"id": 64733653, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64733653.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64733653"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "ok, I think I'm done now", "markup": "markdown", "html": "<p>ok, I think I'm done now</p>", "type": "rendered"}, "created_on": "2018-05-19T07:18:02.198341+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2018-05-19T07:18:02.204959+00:00", "type": "pullrequest_comment", "id": 64736290}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64736280.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64736280"}}, "parent": {"id": 63077580, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63077580.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63077580"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "This is part of the public API, but I don't think we expect anyone to use it. It's used by CanReadData and CanWriteData internally, but I don't expect users to use it directly", "markup": "markdown", "html": "<p>This is part of the public API, but I don't think we expect anyone to use it. It's used by CanReadData and CanWriteData internally, but I don't expect users to use it directly</p>", "type": "rendered"}, "created_on": "2018-05-19T07:16:26.030689+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-05-19T07:16:26.038702+00:00", "type": "pullrequest_comment", "id": 64736280}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64733653.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64733653"}}, "parent": {"id": 64706136, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64706136.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64706136"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "I've addressed many of your comments. There's a few more I think I can handle; I'll leave the rest for @mxgrey", "markup": "markdown", "html": "<p>I've addressed many of your comments. There's a few more I think I can handle; I'll leave the rest for @mxgrey</p>", "type": "rendered"}, "created_on": "2018-05-19T00:35:03.461255+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2018-05-19T00:35:03.478368+00:00", "type": "pullrequest_comment", "id": 64733653}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64733520.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64733520"}}, "parent": {"id": 63418316, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63418316.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63418316"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "c63a1e050959", "markup": "markdown", "html": "<p><a href=\"#!/ignitionrobotics/ign-physics/commits/c63a1e050959\" rel=\"nofollow\" class=\"ap-connect-link\">c63a1e050959</a></p>", "type": "rendered"}, "created_on": "2018-05-19T00:26:29.458819+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-05-19T00:26:29.465477+00:00", "type": "pullrequest_comment", "id": 64733520}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64733519.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64733519"}}, "parent": {"id": 63418987, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63418987.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63418987"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "c63a1e050959", "markup": "markdown", "html": "<p><a href=\"#!/ignitionrobotics/ign-physics/commits/c63a1e050959\" rel=\"nofollow\" class=\"ap-connect-link\">c63a1e050959</a></p>", "type": "rendered"}, "created_on": "2018-05-19T00:26:20.975321+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-05-19T00:26:20.990705+00:00", "type": "pullrequest_comment", "id": 64733519}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "c63a1e050959", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/c63a1e050959.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/c63a1e050959"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-19T00:24:53.567760+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64732959.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64732959"}}, "parent": {"id": 64732896, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64732896.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64732896"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "and 4b59f3ac8367", "markup": "markdown", "html": "<p>and <a href=\"#!/ignitionrobotics/ign-physics/commits/4b59f3ac8367\" rel=\"nofollow\" class=\"ap-connect-link\">4b59f3ac8367</a></p>", "type": "rendered"}, "created_on": "2018-05-18T23:53:20.913941+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-05-18T23:53:20.922002+00:00", "type": "pullrequest_comment", "id": 64732959}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4b59f3ac8367", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4b59f3ac8367.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4b59f3ac8367"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-18T23:53:00.997469+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64732896.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64732896"}}, "parent": {"id": 63052797, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63052797.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63052797"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "yeah, this paragraph was inconsistent. I've hopefully improved it in 00d84bb894c4", "markup": "markdown", "html": "<p>yeah, this paragraph was inconsistent. I've hopefully improved it in <a href=\"#!/ignitionrobotics/ign-physics/commits/00d84bb894c4\" rel=\"nofollow\" class=\"ap-connect-link\">00d84bb894c4</a></p>", "type": "rendered"}, "created_on": "2018-05-18T23:49:31.821416+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-05-18T23:49:31.827775+00:00", "type": "pullrequest_comment", "id": 64732896}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "00d84bb894c4", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/00d84bb894c4.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/00d84bb894c4"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-18T23:49:07.997952+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64731606.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64731606"}}, "parent": {"id": 63053176, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63053176.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63053176"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "docs for parameters in CanReadData and CanWriteData in 82edb3f", "markup": "markdown", "html": "<p>docs for parameters in CanReadData and CanWriteData in <a href=\"#!/ignitionrobotics/ign-physics/commits/82edb3f\" rel=\"nofollow\" class=\"ap-connect-link\">82edb3f</a></p>", "type": "rendered"}, "created_on": "2018-05-18T23:02:25.860920+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-05-18T23:02:25.867514+00:00", "type": "pullrequest_comment", "id": 64731606}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "82edb3fa068a", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/82edb3fa068a.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/82edb3fa068a"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-18T23:00:01.116383+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "dbd93cefad4c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/dbd93cefad4c.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/dbd93cefad4c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-18T22:30:13.704418+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64716203.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64716203"}}, "parent": {"id": 63052448, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63052448.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63052448"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "6b420f8c4f12", "markup": "markdown", "html": "<p><a href=\"#!/ignitionrobotics/ign-physics/commits/6b420f8c4f12\" rel=\"nofollow\" class=\"ap-connect-link\">6b420f8c4f12</a></p>", "type": "rendered"}, "created_on": "2018-05-18T18:33:32.061989+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-05-18T18:33:32.068979+00:00", "type": "pullrequest_comment", "id": 64716203}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64716195.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64716195"}}, "parent": {"id": 63052383, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63052383.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63052383"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "6b420f8c4f12", "markup": "markdown", "html": "<p><a href=\"#!/ignitionrobotics/ign-physics/commits/6b420f8c4f12\" rel=\"nofollow\" class=\"ap-connect-link\">6b420f8c4f12</a></p>", "type": "rendered"}, "created_on": "2018-05-18T18:33:25.046722+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-05-18T18:33:25.055125+00:00", "type": "pullrequest_comment", "id": 64716195}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "6b420f8c4f12", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/6b420f8c4f12.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/6b420f8c4f12"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-18T18:33:21.807851+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64715634.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64715634"}}, "parent": {"id": 63053520, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63053520.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63053520"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "[7757f7ddc8cc](#!/ignitionrobotics/ign-physics/commits/7757f7ddc8cc)", "markup": "markdown", "html": "<p><a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/commits/7757f7ddc8cc\" rel=\"nofollow\">7757f7ddc8cc</a></p>", "type": "rendered"}, "created_on": "2018-05-18T18:25:54.582572+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-05-18T18:25:54.588888+00:00", "type": "pullrequest_comment", "id": 64715634}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64715605.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64715605"}}, "parent": {"id": 63052589, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63052589.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63052589"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "I clarified it a bit in 7757f7ddc8cc; let me know if you want more", "markup": "markdown", "html": "<p>I clarified it a bit in <a href=\"#!/ignitionrobotics/ign-physics/commits/7757f7ddc8cc\" rel=\"nofollow\" class=\"ap-connect-link\">7757f7ddc8cc</a>; let me know if you want more</p>", "type": "rendered"}, "created_on": "2018-05-18T18:25:31.332457+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-05-18T18:25:31.341923+00:00", "type": "pullrequest_comment", "id": 64715605}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "7757f7ddc8cc", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/7757f7ddc8cc.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/7757f7ddc8cc"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-18T18:24:55.622456+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64715467.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64715467"}}, "parent": {"id": 63076983, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63076983.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63076983"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "f9141fc9d914", "markup": "markdown", "html": "<p><a href=\"#!/ignitionrobotics/ign-physics/commits/f9141fc9d914\" rel=\"nofollow\" class=\"ap-connect-link\">f9141fc9d914</a></p>", "type": "rendered"}, "created_on": "2018-05-18T18:23:25.149557+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-05-18T18:23:25.157043+00:00", "type": "pullrequest_comment", "id": 64715467}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "f9141fc9d914", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/f9141fc9d914.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/f9141fc9d914"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-18T18:23:17.541223+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64714929.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64714929"}}, "parent": {"id": 63052952, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/63052952.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-63052952"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": " 148f221", "markup": "markdown", "html": "<p><a href=\"#!/ignitionrobotics/ign-physics/commits/148f221\" rel=\"nofollow\" class=\"ap-connect-link\">148f221</a></p>", "type": "rendered"}, "created_on": "2018-05-18T18:15:48.777193+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-05-18T18:15:48.785704+00:00", "type": "pullrequest_comment", "id": 64714929}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"approval": {"date": "2018-05-18T16:24:49.971768+00:00", "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64706136.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64706136"}}, "parent": {"id": 64483957, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64483957.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64483957"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "My comments don\u2019t effect the functionality. I\u2019ll approve.", "markup": "markdown", "html": "<p>My comments don\u2019t effect the functionality. I\u2019ll approve.</p>", "type": "rendered"}, "created_on": "2018-05-18T16:24:47.429383+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2018-05-18T16:24:47.438519+00:00", "type": "pullrequest_comment", "id": 64706136}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64483957.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64483957"}}, "parent": {"id": 64483441, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64483441.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64483441"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "sorry I forgot about your comments. I'll take a look and if it's small enough, we can just add the documentation to this pull request", "markup": "markdown", "html": "<p>sorry I forgot about your comments. I'll take a look and if it's small enough, we can just add the documentation to this pull request</p>", "type": "rendered"}, "created_on": "2018-05-17T00:01:14.571629+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2018-05-17T00:01:14.579003+00:00", "type": "pullrequest_comment", "id": 64483957}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/64483441.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-64483441"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "The functionality looks fine to me, but there is a lot of missing documentation. Do you \\(@scpeters or @mxgrey \\) want to break documentation out into a separate task/pull request? ", "markup": "markdown", "html": "<p>The functionality looks fine to me, but there is a lot of missing documentation. Do you (@scpeters or @mxgrey ) want to break documentation out into a separate task/pull request? </p>", "type": "rendered"}, "created_on": "2018-05-16T23:50:16.717953+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2018-05-16T23:50:16.733570+00:00", "type": "pullrequest_comment", "id": 64483441}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"approval": {"date": "2018-05-16T23:20:19.609580+00:00", "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "Part 3: CompositeData prototype summary", "destination": {"commit": {"hash": "b2c4fb7e7730", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b2c4fb7e7730.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b2c4fb7e7730"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "83fad99b2909", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/83fad99b2909.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/83fad99b2909"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-05-16T23:15:33.709702+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}], "next": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/activity_ctx=kjCX7tghz.json"}