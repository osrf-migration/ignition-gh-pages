{"pagelen": 50, "values": [{"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "790ccf162a08", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/790ccf162a08.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/790ccf162a08"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4ab7c70e2920", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4ab7c70e2920.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4ab7c70e2920"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2017-12-13T03:12:20.499185+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "b551ea14f9e0", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b551ea14f9e0.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b551ea14f9e0"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "38640e55e502", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/38640e55e502.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/38640e55e502"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2017-12-13T01:49:45.276724+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "0199e60ea2fd", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/0199e60ea2fd.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/0199e60ea2fd"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "50a7948e00f2", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/50a7948e00f2.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/50a7948e00f2"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2017-11-13T21:52:57.312977+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "d0ceab3c7c3b", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/d0ceab3c7c3b.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/d0ceab3c7c3b"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "24db48b6cbee", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/24db48b6cbee.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/24db48b6cbee"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-11-08T18:48:55.861615+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "47876273f504", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/47876273f504.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/47876273f504"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "62017df4431e", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/62017df4431e.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/62017df4431e"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2017-11-08T00:11:01.092530+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "cf67c1574afc", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/cf67c1574afc.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/cf67c1574afc"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "2efe360d390e", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/2efe360d390e.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/2efe360d390e"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-11-02T01:02:08.912474+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/45873904.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-45873904"}}, "parent": {"id": 45873737, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/45873737.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-45873737"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Certainly. This header is going to be riddled with bad practices, since it's just meant to be a roughly sketched prototype. Ultimately, I think these data structures should be auto-generated from some type of meta file, like protobuff.", "markup": "markdown", "html": "<p>Certainly. This header is going to be riddled with bad practices, since it's just meant to be a roughly sketched prototype. Ultimately, I think these data structures should be auto-generated from some type of meta file, like protobuff.</p>", "type": "rendered"}, "created_on": "2017-09-27T00:19:55.667865+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2017-09-27T00:19:55.670286+00:00", "type": "pullrequest_comment", "id": 45873904}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/45873737.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-45873737"}}, "parent": {"id": 45873725, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/45873725.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-45873725"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "ie:\n\n~~~\ndouble P = 0;\ndouble I = 0;\ndouble D = 0;\n~~~", "markup": "markdown", "html": "<p>ie:</p>\n<div class=\"codehilite\"><pre><span></span>double P = 0;\ndouble I = 0;\ndouble D = 0;\n</pre></div>", "type": "rendered"}, "created_on": "2017-09-27T00:15:08.219089+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2017-09-27T00:15:08.221847+00:00", "type": "pullrequest_comment", "id": 45873737}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/45873725.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-45873725"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Should we initialize these gains to zero? I think we don't want to have uninitialized variables.", "markup": "markdown", "html": "<p>Should we initialize these gains to zero? I think we don't want to have uninitialized variables.</p>", "type": "rendered"}, "created_on": "2017-09-27T00:14:49.745917+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2017-09-27T00:14:49.748099+00:00", "type": "pullrequest_comment", "id": 45873725}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43939962.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43939962"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "I've expanded on the header documentation for `CompositeData.hh`. Now (almost) every function in the class has some example usage code in its header description. You can find these changes in pull request #4, or more specifically in [this version of CompositeData.hh](#!/ignitionrobotics/ign-physics/src/2469027d11ad4a3a8df322d24bfedeaa7f551303/include/ignition/physics/CompositeData.hh?at=JustCompositeData&fileviewer=file-view-default).\n\nEach block of example code is a fully-functional C++ translation unit which can be copy/pasted into a blank source file and compiled into an executable. If this is excessive, please let me know.", "markup": "markdown", "html": "<p>I've expanded on the header documentation for <code>CompositeData.hh</code>. Now (almost) every function in the class has some example usage code in its header description. You can find these changes in <a href=\"#!/ignitionrobotics/ign-physics/pull-requests/4/part-1-compositedata-implementation-and\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #4</a>, or more specifically in <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/src/2469027d11ad4a3a8df322d24bfedeaa7f551303/include/ignition/physics/CompositeData.hh?at=JustCompositeData&amp;fileviewer=file-view-default\" rel=\"nofollow\">this version of CompositeData.hh</a>.</p>\n<p>Each block of example code is a fully-functional C++ translation unit which can be copy/pasted into a blank source file and compiled into an executable. If this is excessive, please let me know.</p>", "type": "rendered"}, "created_on": "2017-08-30T23:11:48.401983+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-08-30T23:11:48.404421+00:00", "type": "pullrequest_comment", "id": 43939962}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "9c45fc04fb35", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/9c45fc04fb35.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/9c45fc04fb35"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "f4a850262d87", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/f4a850262d87.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/f4a850262d87"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-30T22:52:21.961740+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43857958.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43857958"}}, "parent": {"id": 43854217, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43854217.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43854217"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "After some more thought, I realized what you meant by using function overloading.\n\nThe problem with that is we would eliminate the ability for plugins to provide their own data types and operate in terms of those types. To illustrate this, my DART example would not necessarily work if we did this, because the DART plugin wouldn't be able to embed a proper copy of its concept of a state into the `State` object that we retrieve from it.\n\nMoving forward, it's not hard to imagine scenarios where someone might want to have multiple plugins that operate in different parts of the Gazebo pipeline, but they want to be able to pass custom data between those plugins through the pipeline, which motivates us to support arbitrary types natively through the pipeline instead of forcing users to figure out workarounds. The basic idea is that we want plugins to naturally integrate into the framework instead of needing to kludge them in through improvised (and probably poorly constructed) means.\n\nEdit: typos", "markup": "markdown", "html": "<p>After some more thought, I realized what you meant by using function overloading.</p>\n<p>The problem with that is we would eliminate the ability for plugins to provide their own data types and operate in terms of those types. To illustrate this, my DART example would not necessarily work if we did this, because the DART plugin wouldn't be able to embed a proper copy of its concept of a state into the <code>State</code> object that we retrieve from it.</p>\n<p>Moving forward, it's not hard to imagine scenarios where someone might want to have multiple plugins that operate in different parts of the Gazebo pipeline, but they want to be able to pass custom data between those plugins through the pipeline, which motivates us to support arbitrary types natively through the pipeline instead of forcing users to figure out workarounds. The basic idea is that we want plugins to naturally integrate into the framework instead of needing to kludge them in through improvised (and probably poorly constructed) means.</p>\n<p>Edit: typos</p>", "type": "rendered"}, "created_on": "2017-08-30T07:30:08.360507+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-08-30T07:33:01.918465+00:00", "type": "pullrequest_comment", "id": 43857958}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43854217.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43854217"}}, "parent": {"id": 43848150, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43848150.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43848150"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Thanks for the feedback!\n\n> Instead of using RequireData and ExpectData, can we get started with something simple: like the function overloading in C++, \n\n~~I'm not really clear on what role you would like function overloading to play with respect to CompositeData or how `RequireData` and `ExpectData` can be replaced using function overloading. Just to clarify our semantics, \"function overloading\" is defining multiple functions with the same name but distinguishing them by their signatures (i.e. they take different sets of arguments or have different cv-qualifiers). If you instead mean using virtual functions and overriding them, then I'm still not sure what role that would play, since all the functions provided by `RequireData` and `ExpectData` are templated functions, and templated functions cannot be virtual; they can only be shadowed (which is what we're doing). We also can't avoid using templated functions if we want good performance and/or strong type safety. If you have an alternative implementation in mind, I'd be happy to discuss it (even if it's not fleshed out yet).~~ Edit: See my next comment (which is a reply to this comment) for my revised response to this bullet point.\n\nUltimately, I don't think the existence or use of `RequireData` or `ExpectData` will have a negative impact for users or developers, since they could just be used as higher performance versions of `CompositeData`. There's more that an expert user or developer may *choose* to do with `RequireData` and `ExpectData` (like template metaprogramming stuff), but there's no need for a user or developer to do those more advanced things.\n\n> Instead of holding SearchForStuff.cmake, FindFreeImage.cmake, FindSSE.cmake, etc, in the repositories of...\n\nI super duper absolutely agree with this, and it's something that I've brought up several times now. I think the best proposal we've come up with so far has been to create a unified package of CMake macros that can be distributed and installed as a deb and make it a dependency of each code base's build system. That proposal is on the shelf right now, though, because I guess it's viewed as very low priority.\n\n> Regarding the CompositeData SpecifiyData, RequiredData, how much would you think to be exposed to developers or potential contributors?\n\nThat's a good question, and the truth is, I don't know for sure yet. It might depend on how we approach our abstractions and how we end up implementing the overall Gazebo pipeline.\n\nI can definitely understand how the API can be confusing, and that concern was raised by Peter Horak as well when he reviewed the design docs. I think this is the kind of thing that's so unusual that it probably won't make sense without seeing some clear examples (and the tests don't really qualify as clear examples since they're not really demonstrating a useful application of the API). I think with some examples, the purpose and usage of the class should become very clear and intuitive. It pretty much boils down to: `CompositeData` is a container for an arbitrary batch of data objects which you can retrieve, create, or delete. Some data can be marked as \"required\" in which case you can't delete it. Everything else in the `CompositeData` API just provides some extra utility for advanced users/developers and probably won't matter to most people.\n\nI don't imagine we can really wrap another layer on top without basically eliminating the purpose of the class altogether, but I'm definitely open to ideas if you have any.\n\n> As for the GetOrCreate API, if I have data.Get<JointProperty>(2) \n\nI probably did a poor job of explaining this above, but what I was trying to say was that `data.Get<JointProperty>(2)` is **not** an option in the current implementation. It wouldn't compile, because the `Get<T>()` function does not accept any arguments. I designed it to not accept any arguments specifically because I didn't want to create the kind of confusion you just described in 4.(1) and 4.(2). Every data type stored in a `CompositeData` must have one unique instance. If you want to store a vector of some type, then it must be wrapped, like:\n\n```\nstruct MyDataVector\n{\n  IGN_PHYSICS_DATA_LABEL(MyDataVector)\n  std::vector<MyData> vec;\n};\n```\n\nThen you can retrieve element `i` from your vector using `data.Get<MyDataVector>().vec[i];`. The reason for this design choice is that (1) some data types might need to be unique (i.e. only one instance of it should be allowed to exist within a `CompositeData`), in which case, our design should not make an assumption that all data types can have multiple copies, and (2) if any data types need to have multiple copies within one `CompositeData`, they can always wrap the multiple copies up into one unique type, as shown above.\n\nSo `Get<T>()` always retrieves the one unique instance of data type `T` within your `CompositeData` object (or it will create `T` with the default constructor of `T` if an instance of `T` is not already available in your `CompositeData` object). If you need a function that will create `T` with a specific set of arguments when `T` did not already exist, then you must use `GetOrCreate<T>(~)`, and you can pass the constructor of `T` any arguments that you would like.\n\n> more explanation on silent query would be appreciated, maybe 1-2 sentence descriptive example usage in the physics simulation where we require query to have state\n\nStrictly speaking, the query flags and the silent modes aren't ever really *necessary* to use since they don't effect the data inside of the `CompositeData`. They exist for advanced use if you want to do some introspection into whether you're handling (or even aware of) all the data inside of a `CompositeData` object that you've been given. That said, I'll be happy to put together some examples of how to use it to identify data types that your program is not handling.\n\n> (side note: No need to address these comments in rush, we can talk)\n\nI just saw this after I finished typing out all of the above, but even if I had seen it earlier, I don't think it would've affected my decision to reply ;D\n\nEdit: Corrected the definition of `MyDataVector`", "markup": "markdown", "html": "<p>Thanks for the feedback!</p>\n<blockquote>\n<p>Instead of using RequireData and ExpectData, can we get started with something simple: like the function overloading in C++, </p>\n</blockquote>\n<p><del>I'm not really clear on what role you would like function overloading to play with respect to CompositeData or how <code>RequireData</code> and <code>ExpectData</code> can be replaced using function overloading. Just to clarify our semantics, \"function overloading\" is defining multiple functions with the same name but distinguishing them by their signatures (i.e. they take different sets of arguments or have different cv-qualifiers). If you instead mean using virtual functions and overriding them, then I'm still not sure what role that would play, since all the functions provided by <code>RequireData</code> and <code>ExpectData</code> are templated functions, and templated functions cannot be virtual; they can only be shadowed (which is what we're doing). We also can't avoid using templated functions if we want good performance and/or strong type safety. If you have an alternative implementation in mind, I'd be happy to discuss it (even if it's not fleshed out yet).</del> Edit: See my next comment (which is a reply to this comment) for my revised response to this bullet point.</p>\n<p>Ultimately, I don't think the existence or use of <code>RequireData</code> or <code>ExpectData</code> will have a negative impact for users or developers, since they could just be used as higher performance versions of <code>CompositeData</code>. There's more that an expert user or developer may <em>choose</em> to do with <code>RequireData</code> and <code>ExpectData</code> (like template metaprogramming stuff), but there's no need for a user or developer to do those more advanced things.</p>\n<blockquote>\n<p>Instead of holding SearchForStuff.cmake, FindFreeImage.cmake, FindSSE.cmake, etc, in the repositories of...</p>\n</blockquote>\n<p>I super duper absolutely agree with this, and it's something that I've brought up several times now. I think the best proposal we've come up with so far has been to create a unified package of CMake macros that can be distributed and installed as a deb and make it a dependency of each code base's build system. That proposal is on the shelf right now, though, because I guess it's viewed as very low priority.</p>\n<blockquote>\n<p>Regarding the CompositeData SpecifiyData, RequiredData, how much would you think to be exposed to developers or potential contributors?</p>\n</blockquote>\n<p>That's a good question, and the truth is, I don't know for sure yet. It might depend on how we approach our abstractions and how we end up implementing the overall Gazebo pipeline.</p>\n<p>I can definitely understand how the API can be confusing, and that concern was raised by Peter Horak as well when he reviewed the design docs. I think this is the kind of thing that's so unusual that it probably won't make sense without seeing some clear examples (and the tests don't really qualify as clear examples since they're not really demonstrating a useful application of the API). I think with some examples, the purpose and usage of the class should become very clear and intuitive. It pretty much boils down to: <code>CompositeData</code> is a container for an arbitrary batch of data objects which you can retrieve, create, or delete. Some data can be marked as \"required\" in which case you can't delete it. Everything else in the <code>CompositeData</code> API just provides some extra utility for advanced users/developers and probably won't matter to most people.</p>\n<p>I don't imagine we can really wrap another layer on top without basically eliminating the purpose of the class altogether, but I'm definitely open to ideas if you have any.</p>\n<blockquote>\n<p>As for the GetOrCreate API, if I have data.Get&lt;JointProperty&gt;(2) </p>\n</blockquote>\n<p>I probably did a poor job of explaining this above, but what I was trying to say was that <code>data.Get&lt;JointProperty&gt;(2)</code> is <strong>not</strong> an option in the current implementation. It wouldn't compile, because the <code>Get&lt;T&gt;()</code> function does not accept any arguments. I designed it to not accept any arguments specifically because I didn't want to create the kind of confusion you just described in 4.(1) and 4.(2). Every data type stored in a <code>CompositeData</code> must have one unique instance. If you want to store a vector of some type, then it must be wrapped, like:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"nt\">struct</span> <span class=\"nt\">MyDataVector</span>\n<span class=\"p\">{</span>\n  <span class=\"err\">IGN_PHYSICS_DATA_LABEL(MyDataVector)</span>\n  <span class=\"n\">std</span><span class=\"p\">:</span><span class=\"o\">:</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">MyData</span><span class=\"o\">&gt;</span> <span class=\"n\">vec</span><span class=\"p\">;</span>\n<span class=\"p\">}</span><span class=\"o\">;</span>\n</pre></div>\n\n\n<p>Then you can retrieve element <code>i</code> from your vector using <code>data.Get&lt;MyDataVector&gt;().vec[i];</code>. The reason for this design choice is that (1) some data types might need to be unique (i.e. only one instance of it should be allowed to exist within a <code>CompositeData</code>), in which case, our design should not make an assumption that all data types can have multiple copies, and (2) if any data types need to have multiple copies within one <code>CompositeData</code>, they can always wrap the multiple copies up into one unique type, as shown above.</p>\n<p>So <code>Get&lt;T&gt;()</code> always retrieves the one unique instance of data type <code>T</code> within your <code>CompositeData</code> object (or it will create <code>T</code> with the default constructor of <code>T</code> if an instance of <code>T</code> is not already available in your <code>CompositeData</code> object). If you need a function that will create <code>T</code> with a specific set of arguments when <code>T</code> did not already exist, then you must use <code>GetOrCreate&lt;T&gt;(~)</code>, and you can pass the constructor of <code>T</code> any arguments that you would like.</p>\n<blockquote>\n<p>more explanation on silent query would be appreciated, maybe 1-2 sentence descriptive example usage in the physics simulation where we require query to have state</p>\n</blockquote>\n<p>Strictly speaking, the query flags and the silent modes aren't ever really <em>necessary</em> to use since they don't effect the data inside of the <code>CompositeData</code>. They exist for advanced use if you want to do some introspection into whether you're handling (or even aware of) all the data inside of a <code>CompositeData</code> object that you've been given. That said, I'll be happy to put together some examples of how to use it to identify data types that your program is not handling.</p>\n<blockquote>\n<p>(side note: No need to address these comments in rush, we can talk)</p>\n</blockquote>\n<p>I just saw this after I finished typing out all of the above, but even if I had seen it earlier, I don't think it would've affected my decision to reply ;D</p>\n<p>Edit: Corrected the definition of <code>MyDataVector</code></p>", "type": "rendered"}, "created_on": "2017-08-30T06:40:38.483977+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-08-30T07:31:44.265632+00:00", "type": "pullrequest_comment", "id": 43854217}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43848150.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43848150"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Great job @mxgrey That's a lot of code and obviously with thorough thoughts and careful designs!     \nSome high level comments from first pass, I suggest us fully agree on these pull requests before we move on to the next step :)       \n\n1. Instead of using `RequireData` and `ExpectData`, can we get started with something simple: like the `function overloading` in C++,   \n     of course we will lose some flexibility since we have to always put required data ahead of the optional ones in the function arguments   \n\n2.  Instead of holding `SearchForStuff.cmake`, `FindFreeImage.cmake`, `FindSSE.cmake`, etc, in the repositories of gazebo, ign-commons, ign-math, and now one more ign-physics, and   \n     let them diverge (since I saw some changes from this ign-physics PR), we might want to put them in one place and offer a URL to get a collection of these files   \n     Similar application in ROS to maintain multiple packages, but not exactly the same: https://raw.githubusercontent.com/ros2/ros2/release-latest/ros2.repos  \n     We can similarly add some script to download these .cmake from a common place, to the gazebo repo's cmake directory    \n\n3. Regarding the `CompositeData` `SpecifiyData`, `RequiredData`, how much would you think to be exposed to developers or potential contributors? When I first read the API, I personally feel    \n    it is not that straightforward to contribute and use. But it makes more sense after reading the test for some example usages. So I am kind of wondering if we can wrap one more layer on top    \n    to facilitate the usage and understanding. Or provide concise examples.     \n\n4. As for the `GetOrCreate` API,  if I have `data.Get<JointProperty>(2)`    \n       (1) if the JointProperty data type is NOT available, this means constructing a `JointProperty` with the argument of 2    \n       (2) if the JointProperty data type is available, this means get the JointProperty of index at 2? (Or my understanding is only `query` API will get data)    \n\n5. more explanation on `silent query` would be appreciated, maybe 1-2 sentence descriptive example usage in the physics simulation where we require query to have state    \n\n\n(side note: No need to address these comments in rush, we can talk)   \n", "markup": "markdown", "html": "<p>Great job @mxgrey That's a lot of code and obviously with thorough thoughts and careful designs!   <br />\nSome high level comments from first pass, I suggest us fully agree on these pull requests before we move on to the next step :)       </p>\n<ol>\n<li>\n<p>Instead of using <code>RequireData</code> and <code>ExpectData</code>, can we get started with something simple: like the <code>function overloading</code> in C++, <br />\n     of course we will lose some flexibility since we have to always put required data ahead of the optional ones in the function arguments   </p>\n</li>\n<li>\n<p>Instead of holding <code>SearchForStuff.cmake</code>, <code>FindFreeImage.cmake</code>, <code>FindSSE.cmake</code>, etc, in the repositories of gazebo, ign-commons, ign-math, and now one more ign-physics, and <br />\n     let them diverge (since I saw some changes from this ign-physics PR), we might want to put them in one place and offer a URL to get a collection of these files <br />\n     Similar application in ROS to maintain multiple packages, but not exactly the same: <a href=\"https://raw.githubusercontent.com/ros2/ros2/release-latest/ros2.repos\" rel=\"nofollow\" class=\"ap-connect-link\">https://raw.githubusercontent.com/ros2/ros2/release-latest/ros2.repos</a><br />\n     We can similarly add some script to download these .cmake from a common place, to the gazebo repo's cmake directory    </p>\n</li>\n<li>\n<p>Regarding the <code>CompositeData</code> <code>SpecifiyData</code>, <code>RequiredData</code>, how much would you think to be exposed to developers or potential contributors? When I first read the API, I personally feel  <br />\n    it is not that straightforward to contribute and use. But it makes more sense after reading the test for some example usages. So I am kind of wondering if we can wrap one more layer on top  <br />\n    to facilitate the usage and understanding. Or provide concise examples.     </p>\n</li>\n<li>\n<p>As for the <code>GetOrCreate</code> API,  if I have <code>data.Get&lt;JointProperty&gt;(2)</code>  <br />\n       (1) if the JointProperty data type is NOT available, this means constructing a <code>JointProperty</code> with the argument of 2  <br />\n       (2) if the JointProperty data type is available, this means get the JointProperty of index at 2? (Or my understanding is only <code>query</code> API will get data)    </p>\n</li>\n<li>\n<p>more explanation on <code>silent query</code> would be appreciated, maybe 1-2 sentence descriptive example usage in the physics simulation where we require query to have state    </p>\n</li>\n</ol>\n<p>(side note: No need to address these comments in rush, we can talk)   </p>", "type": "rendered"}, "created_on": "2017-08-30T04:08:43.532692+00:00", "user": {"display_name": "Ying Lu", "uuid": "{11ec131e-4af6-4228-beaf-167b1c8d1c2c}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B11ec131e-4af6-4228-beaf-167b1c8d1c2c%7D"}, "html": {"href": "https://bitbucket.org/%7B11ec131e-4af6-4228-beaf-167b1c8d1c2c%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:659bfe31-d941-44f5-aa6d-00058b070ea8/c88d5925-8a09-40c7-8684-c02aeafe0f59/128"}}, "nickname": "rosebudflyaway", "type": "user", "account_id": "557058:659bfe31-d941-44f5-aa6d-00058b070ea8"}, "updated_on": "2017-08-30T04:16:56.753182+00:00", "type": "pullrequest_comment", "id": 43848150}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "### Edit: This has been broken down into pull request #3 (CMake), pull request #4 (CompositeData), pull request #5 (SpecifyData), and this one (template metaprogramming). The other PRs should be reviewed, in order, before this one, but the overview given in the description below might still be a useful primer.\r\n\r\nThis pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "4bec977fb556", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4bec977fb556.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4bec977fb556"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "e2b3251839ca", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/e2b3251839ca.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/e2b3251839ca"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-29T20:41:50.905490+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "4bec977fb556", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4bec977fb556.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4bec977fb556"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "e2b3251839ca", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/e2b3251839ca.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/e2b3251839ca"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-29T20:37:13.182317+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43832256.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43832256"}}, "parent": {"id": 43831940, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43831940.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43831940"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "I've now retargeted this PR to build on pull request #5. If anyone still wants one large monolithic version of the PR, let me know, but I think we should avoid redundancy so that we don't have multiple simultaneous conversations about a feature or implementation happening.", "markup": "markdown", "html": "<p>I've now retargeted this PR to build on <a href=\"#!/ignitionrobotics/ign-physics/pull-requests/5/part-2-compositedata-specifydata\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #5</a>. If anyone still wants one large monolithic version of the PR, let me know, but I think we should avoid redundancy so that we don't have multiple simultaneous conversations about a feature or implementation happening.</p>", "type": "rendered"}, "created_on": "2017-08-29T20:36:04.117223+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-08-29T20:36:04.121809+00:00", "type": "pullrequest_comment", "id": 43832256}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "4bec977fb556", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4bec977fb556.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4bec977fb556"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "669d6658d4e2", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/669d6658d4e2.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/669d6658d4e2"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-29T20:31:48.976134+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "4bec977fb556", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4bec977fb556.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4bec977fb556"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "669d6658d4e2", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/669d6658d4e2.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/669d6658d4e2"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-29T20:31:48.908241+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43831940.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43831940"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "I've spun off pull request #4 and pull request #5 to break down this larger PR.", "markup": "markdown", "html": "<p>I've spun off <a href=\"#!/ignitionrobotics/ign-physics/pull-requests/4/part-1-compositedata-implementation-and\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #4</a> and <a href=\"#!/ignitionrobotics/ign-physics/pull-requests/5/part-2-compositedata-specifydata\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #5</a> to break down this larger PR.</p>", "type": "rendered"}, "created_on": "2017-08-29T20:31:11.349055+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-08-29T20:31:11.352438+00:00", "type": "pullrequest_comment", "id": 43831940}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "4493a3ce62f1", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4493a3ce62f1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4493a3ce62f1"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "669d6658d4e2", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/669d6658d4e2.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/669d6658d4e2"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-29T20:10:55.327442+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43827817.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43827817"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "The CMake parts of this PR have been moved over to pull request #3 to make the diff a little more manageable. If this is still too much, I can see about breaking the PR down further.", "markup": "markdown", "html": "<p>The CMake parts of this PR have been moved over to <a href=\"#!/ignitionrobotics/ign-physics/pull-requests/3/changes-to-the-cmake-setup\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #3</a> to make the diff a little more manageable. If this is still too much, I can see about breaking the PR down further.</p>", "type": "rendered"}, "created_on": "2017-08-29T19:29:57.590975+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-08-29T19:29:57.593448+00:00", "type": "pullrequest_comment", "id": 43827817}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43827432.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43827432"}}, "parent": {"id": 43742646, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43742646.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43742646"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "I removed `ignition-common-config.cmake.in` here b1cba69, but I'm leaving `ignition-physics-config.cmake.in` as it is for now, because the CMakeLists.txt script which I brought over from `ign-common` expects the file to use the project's name. If we do (hopefully) end up unifying the build system macros, I don't think it's clear which format they will expect, so I'll leave it with the more specific name for now.", "markup": "markdown", "html": "<p>I removed <code>ignition-common-config.cmake.in</code> here <a href=\"#!/ignitionrobotics/ign-physics/commits/b1cba69\" rel=\"nofollow\" class=\"ap-connect-link\">b1cba69</a>, but I'm leaving <code>ignition-physics-config.cmake.in</code> as it is for now, because the CMakeLists.txt script which I brought over from <code>ign-common</code> expects the file to use the project's name. If we do (hopefully) end up unifying the build system macros, I don't think it's clear which format they will expect, so I'll leave it with the more specific name for now.</p>", "type": "rendered"}, "created_on": "2017-08-29T19:24:34.890678+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2017-08-29T19:24:34.893600+00:00", "type": "pullrequest_comment", "id": 43827432}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "4493a3ce62f1", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4493a3ce62f1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4493a3ce62f1"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b1cba6974e5c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/b1cba6974e5c.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/b1cba6974e5c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-29T19:17:10.774238+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "4493a3ce62f1", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4493a3ce62f1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4493a3ce62f1"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "536acc4f2fab", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/536acc4f2fab.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/536acc4f2fab"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-29T19:14:19.303413+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "4493a3ce62f1", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/4493a3ce62f1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/4493a3ce62f1"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "536acc4f2fab", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/536acc4f2fab.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/536acc4f2fab"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-29T19:14:19.231471+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "1ff1098d60e1", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1ff1098d60e1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1ff1098d60e1"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "536acc4f2fab", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/536acc4f2fab.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/536acc4f2fab"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-29T19:02:40.660964+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43743424.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43743424"}}, "parent": {"id": 43743286, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43743286.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43743286"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "If we took that approach, we'd see unmanageable degrees of merge conflicts. I really like the idea of having a single package of cmake macros that all the projects utilize.", "markup": "markdown", "html": "<p>If we took that approach, we'd see unmanageable degrees of merge conflicts. I really like the idea of having a single package of cmake macros that all the projects utilize.</p>", "type": "rendered"}, "created_on": "2017-08-29T01:09:56.453277+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2017-08-29T01:09:56.455880+00:00", "type": "pullrequest_comment", "id": 43743424}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43743286.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43743286"}}, "parent": {"id": 43743117, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43743117.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43743117"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "I've seen it generic in some of the other projects; so maybe we should target pull requests like this to `ign-seed` and then merge them down to the other ignition projects?", "markup": "markdown", "html": "<p>I've seen it generic in some of the other projects; so maybe we should target pull requests like this to <code>ign-seed</code> and then merge them down to the other ignition projects?</p>", "type": "rendered"}, "created_on": "2017-08-29T01:04:16.767806+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2017-08-29T01:04:16.770208+00:00", "type": "pullrequest_comment", "id": 43743286}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43743117.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43743117"}}, "parent": {"id": 43742607, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43742607.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43742607"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "I agree. I made the change to match `ignition-common`, but I think it would be fine to keep its name generic.", "markup": "markdown", "html": "<p>I agree. I made the change to match <code>ignition-common</code>, but I think it would be fine to keep its name generic.</p>", "type": "rendered"}, "created_on": "2017-08-29T00:58:20.361031+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2017-08-29T00:58:20.363219+00:00", "type": "pullrequest_comment", "id": 43743117}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43743107.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43743107"}}, "parent": {"id": 43743076, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43743076.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43743076"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "thanks", "markup": "markdown", "html": "<p>thanks</p>", "type": "rendered"}, "created_on": "2017-08-29T00:57:58.021820+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2017-08-29T00:57:58.025094+00:00", "type": "pullrequest_comment", "id": 43743107}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43743081.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43743081"}}, "parent": {"id": 43742646, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43742646.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43742646"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Good catch; this was a sloppy copy/paste.", "markup": "markdown", "html": "<p>Good catch; this was a sloppy copy/paste.</p>", "type": "rendered"}, "created_on": "2017-08-29T00:57:24.070852+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2017-08-29T00:57:24.073367+00:00", "type": "pullrequest_comment", "id": 43743081}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43743076.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43743076"}}, "parent": {"id": 43742695, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43742695.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43742695"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "I can (and definitely should) split out most of the CMake-related changes. I could possibly break up some of the source code, although much of it is deeply interrelated.", "markup": "markdown", "html": "<p>I can (and definitely should) split out most of the CMake-related changes. I could possibly break up some of the source code, although much of it is deeply interrelated.</p>", "type": "rendered"}, "created_on": "2017-08-29T00:57:03.449234+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-08-29T00:57:03.452814+00:00", "type": "pullrequest_comment", "id": 43743076}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43743033.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43743033"}}, "parent": {"id": 43742525, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43742525.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43742525"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Any additional operations being performed in there would skew the results of the performance test. I think we can just remove the assignment operation. I put it in there because sometimes compilers will erase lines if they can prove that the line won't have any \"visible effect\", but I don't believe the compiler will be allowed to do that in this case anyway.", "markup": "markdown", "html": "<p>Any additional operations being performed in there would skew the results of the performance test. I think we can just remove the assignment operation. I put it in there because sometimes compilers will erase lines if they can prove that the line won't have any \"visible effect\", but I don't believe the compiler will be allowed to do that in this case anyway.</p>", "type": "rendered"}, "created_on": "2017-08-29T00:55:29.481042+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-08-29T00:55:29.483785+00:00", "type": "pullrequest_comment", "id": 43743033}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43742695.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43742695"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "This is a gigantic pull request. How hard would it be to split it up into smaller pieces?", "markup": "markdown", "html": "<p>This is a gigantic pull request. How hard would it be to split it up into smaller pieces?</p>", "type": "rendered"}, "created_on": "2017-08-29T00:41:07.084605+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2017-08-29T00:41:07.088117+00:00", "type": "pullrequest_comment", "id": 43742695}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43742646.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43742646"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "also rename this to `ignition-config.cmake.in`? at a minimum it shouldn't be `ignition-common-config.cmake.in`", "markup": "markdown", "html": "<p>also rename this to <code>ignition-config.cmake.in</code>? at a minimum it shouldn't be <code>ignition-common-config.cmake.in</code></p>", "type": "rendered"}, "created_on": "2017-08-29T00:39:36.627823+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2017-08-29T00:39:36.630134+00:00", "type": "pullrequest_comment", "id": 43742646}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43742607.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43742607"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "why rename this file to `ignition-physics.in`? it's easier to meld the different ignition projects if they have the same file names, and this file is pretty generic given all the parameterization that it has", "markup": "markdown", "html": "<p>why rename this file to <code>ignition-physics.in</code>? it's easier to meld the different ignition projects if they have the same file names, and this file is pretty generic given all the parameterization that it has</p>", "type": "rendered"}, "created_on": "2017-08-29T00:38:18.581645+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2017-08-29T00:38:18.585387+00:00", "type": "pullrequest_comment", "id": 43742607}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43742525.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43742525"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "just noticed a compiler warning about an unused variable in the performance test:\n\n~~~\n/home/scpeters/ws_old/ignition/src/ign-physics/test/performance/ExpectData.cc:52:17: warning: unused variable \u2018s\u2019 [-Wunused-variable]\n     StringData &s = data.template Get<StringData>();\n                 ^\n~~~\n\nmaybe we could add a small expectation that the string data isn't empty?", "markup": "markdown", "html": "<p>just noticed a compiler warning about an unused variable in the performance test:</p>\n<div class=\"codehilite\"><pre><span></span>/home/scpeters/ws_old/ignition/src/ign-physics/test/performance/ExpectData.cc:52:17: warning: unused variable \u2018s\u2019 [-Wunused-variable]\n     StringData &amp;s = data.template Get&lt;StringData&gt;();\n                 ^\n</pre></div>\n\n\n<p>maybe we could add a small expectation that the string data isn't empty?</p>", "type": "rendered"}, "created_on": "2017-08-29T00:35:41.404496+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2017-08-29T00:35:41.406961+00:00", "type": "pullrequest_comment", "id": 43742525}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "1ff1098d60e1", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1ff1098d60e1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1ff1098d60e1"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "e802dd5ff188", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/e802dd5ff188.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/e802dd5ff188"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-29T00:08:45.174443+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "1ff1098d60e1", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1ff1098d60e1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1ff1098d60e1"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "d247881974b7", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/d247881974b7.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/d247881974b7"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-28T23:49:43.153856+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "1ff1098d60e1", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1ff1098d60e1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1ff1098d60e1"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "d4a22cd62b94", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/d4a22cd62b94.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/d4a22cd62b94"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-28T19:42:17.580552+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the [Rule of Zero, Rule of Three, or Rule of Five](http://en.cppreference.com/w/cpp/language/rule_of_three) (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "1ff1098d60e1", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1ff1098d60e1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1ff1098d60e1"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "5ab9af8902ef", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/5ab9af8902ef.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/5ab9af8902ef"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-24T23:33:20.062630+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the Rule of Zero, Rule of Three, or Rule of Five (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "1ff1098d60e1", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1ff1098d60e1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1ff1098d60e1"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "5ab9af8902ef", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/5ab9af8902ef.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/5ab9af8902ef"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-24T23:23:08.507419+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}, {"update": {"description": "This pull request presents the CompositeData prototype which I described during our Tuesday (8/22) meeting. I'm creating this PR to present the class and concept for review. I don't expect the code itself to be merged. I actually think the work I've done on this so far might really belong in `ignition-common`, because it's not really specific to physics.\r\n\r\n## CompositeData\r\n* CompositeData is an object type that can compose other arbitrary data types, as long as they meet two requirements:\r\n    1. It follows the Rule of Zero, Rule of Three, or Rule of Five (preferably zero or five)\r\n    2. It contains the macro `IGN_PHYSICS_DATA_LABEL(some::unique::name)`\r\n* Requirement (2) is unfortunate, but it seems necessary in order to guarantee compatibility across shared library boundaries. If a user wants to add data that matches requirement (1) but not (2), they can always define a dummy struct to contain their data, and put the macro into the dummy struct. They could even create a \"labeled\" version of their data which simply inherits the data they want and adds the macro to its class definition.\r\n* CompositeData has a pretty [thorough API](#!/ignitionrobotics/ign-physics/src/ab61cc8e5f59daaca382d908da422d154f07f6ca/include/ignition/physics/CompositeData.hh?at=experimental%2Finput&fileviewer=file-view-default#CompositeData.hh-56)\r\n    * `Get<T>()` returns a reference to `T`, which means if the data type did not exist in the `CompositeData`, it will be created using the default constructor. If a default constructor is not available, then the object must be retrieved using `Query<T>()` (described below). The basic `CompositeData` class does not have a const-qualified version of `Get<T>()`, but the `RequireData<T>` extension (described below) does provide const-qualified `Get<T>()` using a bunch of template metaprogramming wizardry.\r\n    * `Create<T>(args)` will create a `T` using `args`. If a `T` already existed, it will be overwritten.\r\n    * `GetOrCreate<T>(args)` will do the same as `Get<T>()` unless the object didn't exist, in which case it will do the same as `Create<T>(args)`. **We can absolutely get rid of this and change `Get<T>()` to accept `args` and exhibit this exact same behavior**. The reason I chose to write a `GetOrCreate<T>()` separate from `Get<T>()` is because:\r\n        * I suspect `Get<T>()`, in the way I designed it, is going to be the most desired use case of handling data within the `CompositeData` object.\r\n        * I'm worried that `Get<T>(args)` will make people think that they're looking up a `T` that matches `args` (rather than creating a `T` using `args` if the `T` was unavailable). For example, I don't want people to think `data.Get<JointProperty>(2)` is going to get the `JointProperty` of joint index `2` when really it would be constructing a `JointProperty` with the argument of `2`.\r\n    * `Remove<T>()` will remove the `T` object if it exists and it is not marked as required (explained below).\r\n    * `Query<T>()` will return a pointer to `T` which will be `nullptr` if `T` is not available. Note that you can choose to perform a \"silent\" query (query tracking will be explained later). A const-qualified version `Query<T>() const` is always available, regardless of requirements.\r\n    * `Has<T>()` tests for existence. This can also be called silently.\r\n    * `StatusOf<T>()` provides a struct that describes the metadata of `T`. This also has a silent mode.\r\n    * `Unquery<T>()` only affects some metadata and has no impact on the actual data.\r\n    * `MakeRequired<T>()` will mark `T` as required so that it can not be deleted until the end of the `CompositeData` object's lifespan. Explained more later.\r\n    * `Copy(~)` can copy data between `CompositeData` objects, and there are some options to change the behavior of `Copy(~)` based on metadata. Note that `Copy(~)` is not allowed to delete data that is marked as required.\r\n* Certain metadata is tracked by the CompositeData object, such as query flags. The query flags will keep track of which data you have explicitly handled by its type (as opposed to implicitly handled through a `Copy` operation). If you have done all the work you intend to do on a `CompositeData` object but some data fields remain unqueried, it may be an indication that there are data types you are not handling, either on purpose or by accident. This query tracking can be used for debugging purposes, or to warn users about potential incompatibilities.\r\n* Requirements are also tracked by the `CompositeData`. Data types can be marked as required by `MakeRequired<T>()`. After being marked as required, the data cannot be deleted until the end of the object's lifecycle. This allows users and developers to enforce that their data dependencies are met. Requirements can be added at run time, but they cannot be removed during run time. The class `RequireData` (described below) can statically express and enforce requirements.\r\n\r\n## ExpectData<Data1, ... , DataN>\r\n* `ExpectData` is an extension of `CompositeData` which has all the same functionality, but it provides extremely low-cost versions of the `CompositeData` API for any Data types that are passed to it as template arguments at compile time. Other than that, it's identical.\r\n* I created a [performance test](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/test/performance/ExpectData.cc?at=experimental%2Finput&fileviewer=file-view-default) which demonstrates that the `ExpectData` class improves access speed by roughly 2 **orders of magnitude** over the map lookup (~1ns per access rather than ~100ns per access).\r\n* Types that get listed by `ExpectData` are still optional; this class has no impact on requirements.\r\n* It's a variadic template, so any number of Data types can be given to it.\r\n\r\n## RequireData<Data1, ..., DataN>\r\n* `RequireData` is an extension of `ExpectData` which additionally marks its Data types as required, both at compile time and at run time.\r\n* As mentioned earlier, data types marked as required must exist and cannot be deleted until the `CompositeData` leaves scope.\r\n* Because `RequireData<T>` enforces the existence of a `T` type at compile time, it also provides a const-qualified `Get<T>() const`.\r\n\r\n## SpecifyData<Spec1, ... , SpecN>\r\n* `SpecifyData` is an extension of `CompositeData` which allows data specifications (e.g. `ExpectData` and `RequireData` or other `SpecifyData` mixtures) to be mixed and merged at compile time. Note that `RequireData` always takes precedence over `ExpectData`, so any `Data` that is listed as both `Expected` and `Required` will ultimately be `Required`.\r\n* This allows us to build up complex, comprehensive data specifications out of smaller, simpler data specifications. For example, we can decompose the data types that are required/expected for a physics engine into the data required/expected for (1) forward kinematics, (2) forward dynamics, (3) inverse kinematics, (4) inverse dynamics, (5) collision detection, (6) collision handling, (7) feedforward control, and (8) feedback control. Then, we can allow users to specify which among those data types they want their plugin to provide, and then we can use those specifications to determine which roles within the physics engine their plugin is capable of performing.\r\n\r\n## Template metaprogramming and static analysis\r\n* Because Data expectations and requirements can be encoded at compile time, we can use the data specifications to perform template metaprogramming and static analysis.\r\n* Examples of this can be found in [CanReadData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanReadData.hh?at=experimental%2Finput&fileviewer=file-view-default) and [CanWriteData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/CanWriteData.hh?at=experimental%2Finput&fileviewer=file-view-default). These classes use CRTP to guarantee that the class which inherits them provides a `Read(T)` or `Write(T)` function for each of the expected or required (depending on which you select) data types in the specification that they are given.\r\n* These classes are powered by [OperateOnSpecifiedData](#!/ignitionrobotics/ign-physics/src/5ab9af8902ef3b04b8ac28f777a43b3809b9b1f3/include/ignition/physics/OperateOnSpecifiedData.hh?at=experimental%2Finput&fileviewer=file-view-default) which is a very generalized interface for traversing the specification tree and applying an operation on each instance of the types in the specification that match some condition (currently, we provide the conditions for Expected and Required).\r\n* If a class does not provide a function which can perform the requested operation for each of the specified data types, then the compiler will throw an error and indicate which function is missing for which data types, giving us some nice compile time guarantees about the class's capabilities.\r\n\r\nAltogether, what we achieve here is an ideal balance of (1) complete generality which allows the framework to be highly adaptable and modular, and (2) the ability to strictly enforce conditions and requirements using the native C++ type system.", "title": "CompositeData prototype [WIP]", "destination": {"commit": {"hash": "1ff1098d60e1", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/1ff1098d60e1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/1ff1098d60e1"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "5ab9af8902ef", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/commit/5ab9af8902ef.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/commits/5ab9af8902ef"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics"}, "avatar": {"href": "data/bytebucket.org/ravatar/{63a01c4f-5625-443b-96f0-73c4005ccada}ts=c_plus_plus"}}, "type": "repository", "name": "ign-physics", "full_name": "ignitionrobotics/ign-physics", "uuid": "{63a01c4f-5625-443b-96f0-73c4005ccada}"}, "branch": {"name": "experimental/input"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2017-08-24T23:23:08.444383+00:00"}, "pull_request": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}}]}