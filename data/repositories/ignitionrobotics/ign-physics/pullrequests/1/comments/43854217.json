{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43854217.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43854217"}}, "parent": {"id": 43848150, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43848150.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43848150"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "Thanks for the feedback!\n\n> Instead of using RequireData and ExpectData, can we get started with something simple: like the function overloading in C++, \n\n~~I'm not really clear on what role you would like function overloading to play with respect to CompositeData or how `RequireData` and `ExpectData` can be replaced using function overloading. Just to clarify our semantics, \"function overloading\" is defining multiple functions with the same name but distinguishing them by their signatures (i.e. they take different sets of arguments or have different cv-qualifiers). If you instead mean using virtual functions and overriding them, then I'm still not sure what role that would play, since all the functions provided by `RequireData` and `ExpectData` are templated functions, and templated functions cannot be virtual; they can only be shadowed (which is what we're doing). We also can't avoid using templated functions if we want good performance and/or strong type safety. If you have an alternative implementation in mind, I'd be happy to discuss it (even if it's not fleshed out yet).~~ Edit: See my next comment (which is a reply to this comment) for my revised response to this bullet point.\n\nUltimately, I don't think the existence or use of `RequireData` or `ExpectData` will have a negative impact for users or developers, since they could just be used as higher performance versions of `CompositeData`. There's more that an expert user or developer may *choose* to do with `RequireData` and `ExpectData` (like template metaprogramming stuff), but there's no need for a user or developer to do those more advanced things.\n\n> Instead of holding SearchForStuff.cmake, FindFreeImage.cmake, FindSSE.cmake, etc, in the repositories of...\n\nI super duper absolutely agree with this, and it's something that I've brought up several times now. I think the best proposal we've come up with so far has been to create a unified package of CMake macros that can be distributed and installed as a deb and make it a dependency of each code base's build system. That proposal is on the shelf right now, though, because I guess it's viewed as very low priority.\n\n> Regarding the CompositeData SpecifiyData, RequiredData, how much would you think to be exposed to developers or potential contributors?\n\nThat's a good question, and the truth is, I don't know for sure yet. It might depend on how we approach our abstractions and how we end up implementing the overall Gazebo pipeline.\n\nI can definitely understand how the API can be confusing, and that concern was raised by Peter Horak as well when he reviewed the design docs. I think this is the kind of thing that's so unusual that it probably won't make sense without seeing some clear examples (and the tests don't really qualify as clear examples since they're not really demonstrating a useful application of the API). I think with some examples, the purpose and usage of the class should become very clear and intuitive. It pretty much boils down to: `CompositeData` is a container for an arbitrary batch of data objects which you can retrieve, create, or delete. Some data can be marked as \"required\" in which case you can't delete it. Everything else in the `CompositeData` API just provides some extra utility for advanced users/developers and probably won't matter to most people.\n\nI don't imagine we can really wrap another layer on top without basically eliminating the purpose of the class altogether, but I'm definitely open to ideas if you have any.\n\n> As for the GetOrCreate API, if I have data.Get<JointProperty>(2) \n\nI probably did a poor job of explaining this above, but what I was trying to say was that `data.Get<JointProperty>(2)` is **not** an option in the current implementation. It wouldn't compile, because the `Get<T>()` function does not accept any arguments. I designed it to not accept any arguments specifically because I didn't want to create the kind of confusion you just described in 4.(1) and 4.(2). Every data type stored in a `CompositeData` must have one unique instance. If you want to store a vector of some type, then it must be wrapped, like:\n\n```\nstruct MyDataVector\n{\n  IGN_PHYSICS_DATA_LABEL(MyDataVector)\n  std::vector<MyData> vec;\n};\n```\n\nThen you can retrieve element `i` from your vector using `data.Get<MyDataVector>().vec[i];`. The reason for this design choice is that (1) some data types might need to be unique (i.e. only one instance of it should be allowed to exist within a `CompositeData`), in which case, our design should not make an assumption that all data types can have multiple copies, and (2) if any data types need to have multiple copies within one `CompositeData`, they can always wrap the multiple copies up into one unique type, as shown above.\n\nSo `Get<T>()` always retrieves the one unique instance of data type `T` within your `CompositeData` object (or it will create `T` with the default constructor of `T` if an instance of `T` is not already available in your `CompositeData` object). If you need a function that will create `T` with a specific set of arguments when `T` did not already exist, then you must use `GetOrCreate<T>(~)`, and you can pass the constructor of `T` any arguments that you would like.\n\n> more explanation on silent query would be appreciated, maybe 1-2 sentence descriptive example usage in the physics simulation where we require query to have state\n\nStrictly speaking, the query flags and the silent modes aren't ever really *necessary* to use since they don't effect the data inside of the `CompositeData`. They exist for advanced use if you want to do some introspection into whether you're handling (or even aware of) all the data inside of a `CompositeData` object that you've been given. That said, I'll be happy to put together some examples of how to use it to identify data types that your program is not handling.\n\n> (side note: No need to address these comments in rush, we can talk)\n\nI just saw this after I finished typing out all of the above, but even if I had seen it earlier, I don't think it would've affected my decision to reply ;D\n\nEdit: Corrected the definition of `MyDataVector`", "markup": "markdown", "html": "<p>Thanks for the feedback!</p>\n<blockquote>\n<p>Instead of using RequireData and ExpectData, can we get started with something simple: like the function overloading in C++, </p>\n</blockquote>\n<p><del>I'm not really clear on what role you would like function overloading to play with respect to CompositeData or how <code>RequireData</code> and <code>ExpectData</code> can be replaced using function overloading. Just to clarify our semantics, \"function overloading\" is defining multiple functions with the same name but distinguishing them by their signatures (i.e. they take different sets of arguments or have different cv-qualifiers). If you instead mean using virtual functions and overriding them, then I'm still not sure what role that would play, since all the functions provided by <code>RequireData</code> and <code>ExpectData</code> are templated functions, and templated functions cannot be virtual; they can only be shadowed (which is what we're doing). We also can't avoid using templated functions if we want good performance and/or strong type safety. If you have an alternative implementation in mind, I'd be happy to discuss it (even if it's not fleshed out yet).</del> Edit: See my next comment (which is a reply to this comment) for my revised response to this bullet point.</p>\n<p>Ultimately, I don't think the existence or use of <code>RequireData</code> or <code>ExpectData</code> will have a negative impact for users or developers, since they could just be used as higher performance versions of <code>CompositeData</code>. There's more that an expert user or developer may <em>choose</em> to do with <code>RequireData</code> and <code>ExpectData</code> (like template metaprogramming stuff), but there's no need for a user or developer to do those more advanced things.</p>\n<blockquote>\n<p>Instead of holding SearchForStuff.cmake, FindFreeImage.cmake, FindSSE.cmake, etc, in the repositories of...</p>\n</blockquote>\n<p>I super duper absolutely agree with this, and it's something that I've brought up several times now. I think the best proposal we've come up with so far has been to create a unified package of CMake macros that can be distributed and installed as a deb and make it a dependency of each code base's build system. That proposal is on the shelf right now, though, because I guess it's viewed as very low priority.</p>\n<blockquote>\n<p>Regarding the CompositeData SpecifiyData, RequiredData, how much would you think to be exposed to developers or potential contributors?</p>\n</blockquote>\n<p>That's a good question, and the truth is, I don't know for sure yet. It might depend on how we approach our abstractions and how we end up implementing the overall Gazebo pipeline.</p>\n<p>I can definitely understand how the API can be confusing, and that concern was raised by Peter Horak as well when he reviewed the design docs. I think this is the kind of thing that's so unusual that it probably won't make sense without seeing some clear examples (and the tests don't really qualify as clear examples since they're not really demonstrating a useful application of the API). I think with some examples, the purpose and usage of the class should become very clear and intuitive. It pretty much boils down to: <code>CompositeData</code> is a container for an arbitrary batch of data objects which you can retrieve, create, or delete. Some data can be marked as \"required\" in which case you can't delete it. Everything else in the <code>CompositeData</code> API just provides some extra utility for advanced users/developers and probably won't matter to most people.</p>\n<p>I don't imagine we can really wrap another layer on top without basically eliminating the purpose of the class altogether, but I'm definitely open to ideas if you have any.</p>\n<blockquote>\n<p>As for the GetOrCreate API, if I have data.Get&lt;JointProperty&gt;(2) </p>\n</blockquote>\n<p>I probably did a poor job of explaining this above, but what I was trying to say was that <code>data.Get&lt;JointProperty&gt;(2)</code> is <strong>not</strong> an option in the current implementation. It wouldn't compile, because the <code>Get&lt;T&gt;()</code> function does not accept any arguments. I designed it to not accept any arguments specifically because I didn't want to create the kind of confusion you just described in 4.(1) and 4.(2). Every data type stored in a <code>CompositeData</code> must have one unique instance. If you want to store a vector of some type, then it must be wrapped, like:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"nt\">struct</span> <span class=\"nt\">MyDataVector</span>\n<span class=\"p\">{</span>\n  <span class=\"err\">IGN_PHYSICS_DATA_LABEL(MyDataVector)</span>\n  <span class=\"n\">std</span><span class=\"p\">:</span><span class=\"o\">:</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">MyData</span><span class=\"o\">&gt;</span> <span class=\"n\">vec</span><span class=\"p\">;</span>\n<span class=\"p\">}</span><span class=\"o\">;</span>\n</pre></div>\n\n\n<p>Then you can retrieve element <code>i</code> from your vector using <code>data.Get&lt;MyDataVector&gt;().vec[i];</code>. The reason for this design choice is that (1) some data types might need to be unique (i.e. only one instance of it should be allowed to exist within a <code>CompositeData</code>), in which case, our design should not make an assumption that all data types can have multiple copies, and (2) if any data types need to have multiple copies within one <code>CompositeData</code>, they can always wrap the multiple copies up into one unique type, as shown above.</p>\n<p>So <code>Get&lt;T&gt;()</code> always retrieves the one unique instance of data type <code>T</code> within your <code>CompositeData</code> object (or it will create <code>T</code> with the default constructor of <code>T</code> if an instance of <code>T</code> is not already available in your <code>CompositeData</code> object). If you need a function that will create <code>T</code> with a specific set of arguments when <code>T</code> did not already exist, then you must use <code>GetOrCreate&lt;T&gt;(~)</code>, and you can pass the constructor of <code>T</code> any arguments that you would like.</p>\n<blockquote>\n<p>more explanation on silent query would be appreciated, maybe 1-2 sentence descriptive example usage in the physics simulation where we require query to have state</p>\n</blockquote>\n<p>Strictly speaking, the query flags and the silent modes aren't ever really <em>necessary</em> to use since they don't effect the data inside of the <code>CompositeData</code>. They exist for advanced use if you want to do some introspection into whether you're handling (or even aware of) all the data inside of a <code>CompositeData</code> object that you've been given. That said, I'll be happy to put together some examples of how to use it to identify data types that your program is not handling.</p>\n<blockquote>\n<p>(side note: No need to address these comments in rush, we can talk)</p>\n</blockquote>\n<p>I just saw this after I finished typing out all of the above, but even if I had seen it earlier, I don't think it would've affected my decision to reply ;D</p>\n<p>Edit: Corrected the definition of <code>MyDataVector</code></p>", "type": "rendered"}, "created_on": "2017-08-30T06:40:38.483977+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-08-30T07:31:44.265632+00:00", "type": "pullrequest_comment", "id": 43854217}