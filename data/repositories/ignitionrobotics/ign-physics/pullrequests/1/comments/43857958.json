{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43857958.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43857958"}}, "parent": {"id": 43854217, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1/comments/43854217.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1/_/diff#comment-43854217"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-physics/pullrequests/1.json"}, "html": {"href": "#!/ignitionrobotics/ign-physics/pull-requests/1"}}, "title": "Part 3: CompositeData prototype summary"}, "content": {"raw": "After some more thought, I realized what you meant by using function overloading.\n\nThe problem with that is we would eliminate the ability for plugins to provide their own data types and operate in terms of those types. To illustrate this, my DART example would not necessarily work if we did this, because the DART plugin wouldn't be able to embed a proper copy of its concept of a state into the `State` object that we retrieve from it.\n\nMoving forward, it's not hard to imagine scenarios where someone might want to have multiple plugins that operate in different parts of the Gazebo pipeline, but they want to be able to pass custom data between those plugins through the pipeline, which motivates us to support arbitrary types natively through the pipeline instead of forcing users to figure out workarounds. The basic idea is that we want plugins to naturally integrate into the framework instead of needing to kludge them in through improvised (and probably poorly constructed) means.\n\nEdit: typos", "markup": "markdown", "html": "<p>After some more thought, I realized what you meant by using function overloading.</p>\n<p>The problem with that is we would eliminate the ability for plugins to provide their own data types and operate in terms of those types. To illustrate this, my DART example would not necessarily work if we did this, because the DART plugin wouldn't be able to embed a proper copy of its concept of a state into the <code>State</code> object that we retrieve from it.</p>\n<p>Moving forward, it's not hard to imagine scenarios where someone might want to have multiple plugins that operate in different parts of the Gazebo pipeline, but they want to be able to pass custom data between those plugins through the pipeline, which motivates us to support arbitrary types natively through the pipeline instead of forcing users to figure out workarounds. The basic idea is that we want plugins to naturally integrate into the framework instead of needing to kludge them in through improvised (and probably poorly constructed) means.</p>\n<p>Edit: typos</p>", "type": "rendered"}, "created_on": "2017-08-30T07:30:08.360507+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-08-30T07:33:01.918465+00:00", "type": "pullrequest_comment", "id": 43857958}