{"rendered": {"reason": {"raw": "This is being replaced by pull request #251", "markup": "markdown", "html": "<p>This is being replaced by <a href=\"#!/ignitionrobotics/ign-transport/pull-requests/251/subscribe-and-publish-raw-serialized-data\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #251</a></p>", "type": "rendered"}, "description": {"raw": "This PR is a work-in-progress, but is mostly complete. I'm opening it to facilitate discussion on the concept and to check whether this is an avenue that we want to take.\r\n\r\nThe key features of this PR are the abilities to publish and subscribe to arbitrary raw message data, while only performing serialization or deserialization when it is absolutely necessary.\r\n\r\nThis probably sounds like it's merely a performance improvement, but it's actually far more important than that: This allows us to subscribe to *any* type of message, including messages whose protobuf descriptors are not available to us (e.g. custom user-defined messages). This feature is necessary for logging in order for us to record custom messages which were generated outside of `ign-msgs`. Protobuf will always fail to deserialize a message whose type was generated in a library that is not linked to the current application, so this PR allows us to skip the deserialization step and send the message data directly into the logger.\r\n\r\nThe key implementation detail in this PR is that I've introduced a new type of subscription handler: `RawSubscriptionHandler`. This new subscription handler is managed independently of the existing `ISubscriptionHandler`.\r\n\r\nTODO List:\r\n\r\n1. Create tests for the raw publisher and subscriber functions\r\n\r\n2. Create an unsubscribe function for raw subscriptions\r\n\r\nThis PR may result in some backlash (for reasons that I'll enumerate below), so I'm completely open to  discussing and reversing the things that I'm proposing in this PR. Here's a list of what I suspect may be controversial:\r\n\r\n1. There's a significant refactoring of `Node::Publisher::Publish(~)` and `NodeShared::RecvMsgUpdate()`. My goal in the refactoring was to keep the changes as DRY as possible. In particular, publishing a raw message to local subscribers is extremely similar to receiving a message from remote publishers and passing it along to your node's local subscribers. Therefore, most of the functionality of `NodeShared::RecvMsgUpdate()` has been refactored into `NodeShared::CheckHandlerInfo(~)` and `NodeShared::TriggerSubscriberCallbacks(~)`.\r\n\r\n2. Generally we want to discourage end-users from doing anything with raw messages, but we want the API for it to be publicly exposed for our own use, and perhaps for advanced users to take advantage of. Therefore, I've introduced an `Advanced` API design pattern: To publish a raw message, you call `publisher->UseAdvancedFeatures().RawPublish(...)`. To create a raw subscription, you would call `node->UseAdvancedFeatures().RawSubscribe(...)`. Since these features are hidden behind the `UseAdvancedFeatures()` functions, it's painfully obvious that these are advanced features which are only meant for advanced users. If we don't like this design pattern, I can easily move `RawPublish` and `RawSubscribe` into the normal API and get rid of the `Advanced` classes.\r\n\r\n3. In the definition of [RawSubscriptionHandler](#!/ignitionrobotics/ign-transport/src/af616bbfe39865c1ce4ab70556f6478389c68240/include/ignition/transport/SubscriptionHandler.hh?at=RawPublishSubscribe&fileviewer=file-view-default#SubscriptionHandler.hh-329) I'm introducing a pimpl design pattern which is a bit stylistically different than what we've been using so far. Instead of creating a `PrivateXXX` class, we create a `XXX::Implementation` class and name its instance `pimpl`. This pattern is a popular one among pimpl users because it allows us to avoid polluting namespaces with classes that can't be accessed by users. It creates a cleaner code model, which is really nice for users who use autocomplete. I don't know if our `PrivateXXX` and `dataPtr` pattern is considered finalized in our style guide or if we've just been using it to be consistent, but I wanted to throw this suggestion out there to see what people think. I can easily switch it over to `PrivateXXX` and `dataPtr` if we would rather remain consistent.", "markup": "markdown", "html": "<p>This PR is a work-in-progress, but is mostly complete. I'm opening it to facilitate discussion on the concept and to check whether this is an avenue that we want to take.</p>\n<p>The key features of this PR are the abilities to publish and subscribe to arbitrary raw message data, while only performing serialization or deserialization when it is absolutely necessary.</p>\n<p>This probably sounds like it's merely a performance improvement, but it's actually far more important than that: This allows us to subscribe to <em>any</em> type of message, including messages whose protobuf descriptors are not available to us (e.g. custom user-defined messages). This feature is necessary for logging in order for us to record custom messages which were generated outside of <code>ign-msgs</code>. Protobuf will always fail to deserialize a message whose type was generated in a library that is not linked to the current application, so this PR allows us to skip the deserialization step and send the message data directly into the logger.</p>\n<p>The key implementation detail in this PR is that I've introduced a new type of subscription handler: <code>RawSubscriptionHandler</code>. This new subscription handler is managed independently of the existing <code>ISubscriptionHandler</code>.</p>\n<p>TODO List:</p>\n<ol>\n<li>\n<p>Create tests for the raw publisher and subscriber functions</p>\n</li>\n<li>\n<p>Create an unsubscribe function for raw subscriptions</p>\n</li>\n</ol>\n<p>This PR may result in some backlash (for reasons that I'll enumerate below), so I'm completely open to  discussing and reversing the things that I'm proposing in this PR. Here's a list of what I suspect may be controversial:</p>\n<ol>\n<li>\n<p>There's a significant refactoring of <code>Node::Publisher::Publish(~)</code> and <code>NodeShared::RecvMsgUpdate()</code>. My goal in the refactoring was to keep the changes as DRY as possible. In particular, publishing a raw message to local subscribers is extremely similar to receiving a message from remote publishers and passing it along to your node's local subscribers. Therefore, most of the functionality of <code>NodeShared::RecvMsgUpdate()</code> has been refactored into <code>NodeShared::CheckHandlerInfo(~)</code> and <code>NodeShared::TriggerSubscriberCallbacks(~)</code>.</p>\n</li>\n<li>\n<p>Generally we want to discourage end-users from doing anything with raw messages, but we want the API for it to be publicly exposed for our own use, and perhaps for advanced users to take advantage of. Therefore, I've introduced an <code>Advanced</code> API design pattern: To publish a raw message, you call <code>publisher-&gt;UseAdvancedFeatures().RawPublish(...)</code>. To create a raw subscription, you would call <code>node-&gt;UseAdvancedFeatures().RawSubscribe(...)</code>. Since these features are hidden behind the <code>UseAdvancedFeatures()</code> functions, it's painfully obvious that these are advanced features which are only meant for advanced users. If we don't like this design pattern, I can easily move <code>RawPublish</code> and <code>RawSubscribe</code> into the normal API and get rid of the <code>Advanced</code> classes.</p>\n</li>\n<li>\n<p>In the definition of <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/src/af616bbfe39865c1ce4ab70556f6478389c68240/include/ignition/transport/SubscriptionHandler.hh?at=RawPublishSubscribe&amp;fileviewer=file-view-default#SubscriptionHandler.hh-329\" rel=\"nofollow\">RawSubscriptionHandler</a> I'm introducing a pimpl design pattern which is a bit stylistically different than what we've been using so far. Instead of creating a <code>PrivateXXX</code> class, we create a <code>XXX::Implementation</code> class and name its instance <code>pimpl</code>. This pattern is a popular one among pimpl users because it allows us to avoid polluting namespaces with classes that can't be accessed by users. It creates a cleaner code model, which is really nice for users who use autocomplete. I don't know if our <code>PrivateXXX</code> and <code>dataPtr</code> pattern is considered finalized in our style guide or if we've just been using it to be consistent, but I wanted to throw this suggestion out there to see what people think. I can easily switch it over to <code>PrivateXXX</code> and <code>dataPtr</code> if we would rather remain consistent.</p>\n</li>\n</ol>", "type": "rendered"}, "title": {"raw": "[WIP] Subscribe and publish raw (serialized) data", "markup": "markdown", "html": "<p>[WIP] Subscribe and publish raw (serialized) data</p>", "type": "rendered"}}, "type": "pullrequest", "description": "This PR is a work-in-progress, but is mostly complete. I'm opening it to facilitate discussion on the concept and to check whether this is an avenue that we want to take.\r\n\r\nThe key features of this PR are the abilities to publish and subscribe to arbitrary raw message data, while only performing serialization or deserialization when it is absolutely necessary.\r\n\r\nThis probably sounds like it's merely a performance improvement, but it's actually far more important than that: This allows us to subscribe to *any* type of message, including messages whose protobuf descriptors are not available to us (e.g. custom user-defined messages). This feature is necessary for logging in order for us to record custom messages which were generated outside of `ign-msgs`. Protobuf will always fail to deserialize a message whose type was generated in a library that is not linked to the current application, so this PR allows us to skip the deserialization step and send the message data directly into the logger.\r\n\r\nThe key implementation detail in this PR is that I've introduced a new type of subscription handler: `RawSubscriptionHandler`. This new subscription handler is managed independently of the existing `ISubscriptionHandler`.\r\n\r\nTODO List:\r\n\r\n1. Create tests for the raw publisher and subscriber functions\r\n\r\n2. Create an unsubscribe function for raw subscriptions\r\n\r\nThis PR may result in some backlash (for reasons that I'll enumerate below), so I'm completely open to  discussing and reversing the things that I'm proposing in this PR. Here's a list of what I suspect may be controversial:\r\n\r\n1. There's a significant refactoring of `Node::Publisher::Publish(~)` and `NodeShared::RecvMsgUpdate()`. My goal in the refactoring was to keep the changes as DRY as possible. In particular, publishing a raw message to local subscribers is extremely similar to receiving a message from remote publishers and passing it along to your node's local subscribers. Therefore, most of the functionality of `NodeShared::RecvMsgUpdate()` has been refactored into `NodeShared::CheckHandlerInfo(~)` and `NodeShared::TriggerSubscriberCallbacks(~)`.\r\n\r\n2. Generally we want to discourage end-users from doing anything with raw messages, but we want the API for it to be publicly exposed for our own use, and perhaps for advanced users to take advantage of. Therefore, I've introduced an `Advanced` API design pattern: To publish a raw message, you call `publisher->UseAdvancedFeatures().RawPublish(...)`. To create a raw subscription, you would call `node->UseAdvancedFeatures().RawSubscribe(...)`. Since these features are hidden behind the `UseAdvancedFeatures()` functions, it's painfully obvious that these are advanced features which are only meant for advanced users. If we don't like this design pattern, I can easily move `RawPublish` and `RawSubscribe` into the normal API and get rid of the `Advanced` classes.\r\n\r\n3. In the definition of [RawSubscriptionHandler](#!/ignitionrobotics/ign-transport/src/af616bbfe39865c1ce4ab70556f6478389c68240/include/ignition/transport/SubscriptionHandler.hh?at=RawPublishSubscribe&fileviewer=file-view-default#SubscriptionHandler.hh-329) I'm introducing a pimpl design pattern which is a bit stylistically different than what we've been using so far. Instead of creating a `PrivateXXX` class, we create a `XXX::Implementation` class and name its instance `pimpl`. This pattern is a popular one among pimpl users because it allows us to avoid polluting namespaces with classes that can't be accessed by users. It creates a cleaner code model, which is really nice for users who use autocomplete. I don't know if our `PrivateXXX` and `dataPtr` pattern is considered finalized in our style guide or if we've just been using it to be consistent, but I wanted to throw this suggestion out there to see what people think. I can easily switch it over to `PrivateXXX` and `dataPtr` if we would rather remain consistent.", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-transport/pullrequests/249/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-transport/diffstat/ignitionrobotics/ign-transport:b7611efd2931%0D43d2b37c8d97?from_pullrequest_id=249"}, "commits": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/249/commits.json"}, "self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/249.json"}, "comments": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/249/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-transport/pullrequests/249/merge"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/249"}, "activity": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/249/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-transport/diff/ignitionrobotics/ign-transport:b7611efd2931%0D43d2b37c8d97?from_pullrequest_id=249"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-transport/pullrequests/249/approve"}, "statuses": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/249/statuses_page=1.json"}}, "title": "[WIP] Subscribe and publish raw (serialized) data", "close_source_branch": false, "reviewers": [], "id": 249, "destination": {"commit": {"hash": "43d2b37c8d97", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/43d2b37c8d97.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/43d2b37c8d97"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "record_proof_of_concept"}}, "created_on": "2017-12-12T03:29:05.592441+00:00", "summary": {"raw": "This PR is a work-in-progress, but is mostly complete. I'm opening it to facilitate discussion on the concept and to check whether this is an avenue that we want to take.\r\n\r\nThe key features of this PR are the abilities to publish and subscribe to arbitrary raw message data, while only performing serialization or deserialization when it is absolutely necessary.\r\n\r\nThis probably sounds like it's merely a performance improvement, but it's actually far more important than that: This allows us to subscribe to *any* type of message, including messages whose protobuf descriptors are not available to us (e.g. custom user-defined messages). This feature is necessary for logging in order for us to record custom messages which were generated outside of `ign-msgs`. Protobuf will always fail to deserialize a message whose type was generated in a library that is not linked to the current application, so this PR allows us to skip the deserialization step and send the message data directly into the logger.\r\n\r\nThe key implementation detail in this PR is that I've introduced a new type of subscription handler: `RawSubscriptionHandler`. This new subscription handler is managed independently of the existing `ISubscriptionHandler`.\r\n\r\nTODO List:\r\n\r\n1. Create tests for the raw publisher and subscriber functions\r\n\r\n2. Create an unsubscribe function for raw subscriptions\r\n\r\nThis PR may result in some backlash (for reasons that I'll enumerate below), so I'm completely open to  discussing and reversing the things that I'm proposing in this PR. Here's a list of what I suspect may be controversial:\r\n\r\n1. There's a significant refactoring of `Node::Publisher::Publish(~)` and `NodeShared::RecvMsgUpdate()`. My goal in the refactoring was to keep the changes as DRY as possible. In particular, publishing a raw message to local subscribers is extremely similar to receiving a message from remote publishers and passing it along to your node's local subscribers. Therefore, most of the functionality of `NodeShared::RecvMsgUpdate()` has been refactored into `NodeShared::CheckHandlerInfo(~)` and `NodeShared::TriggerSubscriberCallbacks(~)`.\r\n\r\n2. Generally we want to discourage end-users from doing anything with raw messages, but we want the API for it to be publicly exposed for our own use, and perhaps for advanced users to take advantage of. Therefore, I've introduced an `Advanced` API design pattern: To publish a raw message, you call `publisher->UseAdvancedFeatures().RawPublish(...)`. To create a raw subscription, you would call `node->UseAdvancedFeatures().RawSubscribe(...)`. Since these features are hidden behind the `UseAdvancedFeatures()` functions, it's painfully obvious that these are advanced features which are only meant for advanced users. If we don't like this design pattern, I can easily move `RawPublish` and `RawSubscribe` into the normal API and get rid of the `Advanced` classes.\r\n\r\n3. In the definition of [RawSubscriptionHandler](#!/ignitionrobotics/ign-transport/src/af616bbfe39865c1ce4ab70556f6478389c68240/include/ignition/transport/SubscriptionHandler.hh?at=RawPublishSubscribe&fileviewer=file-view-default#SubscriptionHandler.hh-329) I'm introducing a pimpl design pattern which is a bit stylistically different than what we've been using so far. Instead of creating a `PrivateXXX` class, we create a `XXX::Implementation` class and name its instance `pimpl`. This pattern is a popular one among pimpl users because it allows us to avoid polluting namespaces with classes that can't be accessed by users. It creates a cleaner code model, which is really nice for users who use autocomplete. I don't know if our `PrivateXXX` and `dataPtr` pattern is considered finalized in our style guide or if we've just been using it to be consistent, but I wanted to throw this suggestion out there to see what people think. I can easily switch it over to `PrivateXXX` and `dataPtr` if we would rather remain consistent.", "markup": "markdown", "html": "<p>This PR is a work-in-progress, but is mostly complete. I'm opening it to facilitate discussion on the concept and to check whether this is an avenue that we want to take.</p>\n<p>The key features of this PR are the abilities to publish and subscribe to arbitrary raw message data, while only performing serialization or deserialization when it is absolutely necessary.</p>\n<p>This probably sounds like it's merely a performance improvement, but it's actually far more important than that: This allows us to subscribe to <em>any</em> type of message, including messages whose protobuf descriptors are not available to us (e.g. custom user-defined messages). This feature is necessary for logging in order for us to record custom messages which were generated outside of <code>ign-msgs</code>. Protobuf will always fail to deserialize a message whose type was generated in a library that is not linked to the current application, so this PR allows us to skip the deserialization step and send the message data directly into the logger.</p>\n<p>The key implementation detail in this PR is that I've introduced a new type of subscription handler: <code>RawSubscriptionHandler</code>. This new subscription handler is managed independently of the existing <code>ISubscriptionHandler</code>.</p>\n<p>TODO List:</p>\n<ol>\n<li>\n<p>Create tests for the raw publisher and subscriber functions</p>\n</li>\n<li>\n<p>Create an unsubscribe function for raw subscriptions</p>\n</li>\n</ol>\n<p>This PR may result in some backlash (for reasons that I'll enumerate below), so I'm completely open to  discussing and reversing the things that I'm proposing in this PR. Here's a list of what I suspect may be controversial:</p>\n<ol>\n<li>\n<p>There's a significant refactoring of <code>Node::Publisher::Publish(~)</code> and <code>NodeShared::RecvMsgUpdate()</code>. My goal in the refactoring was to keep the changes as DRY as possible. In particular, publishing a raw message to local subscribers is extremely similar to receiving a message from remote publishers and passing it along to your node's local subscribers. Therefore, most of the functionality of <code>NodeShared::RecvMsgUpdate()</code> has been refactored into <code>NodeShared::CheckHandlerInfo(~)</code> and <code>NodeShared::TriggerSubscriberCallbacks(~)</code>.</p>\n</li>\n<li>\n<p>Generally we want to discourage end-users from doing anything with raw messages, but we want the API for it to be publicly exposed for our own use, and perhaps for advanced users to take advantage of. Therefore, I've introduced an <code>Advanced</code> API design pattern: To publish a raw message, you call <code>publisher-&gt;UseAdvancedFeatures().RawPublish(...)</code>. To create a raw subscription, you would call <code>node-&gt;UseAdvancedFeatures().RawSubscribe(...)</code>. Since these features are hidden behind the <code>UseAdvancedFeatures()</code> functions, it's painfully obvious that these are advanced features which are only meant for advanced users. If we don't like this design pattern, I can easily move <code>RawPublish</code> and <code>RawSubscribe</code> into the normal API and get rid of the <code>Advanced</code> classes.</p>\n</li>\n<li>\n<p>In the definition of <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-transport/src/af616bbfe39865c1ce4ab70556f6478389c68240/include/ignition/transport/SubscriptionHandler.hh?at=RawPublishSubscribe&amp;fileviewer=file-view-default#SubscriptionHandler.hh-329\" rel=\"nofollow\">RawSubscriptionHandler</a> I'm introducing a pimpl design pattern which is a bit stylistically different than what we've been using so far. Instead of creating a <code>PrivateXXX</code> class, we create a <code>XXX::Implementation</code> class and name its instance <code>pimpl</code>. This pattern is a popular one among pimpl users because it allows us to avoid polluting namespaces with classes that can't be accessed by users. It creates a cleaner code model, which is really nice for users who use autocomplete. I don't know if our <code>PrivateXXX</code> and <code>dataPtr</code> pattern is considered finalized in our style guide or if we've just been using it to be consistent, but I wanted to throw this suggestion out there to see what people think. I can easily switch it over to <code>PrivateXXX</code> and <code>dataPtr</code> if we would rather remain consistent.</p>\n</li>\n</ol>", "type": "rendered"}, "source": {"commit": {"hash": "b7611efd2931", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/b7611efd2931.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/b7611efd2931"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "RawPublishSubscribe"}}, "comment_count": 54, "state": "DECLINED", "task_count": 0, "participants": [{"role": "PARTICIPANT", "participated_on": "2017-12-13T23:39:43.385070+00:00", "type": "participant", "approved": false, "user": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}}, {"role": "PARTICIPANT", "participated_on": "2017-12-13T22:50:22.934933+00:00", "type": "participant", "approved": false, "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}}, {"role": "PARTICIPANT", "participated_on": "2017-12-13T22:53:33.028887+00:00", "type": "participant", "approved": false, "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}}, {"role": "PARTICIPANT", "participated_on": "2017-12-14T02:33:25.631508+00:00", "type": "participant", "approved": false, "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}}], "reason": "This is being replaced by pull request #251", "updated_on": "2017-12-14T02:33:25.656682+00:00", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "merge_commit": null, "closed_by": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}}