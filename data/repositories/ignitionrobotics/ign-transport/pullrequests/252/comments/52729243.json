{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/252/comments/52729243.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/252/_/diff#comment-52729243"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 252, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/252.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/252"}}, "title": "ignition tools record/playback"}, "content": {"raw": "> How can record get notified of new topics? For example, record may be launched before the thing it is supposed to record starts recording. Record would only be subscribed to the ones it saw at launch.\n\nAs a stopgap measure, how would we feel about a special case where passing an empty topic string to `Node::Subscribe(~)` implies that the user wants to subscribe to all topics?\n\nA cleaner long-term solution might be to add something like a filter field to `SubscribeOptions` such as a `std::function<bool(const Advertisement&)>` where `Advertisement` would be meta-data provided by the advertiser (e.g. topic name, time stamp, uuid of the advertising node, maybe other things?). Each time a new topic is advertised, we could run the filter of each qualified subscriber. \"Qualified subscriber\" refers to any subscribers who either (1) subscribed to the advertised topic name, or (2) left the topic name blank while subscribing. If the filter `std::function<bool(const Advertisement&)>` returns true, then we add the subscription; if it returns false, then we ignore the advertisement. By default, `SubscribeOptions` would not filter anything.", "markup": "markdown", "html": "<blockquote>\n<p>How can record get notified of new topics? For example, record may be launched before the thing it is supposed to record starts recording. Record would only be subscribed to the ones it saw at launch.</p>\n</blockquote>\n<p>As a stopgap measure, how would we feel about a special case where passing an empty topic string to <code>Node::Subscribe(~)</code> implies that the user wants to subscribe to all topics?</p>\n<p>A cleaner long-term solution might be to add something like a filter field to <code>SubscribeOptions</code> such as a <code>std::function&lt;bool(const Advertisement&amp;)&gt;</code> where <code>Advertisement</code> would be meta-data provided by the advertiser (e.g. topic name, time stamp, uuid of the advertising node, maybe other things?). Each time a new topic is advertised, we could run the filter of each qualified subscriber. \"Qualified subscriber\" refers to any subscribers who either (1) subscribed to the advertised topic name, or (2) left the topic name blank while subscribing. If the filter <code>std::function&lt;bool(const Advertisement&amp;)&gt;</code> returns true, then we add the subscription; if it returns false, then we ignore the advertisement. By default, <code>SubscribeOptions</code> would not filter anything.</p>", "type": "rendered"}, "created_on": "2017-12-28T23:30:57.046679+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-12-28T23:33:49.880114+00:00", "type": "pullrequest_comment", "id": 52729243}