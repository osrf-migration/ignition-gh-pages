{"pagelen": 50, "values": [{"update": {"description": "This PR adds a `bench` example program that can be used to evaluate the latency and throughput of `ign-transport`.\r\n\r\nA deadlock was found in `Node.cc` when using intraprocess communication with a mutex. The modification to `Node.cc` changes intraprocess message delivery from blocking to non-blocking. The behavior now matches interprocess communication. A few tests relied on blocking intraprocess message delivery. Those tests have been modified to use condition variables.\r\n\r\nA slight change was made to `NodeShared` to reduce the length of time the mutex is held during message publication. I didn't notice any performance impact, but there might be change with large numbers of publishers and subscribers.\r\n\r\n# Dependencies\r\n\r\nThis PR relies on C++14, and will not be merged until pull request #128 is merged first.\r\n\r\n# Benchmarking \r\n\r\nThis process could use more automation, but the scope started to get out of hand. Here are the steps to follow:\r\n\r\n1. Compile and install as normal.\r\n2. Compile the `examples`\r\n3. Run the `bench` example. In one of the following configurations:\r\n\r\n    1. Example intraprocess latency:\r\n\r\n            ./bench -l\r\n\r\n    2. Example interprocess latency:\r\n\r\n            Terminal 1: ./bench -l -r\r\n\r\n            Terminal 2: ./bench -l -p\r\n\r\n    3. Example intraprocess throughput:\r\n\r\n            ./bench -t\r\n\r\n    4. Example interprocess throughput:\r\n\r\n            Terminal 1: ./bench -t -r\r\n\r\n            Terminal 2: ./bench -t -p\r\n\r\n4. The `bench` executable with the `-p` option will output data suitable for use with the `latency.gp` and `throughput.gp` gnuplot scripts. Note: you can use the `-o` option with `bench` to output to a file.\r\n\r\n5. Produce plots using\r\n\r\n    1. Latency\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" latency.gp\r\n\r\n    2. Throughput\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" throughput.gp\r\n\r\n## Results\r\n\r\nRaw data is stored in `examples/data`. We can use this (or some other location) to hold a history of benchmark data. All results are the average of 100 iterations. These tests include time required for message serialization and deserialization.\r\n\r\nI did not make a test out `bench` because results are highly dependent on hardware, background processes, and network activity.\r\n\r\nA few definitions follow.\r\n\r\n** Intraprocess**:  Publisher and subscriber in same process.\r\n\r\n** Interprocess**: Publisher and subscriber in separate processes on the same PC.\r\n\r\n** Wired**: Publisher and subscriber on separate PCs connected via a wired LAN.\r\n\r\n**Wireless**: Publisher and subscriber on separate Pcs where one computer was connected to wireless access point and the other hardwired to the LAN.\r\n\r\n** Latency**: Latency was measure by publishing a message on `topicA`, and then waiting for a response on `topicB`. The time between publication and reception of the response was divided in half to compute the one-way latency time.\r\n\r\n**Throughput**: Throughput was measure by rapidly publishing N messages. Once the N messages have been published, the publisher waits for N responses. The time from start of publication to reception of all N messages is used to compute throughput. \r\n\r\n### Latency\r\n\r\n** Intraprocess latency**\r\n\r\nI was not expecting this result. My theory as to why the plot is not more constant is a combination of context switches, other processes, etc.\r\n\r\n![latency-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/1473127294-latency-Intraprocess-all.png)\r\n\r\n![latency-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3217563991-latency-Intraprocess-small.png)\r\n\r\n![latency-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/83318001-latency-Intraprocess-large.png)\r\n\r\n**Interprocess latency**\r\n\r\n![latency-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2668403778-latency-Interprocess-all.png)\r\n\r\n![latency-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3207293959-latency-Interprocess-small.png)\r\n\r\n![latency-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/556609639-latency-Interprocess-large.png)\r\n**Wired latency**\r\n\r\n![latency-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1861775847-latency-Wired-all.png)\r\n\r\n![latency-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3238222459-latency-Wired-small.png)\r\n\r\n![latency-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/2639846742-latency-Wired-large.png)\r\n\r\n** Wireless latency**\r\n\r\nYou may notice that the latency appears better than over the wired network. I believe this is because I ran the wireless tests when no one else was using the network, and the wired test during an active portion of the day.\r\n\r\n![latency-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/177746882-latency-Wireless-all.png)\r\n\r\n![latency-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/4212627213-latency-Wireless-small.png)\r\n\r\n![latency-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/3866951968-latency-Wireless-large.png)\r\n\r\n### Throughput\r\n\r\n** Intraprocess throughput**\r\n\r\n![throughput-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2829676984-throughput-Intraprocess-all.png)\r\n\r\n![throughput-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3933927565-throughput-Intraprocess-small.png)\r\n\r\n![throughput-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/3718225819-throughput-Intraprocess-large.png)\r\n\r\n** Interprocess throughput**\r\n\r\n![throughput-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/3032255927-throughput-Interprocess-all.png)\r\n\r\n![throughput-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/1568831296-throughput-Interprocess-small.png)\r\n\r\n![throughput-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/4114343739-throughput-Interprocess-large.png)\r\n\r\n** Wired throughput**\r\n\r\n![throughput-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1229007404-throughput-Wired-all.png)\r\n\r\n![throughput-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3679643025-throughput-Wired-small.png)\r\n\r\n![throughput-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/3619655927-throughput-Wired-large.png)\r\n\r\n** Wireless throughput**\r\n\r\n![throughput-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/365561471-throughput-Wireless-all.png)\r\n\r\n![throughput-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/2412795863-throughput-Wireless-small.png)\r\n\r\n![throughput-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/1670547079-throughput-Wireless-large.png)\r\n\r\n## Comparison\r\n\r\nI had no idea whether these results were good or bad. [This paper](https://dl.acm.org/citation.cfm?id=2968502) on ROS1 and ROS2 performance can be used as a point of comparison.", "title": "Benchmark", "destination": {"commit": {"hash": "0baa0d16cec9", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/0baa0d16cec9.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/0baa0d16cec9"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "ign-transport4"}}, "reason": "", "source": {"commit": {"hash": "78b2fe7d1482", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/78b2fe7d1482.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/78b2fe7d1482"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "benchmark_nate"}}, "state": "OPEN", "author": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "date": "2017-10-05T19:38:53.400246+00:00"}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"update": {"description": "This PR adds a `bench` example program that can be used to evaluate the latency and throughput of `ign-transport`.\r\n\r\nA deadlock was found in `Node.cc` when using intraprocess communication with a mutex. The modification to `Node.cc` changes intraprocess message delivery from blocking to non-blocking. The behavior now matches interprocess communication. A few tests relied on blocking intraprocess message delivery. Those tests have been modified to use condition variables.\r\n\r\nA slight change was made to `NodeShared` to reduce the length of time the mutex is held during message publication. I didn't notice any performance impact, but there might be change with large numbers of publishers and subscribers.\r\n\r\n# Dependencies\r\n\r\nThis PR relies on C++14, and will not be merged until pull request #128 is merged first.\r\n\r\n# Benchmarking \r\n\r\nThis process could use more automation, but the scope started to get out of hand. Here are the steps to follow:\r\n\r\n1. Compile and install as normal.\r\n2. Compile the `examples`\r\n3. Run the `bench` example. In one of the following configurations:\r\n\r\n    1. Example intraprocess latency:\r\n\r\n            ./bench -l\r\n\r\n    2. Example interprocess latency:\r\n\r\n            Terminal 1: ./bench -l -r\r\n\r\n            Terminal 2: ./bench -l -p\r\n\r\n    3. Example intraprocess throughput:\r\n\r\n            ./bench -t\r\n\r\n    4. Example interprocess throughput:\r\n\r\n            Terminal 1: ./bench -t -r\r\n\r\n            Terminal 2: ./bench -t -p\r\n\r\n4. The `bench` executable with the `-p` option will output data suitable for use with the `latency.gp` and `throughput.gp` gnuplot scripts. Note: you can use the `-o` option with `bench` to output to a file.\r\n\r\n5. Produce plots using\r\n\r\n    1. Latency\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" latency.gp\r\n\r\n    2. Throughput\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" throughput.gp\r\n\r\n## Results\r\n\r\nRaw data is stored in `examples/data`. We can use this (or some other location) to hold a history of benchmark data. All results are the average of 100 iterations. These tests include time required for message serialization and deserialization.\r\n\r\nI did not make a test out `bench` because results are highly dependent on hardware, background processes, and network activity.\r\n\r\nA few definitions follow.\r\n\r\n** Intraprocess**:  Publisher and subscriber in same process.\r\n\r\n** Interprocess**: Publisher and subscriber in separate processes on the same PC.\r\n\r\n** Wired**: Publisher and subscriber on separate PCs connected via a wired LAN.\r\n\r\n**Wireless**: Publisher and subscriber on separate Pcs where one computer was connected to wireless access point and the other hardwired to the LAN.\r\n\r\n** Latency**: Latency was measure by publishing a message on `topicA`, and then waiting for a response on `topicB`. The time between publication and reception of the response was divided in half to compute the one-way latency time.\r\n\r\n**Throughput**: Throughput was measure by rapidly publishing N messages. Once the N messages have been published, the publisher waits for N responses. The time from start of publication to reception of all N messages is used to compute throughput. \r\n\r\n### Latency\r\n\r\n** Intraprocess latency**\r\n\r\nI was not expecting this result. My theory as to why the plot is not more constant is a combination of context switches, other processes, etc.\r\n\r\n![latency-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/1473127294-latency-Intraprocess-all.png)\r\n\r\n![latency-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3217563991-latency-Intraprocess-small.png)\r\n\r\n![latency-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/83318001-latency-Intraprocess-large.png)\r\n\r\n**Interprocess latency**\r\n\r\n![latency-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2668403778-latency-Interprocess-all.png)\r\n\r\n![latency-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3207293959-latency-Interprocess-small.png)\r\n\r\n![latency-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/556609639-latency-Interprocess-large.png)\r\n**Wired latency**\r\n\r\n![latency-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1861775847-latency-Wired-all.png)\r\n\r\n![latency-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3238222459-latency-Wired-small.png)\r\n\r\n![latency-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/2639846742-latency-Wired-large.png)\r\n\r\n** Wireless latency**\r\n\r\nYou may notice that the latency appears better than over the wired network. I believe this is because I ran the wireless tests when no one else was using the network, and the wired test during an active portion of the day.\r\n\r\n![latency-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/177746882-latency-Wireless-all.png)\r\n\r\n![latency-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/4212627213-latency-Wireless-small.png)\r\n\r\n![latency-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/3866951968-latency-Wireless-large.png)\r\n\r\n### Throughput\r\n\r\n** Intraprocess throughput**\r\n\r\n![throughput-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2829676984-throughput-Intraprocess-all.png)\r\n\r\n![throughput-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3933927565-throughput-Intraprocess-small.png)\r\n\r\n![throughput-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/3718225819-throughput-Intraprocess-large.png)\r\n\r\n** Interprocess throughput**\r\n\r\n![throughput-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/3032255927-throughput-Interprocess-all.png)\r\n\r\n![throughput-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/1568831296-throughput-Interprocess-small.png)\r\n\r\n![throughput-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/4114343739-throughput-Interprocess-large.png)\r\n\r\n** Wired throughput**\r\n\r\n![throughput-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1229007404-throughput-Wired-all.png)\r\n\r\n![throughput-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3679643025-throughput-Wired-small.png)\r\n\r\n![throughput-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/3619655927-throughput-Wired-large.png)\r\n\r\n** Wireless throughput**\r\n\r\n![throughput-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/365561471-throughput-Wireless-all.png)\r\n\r\n![throughput-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/2412795863-throughput-Wireless-small.png)\r\n\r\n![throughput-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/1670547079-throughput-Wireless-large.png)\r\n\r\n## Comparison\r\n\r\nI had no idea whether these results were good or bad. [This paper](https://dl.acm.org/citation.cfm?id=2968502) on ROS1 and ROS2 performance can be used as a point of comparison.", "title": "Benchmark", "destination": {"commit": {"hash": "0baa0d16cec9", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/0baa0d16cec9.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/0baa0d16cec9"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "ign-transport4"}}, "reason": "", "source": {"commit": {"hash": "eb1c5b5647b8", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/eb1c5b5647b8.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/eb1c5b5647b8"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "benchmark_nate"}}, "state": "OPEN", "author": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "date": "2017-10-05T19:37:16.381430+00:00"}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"update": {"description": "This PR adds a `bench` example program that can be used to evaluate the latency and throughput of `ign-transport`.\r\n\r\nA deadlock was found in `Node.cc` when using intraprocess communication with a mutex. The modification to `Node.cc` changes intraprocess message delivery from blocking to non-blocking. The behavior now matches interprocess communication. A few tests relied on blocking intraprocess message delivery. Those tests have been modified to use condition variables.\r\n\r\nA slight change was made to `NodeShared` to reduce the length of time the mutex is held during message publication. I didn't notice any performance impact, but there might be change with large numbers of publishers and subscribers.\r\n\r\n# Dependencies\r\n\r\nThis PR relies on C++14, and will not be merged until pull request #128 is merged first.\r\n\r\n# Benchmarking \r\n\r\nThis process could use more automation, but the scope started to get out of hand. Here are the steps to follow:\r\n\r\n1. Compile and install as normal.\r\n2. Compile the `examples`\r\n3. Run the `bench` example. In one of the following configurations:\r\n\r\n    1. Example intraprocess latency:\r\n\r\n            ./bench -l\r\n\r\n    2. Example interprocess latency:\r\n\r\n            Terminal 1: ./bench -l -r\r\n\r\n            Terminal 2: ./bench -l -p\r\n\r\n    3. Example intraprocess throughput:\r\n\r\n            ./bench -t\r\n\r\n    4. Example interprocess throughput:\r\n\r\n            Terminal 1: ./bench -t -r\r\n\r\n            Terminal 2: ./bench -t -p\r\n\r\n4. The `bench` executable with the `-p` option will output data suitable for use with the `latency.gp` and `throughput.gp` gnuplot scripts. Note: you can use the `-o` option with `bench` to output to a file.\r\n\r\n5. Produce plots using\r\n\r\n    1. Latency\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" latency.gp\r\n\r\n    2. Throughput\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" throughput.gp\r\n\r\n## Results\r\n\r\nRaw data is stored in `examples/data`. We can use this (or some other location) to hold a history of benchmark data. All results are the average of 100 iterations. These tests include time required for message serialization and deserialization.\r\n\r\nI did not make a test out `bench` because results are highly dependent on hardware, background processes, and network activity.\r\n\r\nA few definitions follow.\r\n\r\n** Intraprocess**:  Publisher and subscriber in same process.\r\n\r\n** Interprocess**: Publisher and subscriber in separate processes on the same PC.\r\n\r\n** Wired**: Publisher and subscriber on separate PCs connected via a wired LAN.\r\n\r\n**Wireless**: Publisher and subscriber on separate Pcs where one computer was connected to wireless access point and the other hardwired to the LAN.\r\n\r\n** Latency**: Latency was measure by publishing a message on `topicA`, and then waiting for a response on `topicB`. The time between publication and reception of the response was divided in half to compute the one-way latency time.\r\n\r\n**Throughput**: Throughput was measure by rapidly publishing N messages. Once the N messages have been published, the publisher waits for N responses. The time from start of publication to reception of all N messages is used to compute throughput. \r\n\r\n### Latency\r\n\r\n** Intraprocess latency**\r\n\r\nI was not expecting this result. My theory as to why the plot is not more constant is a combination of context switches, other processes, etc.\r\n\r\n![latency-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/1473127294-latency-Intraprocess-all.png)\r\n\r\n![latency-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3217563991-latency-Intraprocess-small.png)\r\n\r\n![latency-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/83318001-latency-Intraprocess-large.png)\r\n\r\n**Interprocess latency**\r\n\r\n![latency-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2668403778-latency-Interprocess-all.png)\r\n\r\n![latency-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3207293959-latency-Interprocess-small.png)\r\n\r\n![latency-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/556609639-latency-Interprocess-large.png)\r\n**Wired latency**\r\n\r\n![latency-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1861775847-latency-Wired-all.png)\r\n\r\n![latency-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3238222459-latency-Wired-small.png)\r\n\r\n![latency-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/2639846742-latency-Wired-large.png)\r\n\r\n** Wireless latency**\r\n\r\nYou may notice that the latency appears better than over the wired network. I believe this is because I ran the wireless tests when no one else was using the network, and the wired test during an active portion of the day.\r\n\r\n![latency-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/177746882-latency-Wireless-all.png)\r\n\r\n![latency-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/4212627213-latency-Wireless-small.png)\r\n\r\n![latency-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/3866951968-latency-Wireless-large.png)\r\n\r\n### Throughput\r\n\r\n** Intraprocess throughput**\r\n\r\n![throughput-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2829676984-throughput-Intraprocess-all.png)\r\n\r\n![throughput-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3933927565-throughput-Intraprocess-small.png)\r\n\r\n![throughput-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/3718225819-throughput-Intraprocess-large.png)\r\n\r\n** Interprocess throughput**\r\n\r\n![throughput-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/3032255927-throughput-Interprocess-all.png)\r\n\r\n![throughput-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/1568831296-throughput-Interprocess-small.png)\r\n\r\n![throughput-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/4114343739-throughput-Interprocess-large.png)\r\n\r\n** Wired throughput**\r\n\r\n![throughput-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1229007404-throughput-Wired-all.png)\r\n\r\n![throughput-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3679643025-throughput-Wired-small.png)\r\n\r\n![throughput-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/3619655927-throughput-Wired-large.png)\r\n\r\n** Wireless throughput**\r\n\r\n![throughput-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/365561471-throughput-Wireless-all.png)\r\n\r\n![throughput-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/2412795863-throughput-Wireless-small.png)\r\n\r\n![throughput-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/1670547079-throughput-Wireless-large.png)\r\n\r\n## Comparison\r\n\r\nI had no idea whether these results were good or bad. [This paper](https://dl.acm.org/citation.cfm?id=2968502) on ROS1 and ROS2 performance can be used as a point of comparison.", "title": "Benchmark", "destination": {"commit": {"hash": "0baa0d16cec9", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/0baa0d16cec9.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/0baa0d16cec9"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "ign-transport4"}}, "reason": "", "source": {"commit": {"hash": "c5c35b555494", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/c5c35b555494.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/c5c35b555494"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "benchmark_nate"}}, "state": "OPEN", "author": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "date": "2017-10-05T17:54:38.880152+00:00"}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"update": {"description": "This PR adds a `bench` example program that can be used to evaluate the latency and throughput of `ign-transport`.\r\n\r\nA deadlock was found in `Node.cc` when using intraprocess communication with a mutex. The modification to `Node.cc` changes intraprocess message delivery from blocking to non-blocking. The behavior now matches interprocess communication. A few tests relied on blocking intraprocess message delivery. Those tests have been modified to use condition variables.\r\n\r\nA slight change was made to `NodeShared` to reduce the length of time the mutex is held during message publication. I didn't notice any performance impact, but there might be change with large numbers of publishers and subscribers.\r\n\r\n# Dependencies\r\n\r\nThis PR relies on C++14, and will not be merged until pull request #128 is merged first.\r\n\r\n# Benchmarking \r\n\r\nThis process could use more automation, but the scope started to get out of hand. Here are the steps to follow:\r\n\r\n1. Compile and install as normal.\r\n2. Compile the `examples`\r\n3. Run the `bench` example. In one of the following configurations:\r\n\r\n    1. Example intraprocess latency:\r\n\r\n            ./bench -l\r\n\r\n    2. Example interprocess latency:\r\n\r\n            Terminal 1: ./bench -l -r\r\n\r\n            Terminal 2: ./bench -l -p\r\n\r\n    3. Example intraprocess throughput:\r\n\r\n            ./bench -t\r\n\r\n    4. Example interprocess throughput:\r\n\r\n            Terminal 1: ./bench -t -r\r\n\r\n            Terminal 2: ./bench -t -p\r\n\r\n4. The `bench` executable with the `-p` option will output data suitable for use with the `latency.gp` and `throughput.gp` gnuplot scripts. Note: you can use the `-o` option with `bench` to output to a file.\r\n\r\n5. Produce plots using\r\n\r\n    1. Latency\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" latency.gp\r\n\r\n    2. Throughput\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" throughput.gp\r\n\r\n## Results\r\n\r\nRaw data is stored in `examples/data`. We can use this (or some other location) to hold a history of benchmark data. All results are the average of 100 iterations. These tests include time required for message serialization and deserialization.\r\n\r\nI did not make a test out `bench` because results are highly dependent on hardware, background processes, and network activity.\r\n\r\nA few definitions follow.\r\n\r\n** Intraprocess**:  Publisher and subscriber in same process.\r\n\r\n** Interprocess**: Publisher and subscriber in separate processes on the same PC.\r\n\r\n** Wired**: Publisher and subscriber on separate PCs connected via a wired LAN.\r\n\r\n**Wireless**: Publisher and subscriber on separate Pcs where one computer was connected to wireless access point and the other hardwired to the LAN.\r\n\r\n** Latency**: Latency was measure by publishing a message on `topicA`, and then waiting for a response on `topicB`. The time between publication and reception of the response was divided in half to compute the one-way latency time.\r\n\r\n**Throughput**: Throughput was measure by rapidly publishing N messages. Once the N messages have been published, the publisher waits for N responses. The time from start of publication to reception of all N messages is used to compute throughput. \r\n\r\n### Latency\r\n\r\n** Intraprocess latency**\r\n\r\nI was not expecting this result. My theory as to why the plot is not more constant is a combination of context switches, other processes, etc.\r\n\r\n![latency-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/1473127294-latency-Intraprocess-all.png)\r\n\r\n![latency-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3217563991-latency-Intraprocess-small.png)\r\n\r\n![latency-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/83318001-latency-Intraprocess-large.png)\r\n\r\n**Interprocess latency**\r\n\r\n![latency-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2668403778-latency-Interprocess-all.png)\r\n\r\n![latency-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3207293959-latency-Interprocess-small.png)\r\n\r\n![latency-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/556609639-latency-Interprocess-large.png)\r\n**Wired latency**\r\n\r\n![latency-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1861775847-latency-Wired-all.png)\r\n\r\n![latency-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3238222459-latency-Wired-small.png)\r\n\r\n![latency-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/2639846742-latency-Wired-large.png)\r\n\r\n** Wireless latency**\r\n\r\nYou may notice that the latency appears better than over the wired network. I believe this is because I ran the wireless tests when no one else was using the network, and the wired test during an active portion of the day.\r\n\r\n![latency-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/177746882-latency-Wireless-all.png)\r\n\r\n![latency-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/4212627213-latency-Wireless-small.png)\r\n\r\n![latency-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/3866951968-latency-Wireless-large.png)\r\n\r\n### Throughput\r\n\r\n** Intraprocess throughput**\r\n\r\n![throughput-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2829676984-throughput-Intraprocess-all.png)\r\n\r\n![throughput-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3933927565-throughput-Intraprocess-small.png)\r\n\r\n![throughput-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/3718225819-throughput-Intraprocess-large.png)\r\n\r\n** Interprocess throughput**\r\n\r\n![throughput-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/3032255927-throughput-Interprocess-all.png)\r\n\r\n![throughput-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/1568831296-throughput-Interprocess-small.png)\r\n\r\n![throughput-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/4114343739-throughput-Interprocess-large.png)\r\n\r\n** Wired throughput**\r\n\r\n![throughput-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1229007404-throughput-Wired-all.png)\r\n\r\n![throughput-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3679643025-throughput-Wired-small.png)\r\n\r\n![throughput-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/3619655927-throughput-Wired-large.png)\r\n\r\n** Wireless throughput**\r\n\r\n![throughput-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/365561471-throughput-Wireless-all.png)\r\n\r\n![throughput-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/2412795863-throughput-Wireless-small.png)\r\n\r\n![throughput-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/1670547079-throughput-Wireless-large.png)\r\n\r\n## Comparison\r\n\r\nI had no idea whether these results were good or bad. [This paper](https://dl.acm.org/citation.cfm?id=2968502) on ROS1 and ROS2 performance can be used as a point of comparison.", "title": "Benchmark", "destination": {"commit": {"hash": "0baa0d16cec9", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/0baa0d16cec9.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/0baa0d16cec9"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "ign-transport4"}}, "reason": "", "source": {"commit": {"hash": "4dacf3845165", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/4dacf3845165.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/4dacf3845165"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "benchmark_nate"}}, "state": "OPEN", "author": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "date": "2017-10-05T17:27:36.024367+00:00"}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46426705.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46426705"}}, "parent": {"id": 46252660, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46252660.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46252660"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "Local workerpool has been added.", "markup": "markdown", "html": "<p>Local workerpool has been added.</p>", "type": "rendered"}, "created_on": "2017-10-04T17:27:11.690166+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2017-10-04T17:27:11.693025+00:00", "type": "pullrequest_comment", "id": 46426705}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"update": {"description": "This PR adds a `bench` example program that can be used to evaluate the latency and throughput of `ign-transport`.\r\n\r\nA deadlock was found in `Node.cc` when using intraprocess communication with a mutex. The modification to `Node.cc` changes intraprocess message delivery from blocking to non-blocking. The behavior now matches interprocess communication. A few tests relied on blocking intraprocess message delivery. Those tests have been modified to use condition variables.\r\n\r\nA slight change was made to `NodeShared` to reduce the length of time the mutex is held during message publication. I didn't notice any performance impact, but there might be change with large numbers of publishers and subscribers.\r\n\r\n# Dependencies\r\n\r\nThis PR relies on C++14, and will not be merged until pull request #128 is merged first.\r\n\r\n# Benchmarking \r\n\r\nThis process could use more automation, but the scope started to get out of hand. Here are the steps to follow:\r\n\r\n1. Compile and install as normal.\r\n2. Compile the `examples`\r\n3. Run the `bench` example. In one of the following configurations:\r\n\r\n    1. Example intraprocess latency:\r\n\r\n            ./bench -l\r\n\r\n    2. Example interprocess latency:\r\n\r\n            Terminal 1: ./bench -l -r\r\n\r\n            Terminal 2: ./bench -l -p\r\n\r\n    3. Example intraprocess throughput:\r\n\r\n            ./bench -t\r\n\r\n    4. Example interprocess throughput:\r\n\r\n            Terminal 1: ./bench -t -r\r\n\r\n            Terminal 2: ./bench -t -p\r\n\r\n4. The `bench` executable with the `-p` option will output data suitable for use with the `latency.gp` and `throughput.gp` gnuplot scripts. Note: you can use the `-o` option with `bench` to output to a file.\r\n\r\n5. Produce plots using\r\n\r\n    1. Latency\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" latency.gp\r\n\r\n    2. Throughput\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" throughput.gp\r\n\r\n## Results\r\n\r\nRaw data is stored in `examples/data`. We can use this (or some other location) to hold a history of benchmark data. All results are the average of 100 iterations. These tests include time required for message serialization and deserialization.\r\n\r\nI did not make a test out `bench` because results are highly dependent on hardware, background processes, and network activity.\r\n\r\nA few definitions follow.\r\n\r\n** Intraprocess**:  Publisher and subscriber in same process.\r\n\r\n** Interprocess**: Publisher and subscriber in separate processes on the same PC.\r\n\r\n** Wired**: Publisher and subscriber on separate PCs connected via a wired LAN.\r\n\r\n**Wireless**: Publisher and subscriber on separate Pcs where one computer was connected to wireless access point and the other hardwired to the LAN.\r\n\r\n** Latency**: Latency was measure by publishing a message on `topicA`, and then waiting for a response on `topicB`. The time between publication and reception of the response was divided in half to compute the one-way latency time.\r\n\r\n**Throughput**: Throughput was measure by rapidly publishing N messages. Once the N messages have been published, the publisher waits for N responses. The time from start of publication to reception of all N messages is used to compute throughput. \r\n\r\n### Latency\r\n\r\n** Intraprocess latency**\r\n\r\nI was not expecting this result. My theory as to why the plot is not more constant is a combination of context switches, other processes, etc.\r\n\r\n![latency-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/1473127294-latency-Intraprocess-all.png)\r\n\r\n![latency-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3217563991-latency-Intraprocess-small.png)\r\n\r\n![latency-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/83318001-latency-Intraprocess-large.png)\r\n\r\n**Interprocess latency**\r\n\r\n![latency-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2668403778-latency-Interprocess-all.png)\r\n\r\n![latency-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3207293959-latency-Interprocess-small.png)\r\n\r\n![latency-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/556609639-latency-Interprocess-large.png)\r\n**Wired latency**\r\n\r\n![latency-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1861775847-latency-Wired-all.png)\r\n\r\n![latency-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3238222459-latency-Wired-small.png)\r\n\r\n![latency-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/2639846742-latency-Wired-large.png)\r\n\r\n** Wireless latency**\r\n\r\nYou may notice that the latency appears better than over the wired network. I believe this is because I ran the wireless tests when no one else was using the network, and the wired test during an active portion of the day.\r\n\r\n![latency-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/177746882-latency-Wireless-all.png)\r\n\r\n![latency-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/4212627213-latency-Wireless-small.png)\r\n\r\n![latency-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/3866951968-latency-Wireless-large.png)\r\n\r\n### Throughput\r\n\r\n** Intraprocess throughput**\r\n\r\n![throughput-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2829676984-throughput-Intraprocess-all.png)\r\n\r\n![throughput-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3933927565-throughput-Intraprocess-small.png)\r\n\r\n![throughput-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/3718225819-throughput-Intraprocess-large.png)\r\n\r\n** Interprocess throughput**\r\n\r\n![throughput-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/3032255927-throughput-Interprocess-all.png)\r\n\r\n![throughput-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/1568831296-throughput-Interprocess-small.png)\r\n\r\n![throughput-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/4114343739-throughput-Interprocess-large.png)\r\n\r\n** Wired throughput**\r\n\r\n![throughput-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1229007404-throughput-Wired-all.png)\r\n\r\n![throughput-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3679643025-throughput-Wired-small.png)\r\n\r\n![throughput-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/3619655927-throughput-Wired-large.png)\r\n\r\n** Wireless throughput**\r\n\r\n![throughput-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/365561471-throughput-Wireless-all.png)\r\n\r\n![throughput-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/2412795863-throughput-Wireless-small.png)\r\n\r\n![throughput-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/1670547079-throughput-Wireless-large.png)\r\n\r\n## Comparison\r\n\r\nI had no idea whether these results were good or bad. [This paper](https://dl.acm.org/citation.cfm?id=2968502) on ROS1 and ROS2 performance can be used as a point of comparison.", "title": "Benchmark", "destination": {"commit": {"hash": "220acae6f0cd", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/220acae6f0cd.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/220acae6f0cd"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "ign-transport4"}}, "reason": "", "source": {"commit": {"hash": "933a874c0d9c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/933a874c0d9c.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/933a874c0d9c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "benchmark_nate"}}, "state": "OPEN", "author": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "date": "2017-10-04T17:26:35.930461+00:00"}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"update": {"description": "This PR adds a `bench` example program that can be used to evaluate the latency and throughput of `ign-transport`.\r\n\r\nA deadlock was found in `Node.cc` when using intraprocess communication with a mutex. The modification to `Node.cc` changes intraprocess message delivery from blocking to non-blocking. The behavior now matches interprocess communication. A few tests relied on blocking intraprocess message delivery. Those tests have been modified to use condition variables.\r\n\r\nA slight change was made to `NodeShared` to reduce the length of time the mutex is held during message publication. I didn't notice any performance impact, but there might be change with large numbers of publishers and subscribers.\r\n\r\n# Dependencies\r\n\r\nThis PR relies on C++14, and will not be merged until pull request #128 is merged first.\r\n\r\n# Benchmarking \r\n\r\nThis process could use more automation, but the scope started to get out of hand. Here are the steps to follow:\r\n\r\n1. Compile and install as normal.\r\n2. Compile the `examples`\r\n3. Run the `bench` example. In one of the following configurations:\r\n\r\n    1. Example intraprocess latency:\r\n\r\n            ./bench -l\r\n\r\n    2. Example interprocess latency:\r\n\r\n            Terminal 1: ./bench -l -r\r\n\r\n            Terminal 2: ./bench -l -p\r\n\r\n    3. Example intraprocess throughput:\r\n\r\n            ./bench -t\r\n\r\n    4. Example interprocess throughput:\r\n\r\n            Terminal 1: ./bench -t -r\r\n\r\n            Terminal 2: ./bench -t -p\r\n\r\n4. The `bench` executable with the `-p` option will output data suitable for use with the `latency.gp` and `throughput.gp` gnuplot scripts. Note: you can use the `-o` option with `bench` to output to a file.\r\n\r\n5. Produce plots using\r\n\r\n    1. Latency\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" latency.gp\r\n\r\n    2. Throughput\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" throughput.gp\r\n\r\n## Results\r\n\r\nRaw data is stored in `examples/data`. We can use this (or some other location) to hold a history of benchmark data. All results are the average of 100 iterations. These tests include time required for message serialization and deserialization.\r\n\r\nI did not make a test out `bench` because results are highly dependent on hardware, background processes, and network activity.\r\n\r\nA few definitions follow.\r\n\r\n** Intraprocess**:  Publisher and subscriber in same process.\r\n\r\n** Interprocess**: Publisher and subscriber in separate processes on the same PC.\r\n\r\n** Wired**: Publisher and subscriber on separate PCs connected via a wired LAN.\r\n\r\n**Wireless**: Publisher and subscriber on separate Pcs where one computer was connected to wireless access point and the other hardwired to the LAN.\r\n\r\n** Latency**: Latency was measure by publishing a message on `topicA`, and then waiting for a response on `topicB`. The time between publication and reception of the response was divided in half to compute the one-way latency time.\r\n\r\n**Throughput**: Throughput was measure by rapidly publishing N messages. Once the N messages have been published, the publisher waits for N responses. The time from start of publication to reception of all N messages is used to compute throughput. \r\n\r\n### Latency\r\n\r\n** Intraprocess latency**\r\n\r\nI was not expecting this result. My theory as to why the plot is not more constant is a combination of context switches, other processes, etc.\r\n\r\n![latency-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/1473127294-latency-Intraprocess-all.png)\r\n\r\n![latency-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3217563991-latency-Intraprocess-small.png)\r\n\r\n![latency-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/83318001-latency-Intraprocess-large.png)\r\n\r\n**Interprocess latency**\r\n\r\n![latency-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2668403778-latency-Interprocess-all.png)\r\n\r\n![latency-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3207293959-latency-Interprocess-small.png)\r\n\r\n![latency-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/556609639-latency-Interprocess-large.png)\r\n**Wired latency**\r\n\r\n![latency-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1861775847-latency-Wired-all.png)\r\n\r\n![latency-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3238222459-latency-Wired-small.png)\r\n\r\n![latency-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/2639846742-latency-Wired-large.png)\r\n\r\n** Wireless latency**\r\n\r\nYou may notice that the latency appears better than over the wired network. I believe this is because I ran the wireless tests when no one else was using the network, and the wired test during an active portion of the day.\r\n\r\n![latency-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/177746882-latency-Wireless-all.png)\r\n\r\n![latency-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/4212627213-latency-Wireless-small.png)\r\n\r\n![latency-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/3866951968-latency-Wireless-large.png)\r\n\r\n### Throughput\r\n\r\n** Intraprocess throughput**\r\n\r\n![throughput-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2829676984-throughput-Intraprocess-all.png)\r\n\r\n![throughput-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3933927565-throughput-Intraprocess-small.png)\r\n\r\n![throughput-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/3718225819-throughput-Intraprocess-large.png)\r\n\r\n** Interprocess throughput**\r\n\r\n![throughput-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/3032255927-throughput-Interprocess-all.png)\r\n\r\n![throughput-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/1568831296-throughput-Interprocess-small.png)\r\n\r\n![throughput-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/4114343739-throughput-Interprocess-large.png)\r\n\r\n** Wired throughput**\r\n\r\n![throughput-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1229007404-throughput-Wired-all.png)\r\n\r\n![throughput-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3679643025-throughput-Wired-small.png)\r\n\r\n![throughput-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/3619655927-throughput-Wired-large.png)\r\n\r\n** Wireless throughput**\r\n\r\n![throughput-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/365561471-throughput-Wireless-all.png)\r\n\r\n![throughput-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/2412795863-throughput-Wireless-small.png)\r\n\r\n![throughput-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/1670547079-throughput-Wireless-large.png)\r\n\r\n## Comparison\r\n\r\nI had no idea whether these results were good or bad. [This paper](https://dl.acm.org/citation.cfm?id=2968502) on ROS1 and ROS2 performance can be used as a point of comparison.", "title": "Benchmark", "destination": {"commit": {"hash": "220acae6f0cd", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/220acae6f0cd.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/220acae6f0cd"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "ign-transport4"}}, "reason": "", "source": {"commit": {"hash": "ed826e87297c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/ed826e87297c.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/ed826e87297c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "benchmark_nate"}}, "state": "OPEN", "author": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "date": "2017-10-04T17:26:00.928580+00:00"}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46422082.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46422082"}}, "parent": {"id": 46164539, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46164539.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46164539"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "The duration shouldn't change at all, correct? `timeEnd` is captured before the `notify_all()`.", "markup": "markdown", "html": "<p>The duration shouldn't change at all, correct? <code>timeEnd</code> is captured before the <code>notify_all()</code>.</p>", "type": "rendered"}, "created_on": "2017-10-04T16:23:10.721820+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2017-10-04T16:23:10.723935+00:00", "type": "pullrequest_comment", "id": 46422082}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46252660.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46252660"}}, "parent": {"id": 46080038, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46080038.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46080038"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "Based on a different conversation, it seems that eventually we should be able to depend on `Ignition Common` without having to install all extra dependencies. How about if we copy the `WorkerPool` class in `Ignition Transport` until we depend on `Ignition Common`. I see a few advantages:\n\n* The behavior won't change when we replace the `WorkerPool` from `Ignition Common` (hopefully soon).\n* I haven't tested but it might be a bit overkill to create and destroy a thread every time that we publish a message for every destination node (located in the same process). ", "markup": "markdown", "html": "<p>Based on a different conversation, it seems that eventually we should be able to depend on <code>Ignition Common</code> without having to install all extra dependencies. How about if we copy the <code>WorkerPool</code> class in <code>Ignition Transport</code> until we depend on <code>Ignition Common</code>. I see a few advantages:</p>\n<ul>\n<li>The behavior won't change when we replace the <code>WorkerPool</code> from <code>Ignition Common</code> (hopefully soon).</li>\n<li>I haven't tested but it might be a bit overkill to create and destroy a thread every time that we publish a message for every destination node (located in the same process). </li>\n</ul>", "type": "rendered"}, "created_on": "2017-10-02T20:14:08.344619+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "updated_on": "2017-10-02T20:14:08.347145+00:00", "type": "pullrequest_comment", "id": 46252660}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46243723.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46243723"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "I've got a few gigabit ethernet switches in my car that you're welcome to use if you'd like to re-test the wired cases on a non-congested network.", "markup": "markdown", "html": "<p>I've got a few gigabit ethernet switches in my car that you're welcome to use if you'd like to re-test the wired cases on a non-congested network.</p>", "type": "rendered"}, "created_on": "2017-10-02T17:52:18.691047+00:00", "user": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}, "updated_on": "2017-10-02T17:52:18.693926+00:00", "type": "pullrequest_comment", "id": 46243723}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46164539.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46164539"}}, "parent": {"id": 46045208, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46045208.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46045208"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "This way, the duration will be computed before the `notify_all()`. Agreed it's not going to change drastically, I'm happy as it is too, your call.", "markup": "markdown", "html": "<p>This way, the duration will be computed before the <code>notify_all()</code>. Agreed it's not going to change drastically, I'm happy as it is too, your call.</p>", "type": "rendered"}, "created_on": "2017-09-29T22:30:07.360362+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "inline": {}, "updated_on": "2017-09-29T22:30:07.363219+00:00", "type": "pullrequest_comment", "id": 46164539}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46080042.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46080042"}}, "parent": {"id": 45986310, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/45986310.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-45986310"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "Removed: aa06591", "markup": "markdown", "html": "<p>Removed: <a href=\"#!/ignitionrobotics/ign-transport/commits/aa06591\" rel=\"nofollow\" class=\"ap-connect-link\">aa06591</a></p>", "type": "rendered"}, "created_on": "2017-09-28T22:13:44.474495+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2017-09-28T22:13:44.477799+00:00", "type": "pullrequest_comment", "id": 46080042}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46080038.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46080038"}}, "parent": {"id": 46045060, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46045060.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46045060"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "removal of ign-common aa06591", "markup": "markdown", "html": "<p>removal of ign-common <a href=\"#!/ignitionrobotics/ign-transport/commits/aa06591\" rel=\"nofollow\" class=\"ap-connect-link\">aa06591</a></p>", "type": "rendered"}, "created_on": "2017-09-28T22:13:39.246910+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2017-09-28T22:13:39.249543+00:00", "type": "pullrequest_comment", "id": 46080038}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"update": {"description": "This PR adds a `bench` example program that can be used to evaluate the latency and throughput of `ign-transport`.\r\n\r\nA deadlock was found in `Node.cc` when using intraprocess communication with a mutex. The modification to `Node.cc` changes intraprocess message delivery from blocking to non-blocking. The behavior now matches interprocess communication. A few tests relied on blocking intraprocess message delivery. Those tests have been modified to use condition variables.\r\n\r\nA slight change was made to `NodeShared` to reduce the length of time the mutex is held during message publication. I didn't notice any performance impact, but there might be change with large numbers of publishers and subscribers.\r\n\r\n# Dependencies\r\n\r\nThis PR relies on C++14, and will not be merged until pull request #128 is merged first.\r\n\r\n# Benchmarking \r\n\r\nThis process could use more automation, but the scope started to get out of hand. Here are the steps to follow:\r\n\r\n1. Compile and install as normal.\r\n2. Compile the `examples`\r\n3. Run the `bench` example. In one of the following configurations:\r\n\r\n    1. Example intraprocess latency:\r\n\r\n            ./bench -l\r\n\r\n    2. Example interprocess latency:\r\n\r\n            Terminal 1: ./bench -l -r\r\n\r\n            Terminal 2: ./bench -l -p\r\n\r\n    3. Example intraprocess throughput:\r\n\r\n            ./bench -t\r\n\r\n    4. Example interprocess throughput:\r\n\r\n            Terminal 1: ./bench -t -r\r\n\r\n            Terminal 2: ./bench -t -p\r\n\r\n4. The `bench` executable with the `-p` option will output data suitable for use with the `latency.gp` and `throughput.gp` gnuplot scripts. Note: you can use the `-o` option with `bench` to output to a file.\r\n\r\n5. Produce plots using\r\n\r\n    1. Latency\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" latency.gp\r\n\r\n    2. Throughput\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" throughput.gp\r\n\r\n## Results\r\n\r\nRaw data is stored in `examples/data`. We can use this (or some other location) to hold a history of benchmark data. All results are the average of 100 iterations. These tests include time required for message serialization and deserialization.\r\n\r\nI did not make a test out `bench` because results are highly dependent on hardware, background processes, and network activity.\r\n\r\nA few definitions follow.\r\n\r\n** Intraprocess**:  Publisher and subscriber in same process.\r\n\r\n** Interprocess**: Publisher and subscriber in separate processes on the same PC.\r\n\r\n** Wired**: Publisher and subscriber on separate PCs connected via a wired LAN.\r\n\r\n**Wireless**: Publisher and subscriber on separate Pcs where one computer was connected to wireless access point and the other hardwired to the LAN.\r\n\r\n** Latency**: Latency was measure by publishing a message on `topicA`, and then waiting for a response on `topicB`. The time between publication and reception of the response was divided in half to compute the one-way latency time.\r\n\r\n**Throughput**: Throughput was measure by rapidly publishing N messages. Once the N messages have been published, the publisher waits for N responses. The time from start of publication to reception of all N messages is used to compute throughput. \r\n\r\n### Latency\r\n\r\n** Intraprocess latency**\r\n\r\nI was not expecting this result. My theory as to why the plot is not more constant is a combination of context switches, other processes, etc.\r\n\r\n![latency-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/1473127294-latency-Intraprocess-all.png)\r\n\r\n![latency-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3217563991-latency-Intraprocess-small.png)\r\n\r\n![latency-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/83318001-latency-Intraprocess-large.png)\r\n\r\n**Interprocess latency**\r\n\r\n![latency-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2668403778-latency-Interprocess-all.png)\r\n\r\n![latency-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3207293959-latency-Interprocess-small.png)\r\n\r\n![latency-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/556609639-latency-Interprocess-large.png)\r\n**Wired latency**\r\n\r\n![latency-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1861775847-latency-Wired-all.png)\r\n\r\n![latency-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3238222459-latency-Wired-small.png)\r\n\r\n![latency-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/2639846742-latency-Wired-large.png)\r\n\r\n** Wireless latency**\r\n\r\nYou may notice that the latency appears better than over the wired network. I believe this is because I ran the wireless tests when no one else was using the network, and the wired test during an active portion of the day.\r\n\r\n![latency-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/177746882-latency-Wireless-all.png)\r\n\r\n![latency-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/4212627213-latency-Wireless-small.png)\r\n\r\n![latency-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/3866951968-latency-Wireless-large.png)\r\n\r\n### Throughput\r\n\r\n** Intraprocess throughput**\r\n\r\n![throughput-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2829676984-throughput-Intraprocess-all.png)\r\n\r\n![throughput-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3933927565-throughput-Intraprocess-small.png)\r\n\r\n![throughput-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/3718225819-throughput-Intraprocess-large.png)\r\n\r\n** Interprocess throughput**\r\n\r\n![throughput-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/3032255927-throughput-Interprocess-all.png)\r\n\r\n![throughput-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/1568831296-throughput-Interprocess-small.png)\r\n\r\n![throughput-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/4114343739-throughput-Interprocess-large.png)\r\n\r\n** Wired throughput**\r\n\r\n![throughput-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1229007404-throughput-Wired-all.png)\r\n\r\n![throughput-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3679643025-throughput-Wired-small.png)\r\n\r\n![throughput-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/3619655927-throughput-Wired-large.png)\r\n\r\n** Wireless throughput**\r\n\r\n![throughput-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/365561471-throughput-Wireless-all.png)\r\n\r\n![throughput-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/2412795863-throughput-Wireless-small.png)\r\n\r\n![throughput-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/1670547079-throughput-Wireless-large.png)\r\n\r\n## Comparison\r\n\r\nI had no idea whether these results were good or bad. [This paper](https://dl.acm.org/citation.cfm?id=2968502) on ROS1 and ROS2 performance can be used as a point of comparison.", "title": "Benchmark", "destination": {"commit": {"hash": "00b20d88d9a3", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/00b20d88d9a3.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/00b20d88d9a3"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "ign-transport4"}}, "reason": "", "source": {"commit": {"hash": "c7cc47d42d98", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/c7cc47d42d98.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/c7cc47d42d98"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "benchmark_nate"}}, "state": "OPEN", "author": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "date": "2017-09-28T22:13:08.208063+00:00"}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46045208.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46045208"}}, "parent": {"id": 45986026, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/45986026.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-45986026"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "I'm not sure of the benefit of the proposed move. It won't change the computed duration.", "markup": "markdown", "html": "<p>I'm not sure of the benefit of the proposed move. It won't change the computed duration.</p>", "type": "rendered"}, "created_on": "2017-09-28T14:42:52.127242+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2017-09-28T14:42:52.130221+00:00", "type": "pullrequest_comment", "id": 46045208}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46045060.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46045060"}}, "parent": {"id": 45981803, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/45981803.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-45981803"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "I'll try the std::async approach.\n\nI agree with trying to reduce dependencies, but it is a balance. The goal of Ignition is to have as few libraries as possible, with plugins playing a larger role.  ", "markup": "markdown", "html": "<p>I'll try the std::async approach.</p>\n<p>I agree with trying to reduce dependencies, but it is a balance. The goal of Ignition is to have as few libraries as possible, with plugins playing a larger role.  </p>", "type": "rendered"}, "created_on": "2017-09-28T14:41:44.137663+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2017-09-28T14:41:44.140702+00:00", "type": "pullrequest_comment", "id": 46045060}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/46044402.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-46044402"}}, "parent": {"id": 45975745, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/45975745.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-45975745"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "Agreed. We approached the theoretical limit of TCP over gigabit ethernet.", "markup": "markdown", "html": "<p>Agreed. We approached the theoretical limit of TCP over gigabit ethernet.</p>", "type": "rendered"}, "created_on": "2017-09-28T14:36:11.007607+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2017-09-28T14:36:11.010948+00:00", "type": "pullrequest_comment", "id": 46044402}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/45986310.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-45986310"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "Do we need this block? I believe an `ofstream` closes automatically in its destructor. See also line `414`.", "markup": "markdown", "html": "<p>Do we need this block? I believe an <code>ofstream</code> closes automatically in its destructor. See also line <code>414</code>.</p>", "type": "rendered"}, "created_on": "2017-09-28T01:18:08.761570+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "inline": {}, "updated_on": "2017-09-28T01:18:08.763793+00:00", "type": "pullrequest_comment", "id": 45986310}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/45986026.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-45986026"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "We could move it to the callback before calling `notify_all`.", "markup": "markdown", "html": "<p>We could move it to the callback before calling <code>notify_all</code>.</p>", "type": "rendered"}, "created_on": "2017-09-28T01:09:13.704577+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "inline": {}, "updated_on": "2017-09-28T01:09:13.707414+00:00", "type": "pullrequest_comment", "id": 45986026}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/45981803.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-45981803"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "The main issue that I see after thinking on this during some time is the extra Ignition Common dependency. I see two main problems:\n\n* Currently, Ignition Common doesn't build on Windows. This will affect the Ignition Transport CI because all Windows builds won't work until we fix the Ignition Common CI. The current plan is to merge the initial Ignition CMake [PR](#!/ignitionrobotics/ign-cmake/pull-requests/1), and then, merge the CMakeRefactor [PR](#!/ignitionrobotics/ign-common/pull-requests/69) in Ignition Common. In my opinion, this is just an issue that will delay the merge of this pull request a little bit, but it's not a big deal if Ignition Common is fixed.\n\n* The main concern that I have is the size of Ignition Common in terms of dependencies. Here is some data:\n  * [Recursive list of dependencies on Ignition Transport 3.x.x](https://bitbucket.org/snippets/osrf/9jaEzk/ignition-transport-3xx-recursive)\n  * [Recursive list of dependencies on Ignition Common 0.x.x](https://bitbucket.org/snippets/osrf/zj5Ex5/ignition-common-0xx-recursive-dependencies)\n  * [Diff](https://bitbucket.org/snippets/osrf/9jaERX/dependencies-diff-ignition-transport-3xx)\n\n  For the record, I created the list with:\n  \n```\n#!c++\n\napt-rdepends libignition-transport-dev | grep Depends | cut -d\" \" -f4 | sort | uniq > /tmp/transport_deps\napt-rdepends libignition-common-dev | grep Depends | cut -d\" \" -f4 | sort | uniq > /tmp/common_deps\ncat /tmp/transport_deps /tmp/common_deps | sort | uniq -u > diff_deps\ngrep -Fvxf /tmp/transport_deps /tmp/diff_deps > /tmp/diff\n```\n\nI'm not 100% convinced that the need of `common::WorkerPool` justifies to pull all these extra dependencies. Note, that some of the dependencies will already exist in a basic installation, but I think is arguable the need to pull audio and video dependencies (for example) into Ignition Transport. [This issue](#!/ignitionrobotics/ign-common/issues/14) captures more details about it.\n\nHere are a few proposals:\n\n* Copy the `WorkerPool` class into Ignition Transport.\n* Split `Ignition Common` into multiple libraries. I'd like to see `Ignition Common` as a pretty lightweight library focused in real common features that can be implemented with just a few dependencies. I'm aware that this can take a bit of discussion, so I'm leaning towards the other options until we have a clear idea of the `Ignition Common` direction. I think this is the right way to go, but will block this PR for some time.\n* Maybe there's an easy way to use `std::async` instead of a `WorkerPool`. Just an idea, I haven't thought much about it.", "markup": "markdown", "html": "<p>The main issue that I see after thinking on this during some time is the extra Ignition Common dependency. I see two main problems:</p>\n<ul>\n<li>\n<p>Currently, Ignition Common doesn't build on Windows. This will affect the Ignition Transport CI because all Windows builds won't work until we fix the Ignition Common CI. The current plan is to merge the initial Ignition CMake <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-cmake/pull-requests/1\" rel=\"nofollow\">PR</a>, and then, merge the CMakeRefactor <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-common/pull-requests/69\" rel=\"nofollow\">PR</a> in Ignition Common. In my opinion, this is just an issue that will delay the merge of this pull request a little bit, but it's not a big deal if Ignition Common is fixed.</p>\n</li>\n<li>\n<p>The main concern that I have is the size of Ignition Common in terms of dependencies. Here is some data:</p>\n</li>\n<li><a data-is-external-link=\"true\" href=\"https://bitbucket.org/snippets/osrf/9jaEzk/ignition-transport-3xx-recursive\" rel=\"nofollow\">Recursive list of dependencies on Ignition Transport 3.x.x</a></li>\n<li><a data-is-external-link=\"true\" href=\"https://bitbucket.org/snippets/osrf/zj5Ex5/ignition-common-0xx-recursive-dependencies\" rel=\"nofollow\">Recursive list of dependencies on Ignition Common 0.x.x</a></li>\n<li><a data-is-external-link=\"true\" href=\"https://bitbucket.org/snippets/osrf/9jaERX/dependencies-diff-ignition-transport-3xx\" rel=\"nofollow\">Diff</a></li>\n</ul>\n<p>For the record, I created the list with:</p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"n\">apt</span><span class=\"o\">-</span><span class=\"n\">rdepends</span> <span class=\"n\">libignition</span><span class=\"o\">-</span><span class=\"n\">transport</span><span class=\"o\">-</span><span class=\"n\">dev</span> <span class=\"o\">|</span> <span class=\"n\">grep</span> <span class=\"n\">Depends</span> <span class=\"o\">|</span> <span class=\"n\">cut</span> <span class=\"o\">-</span><span class=\"n\">d</span><span class=\"s\">&quot; &quot;</span> <span class=\"o\">-</span><span class=\"n\">f4</span> <span class=\"o\">|</span> <span class=\"n\">sort</span> <span class=\"o\">|</span> <span class=\"n\">uniq</span> <span class=\"o\">&gt;</span> <span class=\"o\">/</span><span class=\"n\">tmp</span><span class=\"o\">/</span><span class=\"n\">transport_deps</span>\n<span class=\"n\">apt</span><span class=\"o\">-</span><span class=\"n\">rdepends</span> <span class=\"n\">libignition</span><span class=\"o\">-</span><span class=\"n\">common</span><span class=\"o\">-</span><span class=\"n\">dev</span> <span class=\"o\">|</span> <span class=\"n\">grep</span> <span class=\"n\">Depends</span> <span class=\"o\">|</span> <span class=\"n\">cut</span> <span class=\"o\">-</span><span class=\"n\">d</span><span class=\"s\">&quot; &quot;</span> <span class=\"o\">-</span><span class=\"n\">f4</span> <span class=\"o\">|</span> <span class=\"n\">sort</span> <span class=\"o\">|</span> <span class=\"n\">uniq</span> <span class=\"o\">&gt;</span> <span class=\"o\">/</span><span class=\"n\">tmp</span><span class=\"o\">/</span><span class=\"n\">common_deps</span>\n<span class=\"n\">cat</span> <span class=\"o\">/</span><span class=\"n\">tmp</span><span class=\"o\">/</span><span class=\"n\">transport_deps</span> <span class=\"o\">/</span><span class=\"n\">tmp</span><span class=\"o\">/</span><span class=\"n\">common_deps</span> <span class=\"o\">|</span> <span class=\"n\">sort</span> <span class=\"o\">|</span> <span class=\"n\">uniq</span> <span class=\"o\">-</span><span class=\"n\">u</span> <span class=\"o\">&gt;</span> <span class=\"n\">diff_deps</span>\n<span class=\"n\">grep</span> <span class=\"o\">-</span><span class=\"n\">Fvxf</span> <span class=\"o\">/</span><span class=\"n\">tmp</span><span class=\"o\">/</span><span class=\"n\">transport_deps</span> <span class=\"o\">/</span><span class=\"n\">tmp</span><span class=\"o\">/</span><span class=\"n\">diff_deps</span> <span class=\"o\">&gt;</span> <span class=\"o\">/</span><span class=\"n\">tmp</span><span class=\"o\">/</span><span class=\"n\">diff</span>\n</pre></div>\n\n\n<p>I'm not 100% convinced that the need of <code>common::WorkerPool</code> justifies to pull all these extra dependencies. Note, that some of the dependencies will already exist in a basic installation, but I think is arguable the need to pull audio and video dependencies (for example) into Ignition Transport. <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-common/issues/14\" rel=\"nofollow\">This issue</a> captures more details about it.</p>\n<p>Here are a few proposals:</p>\n<ul>\n<li>Copy the <code>WorkerPool</code> class into Ignition Transport.</li>\n<li>Split <code>Ignition Common</code> into multiple libraries. I'd like to see <code>Ignition Common</code> as a pretty lightweight library focused in real common features that can be implemented with just a few dependencies. I'm aware that this can take a bit of discussion, so I'm leaning towards the other options until we have a clear idea of the <code>Ignition Common</code> direction. I think this is the right way to go, but will block this PR for some time.</li>\n<li>Maybe there's an easy way to use <code>std::async</code> instead of a <code>WorkerPool</code>. Just an idea, I haven't thought much about it.</li>\n</ul>", "type": "rendered"}, "created_on": "2017-09-27T22:58:22.615728+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "updated_on": "2017-09-28T01:01:49.377530+00:00", "type": "pullrequest_comment", "id": 45981803}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/45983385.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-45983385"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "Very minor tweaks commited directly in e09fe4a.", "markup": "markdown", "html": "<p>Very minor tweaks commited directly in <a href=\"#!/ignitionrobotics/ign-transport/commits/e09fe4a\" rel=\"nofollow\" class=\"ap-connect-link\">e09fe4a</a>.</p>", "type": "rendered"}, "created_on": "2017-09-27T23:44:20.227402+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "updated_on": "2017-09-27T23:44:20.229858+00:00", "type": "pullrequest_comment", "id": 45983385}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"update": {"description": "This PR adds a `bench` example program that can be used to evaluate the latency and throughput of `ign-transport`.\r\n\r\nA deadlock was found in `Node.cc` when using intraprocess communication with a mutex. The modification to `Node.cc` changes intraprocess message delivery from blocking to non-blocking. The behavior now matches interprocess communication. A few tests relied on blocking intraprocess message delivery. Those tests have been modified to use condition variables.\r\n\r\nA slight change was made to `NodeShared` to reduce the length of time the mutex is held during message publication. I didn't notice any performance impact, but there might be change with large numbers of publishers and subscribers.\r\n\r\n# Dependencies\r\n\r\nThis PR relies on C++14, and will not be merged until pull request #128 is merged first.\r\n\r\n# Benchmarking \r\n\r\nThis process could use more automation, but the scope started to get out of hand. Here are the steps to follow:\r\n\r\n1. Compile and install as normal.\r\n2. Compile the `examples`\r\n3. Run the `bench` example. In one of the following configurations:\r\n\r\n    1. Example intraprocess latency:\r\n\r\n            ./bench -l\r\n\r\n    2. Example interprocess latency:\r\n\r\n            Terminal 1: ./bench -l -r\r\n\r\n            Terminal 2: ./bench -l -p\r\n\r\n    3. Example intraprocess throughput:\r\n\r\n            ./bench -t\r\n\r\n    4. Example interprocess throughput:\r\n\r\n            Terminal 1: ./bench -t -r\r\n\r\n            Terminal 2: ./bench -t -p\r\n\r\n4. The `bench` executable with the `-p` option will output data suitable for use with the `latency.gp` and `throughput.gp` gnuplot scripts. Note: you can use the `-o` option with `bench` to output to a file.\r\n\r\n5. Produce plots using\r\n\r\n    1. Latency\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" latency.gp\r\n\r\n    2. Throughput\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" throughput.gp\r\n\r\n## Results\r\n\r\nRaw data is stored in `examples/data`. We can use this (or some other location) to hold a history of benchmark data. All results are the average of 100 iterations. These tests include time required for message serialization and deserialization.\r\n\r\nI did not make a test out `bench` because results are highly dependent on hardware, background processes, and network activity.\r\n\r\nA few definitions follow.\r\n\r\n** Intraprocess**:  Publisher and subscriber in same process.\r\n\r\n** Interprocess**: Publisher and subscriber in separate processes on the same PC.\r\n\r\n** Wired**: Publisher and subscriber on separate PCs connected via a wired LAN.\r\n\r\n**Wireless**: Publisher and subscriber on separate Pcs where one computer was connected to wireless access point and the other hardwired to the LAN.\r\n\r\n** Latency**: Latency was measure by publishing a message on `topicA`, and then waiting for a response on `topicB`. The time between publication and reception of the response was divided in half to compute the one-way latency time.\r\n\r\n**Throughput**: Throughput was measure by rapidly publishing N messages. Once the N messages have been published, the publisher waits for N responses. The time from start of publication to reception of all N messages is used to compute throughput. \r\n\r\n### Latency\r\n\r\n** Intraprocess latency**\r\n\r\nI was not expecting this result. My theory as to why the plot is not more constant is a combination of context switches, other processes, etc.\r\n\r\n![latency-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/1473127294-latency-Intraprocess-all.png)\r\n\r\n![latency-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3217563991-latency-Intraprocess-small.png)\r\n\r\n![latency-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/83318001-latency-Intraprocess-large.png)\r\n\r\n**Interprocess latency**\r\n\r\n![latency-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2668403778-latency-Interprocess-all.png)\r\n\r\n![latency-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3207293959-latency-Interprocess-small.png)\r\n\r\n![latency-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/556609639-latency-Interprocess-large.png)\r\n**Wired latency**\r\n\r\n![latency-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1861775847-latency-Wired-all.png)\r\n\r\n![latency-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3238222459-latency-Wired-small.png)\r\n\r\n![latency-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/2639846742-latency-Wired-large.png)\r\n\r\n** Wireless latency**\r\n\r\nYou may notice that the latency appears better than over the wired network. I believe this is because I ran the wireless tests when no one else was using the network, and the wired test during an active portion of the day.\r\n\r\n![latency-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/177746882-latency-Wireless-all.png)\r\n\r\n![latency-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/4212627213-latency-Wireless-small.png)\r\n\r\n![latency-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/3866951968-latency-Wireless-large.png)\r\n\r\n### Throughput\r\n\r\n** Intraprocess throughput**\r\n\r\n![throughput-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2829676984-throughput-Intraprocess-all.png)\r\n\r\n![throughput-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3933927565-throughput-Intraprocess-small.png)\r\n\r\n![throughput-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/3718225819-throughput-Intraprocess-large.png)\r\n\r\n** Interprocess throughput**\r\n\r\n![throughput-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/3032255927-throughput-Interprocess-all.png)\r\n\r\n![throughput-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/1568831296-throughput-Interprocess-small.png)\r\n\r\n![throughput-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/4114343739-throughput-Interprocess-large.png)\r\n\r\n** Wired throughput**\r\n\r\n![throughput-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1229007404-throughput-Wired-all.png)\r\n\r\n![throughput-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3679643025-throughput-Wired-small.png)\r\n\r\n![throughput-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/3619655927-throughput-Wired-large.png)\r\n\r\n** Wireless throughput**\r\n\r\n![throughput-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/365561471-throughput-Wireless-all.png)\r\n\r\n![throughput-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/2412795863-throughput-Wireless-small.png)\r\n\r\n![throughput-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/1670547079-throughput-Wireless-large.png)\r\n\r\n## Comparison\r\n\r\nI had no idea whether these results were good or bad. [This paper](https://dl.acm.org/citation.cfm?id=2968502) on ROS1 and ROS2 performance can be used as a point of comparison.", "title": "Benchmark", "destination": {"commit": {"hash": "00b20d88d9a3", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/00b20d88d9a3.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/00b20d88d9a3"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "ign-transport4"}}, "reason": "", "source": {"commit": {"hash": "e09fe4ac8732", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/e09fe4ac8732.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/e09fe4ac8732"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "benchmark_nate"}}, "state": "OPEN", "author": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "date": "2017-09-27T23:43:43.075066+00:00"}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/45983003.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-45983003"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "All calls to `<condition_variable>.wait(lk)` should be changed to `<condition_variable>.wait(lk, bool_expression)` to avoid spurious wakeups. See [here](http://en.cppreference.com/w/cpp/thread/condition_variable/wait).", "markup": "markdown", "html": "<p>All calls to <code>&lt;condition_variable&gt;.wait(lk)</code> should be changed to <code>&lt;condition_variable&gt;.wait(lk, bool_expression)</code> to avoid spurious wakeups. See <a data-is-external-link=\"true\" href=\"http://en.cppreference.com/w/cpp/thread/condition_variable/wait\" rel=\"nofollow\">here</a>.</p>", "type": "rendered"}, "created_on": "2017-09-27T23:32:51.622471+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "updated_on": "2017-09-27T23:33:49.326956+00:00", "type": "pullrequest_comment", "id": 45983003}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225/comments/45975745.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225/_/diff#comment-45975745"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}, "content": {"raw": "Quick comment about the wired troughput during interprocess communication over the wire. The approximate maximum throughput for TCP over Gigabit Ethernet should be around 120MB/s . That's probably why the curve saturates at that point.", "markup": "markdown", "html": "<p>Quick comment about the wired troughput during interprocess communication over the wire. The approximate maximum throughput for TCP over Gigabit Ethernet should be around 120MB/s . That's probably why the curve saturates at that point.</p>", "type": "rendered"}, "created_on": "2017-09-27T21:02:01.772207+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "updated_on": "2017-09-27T21:02:21.631176+00:00", "type": "pullrequest_comment", "id": 45975745}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"update": {"description": "This PR adds a `bench` example program that can be used to evaluate the latency and throughput of `ign-transport`.\r\n\r\nA deadlock was found in `Node.cc` when using intraprocess communication with a mutex. The modification to `Node.cc` changes intraprocess message delivery from blocking to non-blocking. The behavior now matches interprocess communication. A few tests relied on blocking intraprocess message delivery. Those tests have been modified to use condition variables.\r\n\r\nA slight change was made to `NodeShared` to reduce the length of time the mutex is held during message publication. I didn't notice any performance impact, but there might be change with large numbers of publishers and subscribers.\r\n\r\n# Dependencies\r\n\r\nThis PR relies on C++14, and will not be merged until pull request #128 is merged first.\r\n\r\n# Benchmarking \r\n\r\nThis process could use more automation, but the scope started to get out of hand. Here are the steps to follow:\r\n\r\n1. Compile and install as normal.\r\n2. Compile the `examples`\r\n3. Run the `bench` example. In one of the following configurations:\r\n\r\n    1. Example intraprocess latency:\r\n\r\n            ./bench -l\r\n\r\n    2. Example interprocess latency:\r\n\r\n            Terminal 1: ./bench -l -r\r\n\r\n            Terminal 2: ./bench -l -p\r\n\r\n    3. Example intraprocess throughput:\r\n\r\n            ./bench -t\r\n\r\n    4. Example interprocess throughput:\r\n\r\n            Terminal 1: ./bench -t -r\r\n\r\n            Terminal 2: ./bench -t -p\r\n\r\n4. The `bench` executable with the `-p` option will output data suitable for use with the `latency.gp` and `throughput.gp` gnuplot scripts. Note: you can use the `-o` option with `bench` to output to a file.\r\n\r\n5. Produce plots using\r\n\r\n    1. Latency\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" latency.gp\r\n\r\n    2. Throughput\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" throughput.gp\r\n\r\n## Results\r\n\r\nRaw data is stored in `examples/data`. We can use this (or some other location) to hold a history of benchmark data. All results are the average of 100 iterations. These tests include time required for message serialization and deserialization.\r\n\r\nI did not make a test out `bench` because results are highly dependent on hardware, background processes, and network activity.\r\n\r\nA few definitions follow.\r\n\r\n** Intraprocess**:  Publisher and subscriber in same process.\r\n\r\n** Interprocess**: Publisher and subscriber in separate processes on the same PC.\r\n\r\n** Wired**: Publisher and subscriber on separate PCs connected via a wired LAN.\r\n\r\n**Wireless**: Publisher and subscriber on separate Pcs where one computer was connected to wireless access point and the other hardwired to the LAN.\r\n\r\n** Latency**: Latency was measure by publishing a message on `topicA`, and then waiting for a response on `topicB`. The time between publication and reception of the response was divided in half to compute the one-way latency time.\r\n\r\n**Throughput**: Throughput was measure by rapidly publishing N messages. Once the N messages have been published, the publisher waits for N responses. The time from start of publication to reception of all N messages is used to compute throughput. \r\n\r\n### Latency\r\n\r\n** Intraprocess latency**\r\n\r\nI was not expecting this result. My theory as to why the plot is not more constant is a combination of context switches, other processes, etc.\r\n\r\n![latency-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/1473127294-latency-Intraprocess-all.png)\r\n\r\n![latency-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3217563991-latency-Intraprocess-small.png)\r\n\r\n![latency-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/83318001-latency-Intraprocess-large.png)\r\n\r\n**Interprocess latency**\r\n\r\n![latency-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2668403778-latency-Interprocess-all.png)\r\n\r\n![latency-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3207293959-latency-Interprocess-small.png)\r\n\r\n![latency-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/556609639-latency-Interprocess-large.png)\r\n**Wired latency**\r\n\r\n![latency-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1861775847-latency-Wired-all.png)\r\n\r\n![latency-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3238222459-latency-Wired-small.png)\r\n\r\n![latency-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/2639846742-latency-Wired-large.png)\r\n\r\n** Wireless latency**\r\n\r\nYou may notice that the latency appears better than over the wired network. I believe this is because I ran the wireless tests when no one else was using the network, and the wired test during an active portion of the day.\r\n\r\n![latency-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/177746882-latency-Wireless-all.png)\r\n\r\n![latency-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/4212627213-latency-Wireless-small.png)\r\n\r\n![latency-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/3866951968-latency-Wireless-large.png)\r\n\r\n### Throughput\r\n\r\n** Intraprocess throughput**\r\n\r\n![throughput-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2829676984-throughput-Intraprocess-all.png)\r\n\r\n![throughput-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3933927565-throughput-Intraprocess-small.png)\r\n\r\n![throughput-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/3718225819-throughput-Intraprocess-large.png)\r\n\r\n** Interprocess throughput**\r\n\r\n![throughput-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/3032255927-throughput-Interprocess-all.png)\r\n\r\n![throughput-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/1568831296-throughput-Interprocess-small.png)\r\n\r\n![throughput-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/4114343739-throughput-Interprocess-large.png)\r\n\r\n** Wired throughput**\r\n\r\n![throughput-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1229007404-throughput-Wired-all.png)\r\n\r\n![throughput-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3679643025-throughput-Wired-small.png)\r\n\r\n![throughput-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/3619655927-throughput-Wired-large.png)\r\n\r\n** Wireless throughput**\r\n\r\n![throughput-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/365561471-throughput-Wireless-all.png)\r\n\r\n![throughput-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/2412795863-throughput-Wireless-small.png)\r\n\r\n![throughput-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/1670547079-throughput-Wireless-large.png)\r\n\r\n## Comparison\r\n\r\nI had no idea whether these results were good or bad. [This paper](https://dl.acm.org/citation.cfm?id=2968502) on ROS1 and ROS2 performance can be used as a point of comparison.", "title": "Benchmark", "destination": {"commit": {"hash": "b5e8dbef56ca", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/b5e8dbef56ca.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/b5e8dbef56ca"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "ign-transport4"}}, "reason": "", "source": {"commit": {"hash": "a1f20b2c3159", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/a1f20b2c3159.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/a1f20b2c3159"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "benchmark_nate"}}, "state": "OPEN", "author": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "date": "2017-09-26T23:08:05.482803+00:00"}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}, {"update": {"description": "This PR adds a `bench` example program that can be used to evaluate the latency and throughput of `ign-transport`.\r\n\r\nA deadlock was found in `Node.cc` when using intraprocess communication with a mutex. The modification to `Node.cc` changes intraprocess message delivery from blocking to non-blocking. The behavior now matches interprocess communication. A few tests relied on blocking intraprocess message delivery. Those tests have been modified to use condition variables.\r\n\r\nA slight change was made to `NodeShared` to reduce the length of time the mutex is held during message publication. I didn't notice any performance impact, but there might be change with large numbers of publishers and subscribers.\r\n\r\n# Dependencies\r\n\r\nThis PR relies on C++14, and will not be merged until pull request #128 is merged first.\r\n\r\n# Benchmarking \r\n\r\nThis process could use more automation, but the scope started to get out of hand. Here are the steps to follow:\r\n\r\n1. Compile and install as normal.\r\n2. Compile the `examples`\r\n3. Run the `bench` example. In one of the following configurations:\r\n\r\n    1. Example intraprocess latency:\r\n\r\n            ./bench -l\r\n\r\n    2. Example interprocess latency:\r\n\r\n            Terminal 1: ./bench -l -r\r\n\r\n            Terminal 2: ./bench -l -p\r\n\r\n    3. Example intraprocess throughput:\r\n\r\n            ./bench -t\r\n\r\n    4. Example interprocess throughput:\r\n\r\n            Terminal 1: ./bench -t -r\r\n\r\n            Terminal 2: ./bench -t -p\r\n\r\n4. The `bench` executable with the `-p` option will output data suitable for use with the `latency.gp` and `throughput.gp` gnuplot scripts. Note: you can use the `-o` option with `bench` to output to a file.\r\n\r\n5. Produce plots using\r\n\r\n    1. Latency\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" latency.gp\r\n\r\n    2. Throughput\r\n\r\n            gnuplot -e \"filename='MY_FILENAME'; prefix='MY_PREFIX'\" throughput.gp\r\n\r\n## Results\r\n\r\nRaw data is stored in `examples/data`. We can use this (or some other location) to hold a history of benchmark data. All results are the average of 100 iterations. These tests include time required for message serialization and deserialization.\r\n\r\nI did not make a test out `bench` because results are highly dependent on hardware, background processes, and network activity.\r\n\r\nA few definitions follow.\r\n\r\n** Intraprocess**:  Publisher and subscriber in same process.\r\n\r\n** Interprocess**: Publisher and subscriber in separate processes on the same PC.\r\n\r\n** Wired**: Publisher and subscriber on separate PCs connected via a wired LAN.\r\n\r\n**Wireless**: Publisher and subscriber on separate Pcs where one computer was connected to wireless access point and the other hardwired to the LAN.\r\n\r\n** Latency**: Latency was measure by publishing a message on `topicA`, and then waiting for a response on `topicB`. The time between publication and reception of the response was divided in half to compute the one-way latency time.\r\n\r\n**Throughput**: Throughput was measure by rapidly publishing N messages. Once the N messages have been published, the publisher waits for N responses. The time from start of publication to reception of all N messages is used to compute throughput. \r\n\r\n### Latency\r\n\r\n** Intraprocess latency**\r\n\r\nI was not expecting this result. My theory as to why the plot is not more constant is a combination of context switches, other processes, etc.\r\n\r\n![latency-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/1473127294-latency-Intraprocess-all.png)\r\n\r\n![latency-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3217563991-latency-Intraprocess-small.png)\r\n\r\n![latency-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/83318001-latency-Intraprocess-large.png)\r\n\r\n**Interprocess latency**\r\n\r\n![latency-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2668403778-latency-Interprocess-all.png)\r\n\r\n![latency-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3207293959-latency-Interprocess-small.png)\r\n\r\n![latency-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/556609639-latency-Interprocess-large.png)\r\n**Wired latency**\r\n\r\n![latency-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1861775847-latency-Wired-all.png)\r\n\r\n![latency-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3238222459-latency-Wired-small.png)\r\n\r\n![latency-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/2639846742-latency-Wired-large.png)\r\n\r\n** Wireless latency**\r\n\r\nYou may notice that the latency appears better than over the wired network. I believe this is because I ran the wireless tests when no one else was using the network, and the wired test during an active portion of the day.\r\n\r\n![latency-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/177746882-latency-Wireless-all.png)\r\n\r\n![latency-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/4212627213-latency-Wireless-small.png)\r\n\r\n![latency-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/3866951968-latency-Wireless-large.png)\r\n\r\n### Throughput\r\n\r\n** Intraprocess throughput**\r\n\r\n![throughput-Intraprocess-all.png](https://bitbucket.org/repo/og7EBq/images/2829676984-throughput-Intraprocess-all.png)\r\n\r\n![throughput-Intraprocess-small.png](https://bitbucket.org/repo/og7EBq/images/3933927565-throughput-Intraprocess-small.png)\r\n\r\n![throughput-Intraprocess-large.png](https://bitbucket.org/repo/og7EBq/images/3718225819-throughput-Intraprocess-large.png)\r\n\r\n** Interprocess throughput**\r\n\r\n![throughput-Interprocess-all.png](https://bitbucket.org/repo/og7EBq/images/3032255927-throughput-Interprocess-all.png)\r\n\r\n![throughput-Interprocess-small.png](https://bitbucket.org/repo/og7EBq/images/1568831296-throughput-Interprocess-small.png)\r\n\r\n![throughput-Interprocess-large.png](https://bitbucket.org/repo/og7EBq/images/4114343739-throughput-Interprocess-large.png)\r\n\r\n** Wired throughput**\r\n\r\n![throughput-Wired-all.png](https://bitbucket.org/repo/og7EBq/images/1229007404-throughput-Wired-all.png)\r\n\r\n![throughput-Wired-small.png](https://bitbucket.org/repo/og7EBq/images/3679643025-throughput-Wired-small.png)\r\n\r\n![throughput-Wired-large.png](https://bitbucket.org/repo/og7EBq/images/3619655927-throughput-Wired-large.png)\r\n\r\n** Wireless throughput**\r\n\r\n![throughput-Wireless-all.png](https://bitbucket.org/repo/og7EBq/images/365561471-throughput-Wireless-all.png)\r\n\r\n![throughput-Wireless-small.png](https://bitbucket.org/repo/og7EBq/images/2412795863-throughput-Wireless-small.png)\r\n\r\n![throughput-Wireless-large.png](https://bitbucket.org/repo/og7EBq/images/1670547079-throughput-Wireless-large.png)\r\n\r\n## Comparison\r\n\r\nI had no idea whether these results were good or bad. [This paper](https://dl.acm.org/citation.cfm?id=2968502) on ROS1 and ROS2 performance can be used as a point of comparison.", "title": "Benchmark", "destination": {"commit": {"hash": "b5e8dbef56ca", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/b5e8dbef56ca.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/b5e8dbef56ca"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "ign-transport4"}}, "reason": "", "source": {"commit": {"hash": "a1f20b2c3159", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/commit/a1f20b2c3159.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/commits/a1f20b2c3159"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "branch": {"name": "benchmark_nate"}}, "state": "OPEN", "author": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "date": "2017-09-26T23:08:05.440105+00:00"}, "pull_request": {"type": "pullrequest", "id": 225, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/pullrequests/225.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/pull-requests/225"}}, "title": "Benchmark"}}]}