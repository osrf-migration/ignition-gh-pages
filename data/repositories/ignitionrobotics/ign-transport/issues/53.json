{"priority": "minor", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "links": {"attachments": {"href": "data/repositories/ignitionrobotics/ign-transport/issues/53/attachments_page=1.json"}, "self": {"href": "data/repositories/ignitionrobotics/ign-transport/issues/53.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-transport/issues/53/watch"}, "comments": {"href": "data/repositories/ignitionrobotics/ign-transport/issues/53/comments_page=1.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/issues/53/call-to-exit-in-nodeshared"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-transport/issues/53/vote"}}, "reporter": {"display_name": "Rich Mattes", "uuid": "{1ef6f3dd-b8db-412b-94e9-e430e7aafd23}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B1ef6f3dd-b8db-412b-94e9-e430e7aafd23%7D"}, "html": {"href": "https://bitbucket.org/%7B1ef6f3dd-b8db-412b-94e9-e430e7aafd23%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/d431baafeedf5d8921cb50a3c9902e16d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsRM-0.png"}}, "nickname": "richmattes", "type": "user", "account_id": "557058:a38935e3-9a08-40d9-917a-ff19973e58df"}, "title": "Call to exit in NodeShared", "component": null, "votes": 0, "watches": 1, "content": {"raw": "We're working on including ignition-transport-1.2.0 in Fedora, and there were only two minor issues that came out of the package review. One of them is that `rpmlint` found a call to exit() in libignition-transport1.so.1.2.0.  `rpmlint`  has this to say about it:\r\n\r\n```\r\nThis library package calls exit() or _exit(), probably in a non-fork()\r\ncontext. Doing so from a library is strongly discouraged - when a library\r\nfunction calls exit(), it prevents the calling program from handling the\r\nerror, reporting it to the user, closing files properly, and cleaning up any\r\nstate that the program has. It is preferred for the library to return an\r\nactual error code and let the calling program decide how to handle the\r\nsituation.\r\n```\r\n\r\nThe exit call is in src/NodeShared.cc, and appears to happen when zeromq throws an exception when being initialized in the NodeShared constructor.  Other than passing the exception on to the caller, I can't think of a good way to handle it without moving away from RAII or giving NodeShared some kind of \"valid\" flag.", "markup": "markdown", "html": "<p>We're working on including ignition-transport-1.2.0 in Fedora, and there were only two minor issues that came out of the package review. One of them is that <code>rpmlint</code> found a call to exit() in libignition-transport1.so.1.2.0.  <code>rpmlint</code>  has this to say about it:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"nx\">This</span> <span class=\"nx\">library</span> <span class=\"kr\">package</span> <span class=\"nx\">calls</span> <span class=\"nx\">exit</span><span class=\"p\">()</span> <span class=\"nx\">or</span> <span class=\"nx\">_exit</span><span class=\"p\">(),</span> <span class=\"nx\">probably</span> <span class=\"k\">in</span> <span class=\"nx\">a</span> <span class=\"nx\">non</span><span class=\"o\">-</span><span class=\"nx\">fork</span><span class=\"p\">()</span>\n<span class=\"nx\">context</span><span class=\"p\">.</span> <span class=\"nx\">Doing</span> <span class=\"nx\">so</span> <span class=\"nx\">from</span> <span class=\"nx\">a</span> <span class=\"nx\">library</span> <span class=\"nx\">is</span> <span class=\"nx\">strongly</span> <span class=\"nx\">discouraged</span> <span class=\"o\">-</span> <span class=\"nx\">when</span> <span class=\"nx\">a</span> <span class=\"nx\">library</span>\n<span class=\"kd\">function</span> <span class=\"nx\">calls</span> <span class=\"nx\">exit</span><span class=\"p\">(),</span> <span class=\"nx\">it</span> <span class=\"nx\">prevents</span> <span class=\"nx\">the</span> <span class=\"nx\">calling</span> <span class=\"nx\">program</span> <span class=\"nx\">from</span> <span class=\"nx\">handling</span> <span class=\"nx\">the</span>\n<span class=\"nx\">error</span><span class=\"p\">,</span> <span class=\"nx\">reporting</span> <span class=\"nx\">it</span> <span class=\"nx\">to</span> <span class=\"nx\">the</span> <span class=\"nx\">user</span><span class=\"p\">,</span> <span class=\"nx\">closing</span> <span class=\"nx\">files</span> <span class=\"nx\">properly</span><span class=\"p\">,</span> <span class=\"nx\">and</span> <span class=\"nx\">cleaning</span> <span class=\"nx\">up</span> <span class=\"nx\">any</span>\n<span class=\"nx\">state</span> <span class=\"nx\">that</span> <span class=\"nx\">the</span> <span class=\"nx\">program</span> <span class=\"nx\">has</span><span class=\"p\">.</span> <span class=\"nx\">It</span> <span class=\"nx\">is</span> <span class=\"nx\">preferred</span> <span class=\"k\">for</span> <span class=\"nx\">the</span> <span class=\"nx\">library</span> <span class=\"nx\">to</span> <span class=\"k\">return</span> <span class=\"nx\">an</span>\n<span class=\"nx\">actual</span> <span class=\"nx\">error</span> <span class=\"nx\">code</span> <span class=\"nx\">and</span> <span class=\"kd\">let</span> <span class=\"nx\">the</span> <span class=\"nx\">calling</span> <span class=\"nx\">program</span> <span class=\"nx\">decide</span> <span class=\"nx\">how</span> <span class=\"nx\">to</span> <span class=\"nx\">handle</span> <span class=\"nx\">the</span>\n<span class=\"nx\">situation</span><span class=\"p\">.</span>\n</pre></div>\n\n\n<p>The exit call is in src/NodeShared.cc, and appears to happen when zeromq throws an exception when being initialized in the NodeShared constructor.  Other than passing the exception on to the caller, I can't think of a good way to handle it without moving away from RAII or giving NodeShared some kind of \"valid\" flag.</p>", "type": "rendered"}, "assignee": null, "state": "resolved", "version": null, "edited_on": null, "created_on": "2016-07-13T23:09:22.603231+00:00", "milestone": null, "updated_on": "2016-08-03T16:46:41.295064+00:00", "type": "issue", "id": 53}