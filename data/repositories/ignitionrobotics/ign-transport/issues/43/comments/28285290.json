{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/issues/43/comments/28285290.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/issues/43#comment-28285290"}}, "issue": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport/issues/43.json"}}, "type": "issue", "id": 43, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "title": "Restrict maximum topic length"}, "content": {"raw": "Checking the return value looks like a good expectation to me. If the topic exceeds the maximum length we should expect a `0`, otherwise a value greater than `0`.\n\nI understand that right now you can create a `SubscriptionMessage` (for example) with a large topic, call to `Pack()`, and then, check that `Unpack()` returns `0`. However, at some point we will prevent to create a `SubscriptionMessage` with a large topic, so this test won't work in the future. I'd suggest to test `Unpack()` with a valid `SubscriptionMessage`, call `Pack()`, and then, manually modify the `topicLength` field in the serialized data. E.g.:\n\nSerialize a valid `SubscriptionMessage`:\n\n```\n#!c++\n\n// Pack a SubscriptionMsg.\nSubscriptionMsg subMsg(otherHeader, topic);\nbuffer.resize(subMsg.MsgLength());\nbytes = subMsg.Pack(&buffer[0]);\nEXPECT_EQ(bytes, subMsg.MsgLength());\n\n```\n\nManually modify the `topicLength` field of the serialized `SubscriptionMsg` before calling `Unpack()`:\n\n\n```\n#!c++\n\n// Unpack a SubscriptionMsg with a long topic.\nSubscriptionMsg otherSubMsg;\nheaderBytes = header.Unpack(&buffer[0]);\nEXPECT_EQ(headerBytes, static_cast<size_t>(header.HeaderLength()));\notherSubMsg.SetHeader(header);\npBody = &buffer[0] + header.HeaderLength();\n\n// Set the topic length to an illegal value.\nuint64_t topicLength = maxTopicLength + 1;\nmemcpy(pBody, &topicLength, sizeof(topicLength));\n\nEXPECT_EQ(otherSubMsg.Unpack(pBody), 0u);\n```\n", "markup": "markdown", "html": "<p>Checking the return value looks like a good expectation to me. If the topic exceeds the maximum length we should expect a <code>0</code>, otherwise a value greater than <code>0</code>.</p>\n<p>I understand that right now you can create a <code>SubscriptionMessage</code> (for example) with a large topic, call to <code>Pack()</code>, and then, check that <code>Unpack()</code> returns <code>0</code>. However, at some point we will prevent to create a <code>SubscriptionMessage</code> with a large topic, so this test won't work in the future. I'd suggest to test <code>Unpack()</code> with a valid <code>SubscriptionMessage</code>, call <code>Pack()</code>, and then, manually modify the <code>topicLength</code> field in the serialized data. E.g.:</p>\n<p>Serialize a valid <code>SubscriptionMessage</code>:</p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"c1\">// Pack a SubscriptionMsg.</span>\n<span class=\"n\">SubscriptionMsg</span> <span class=\"nf\">subMsg</span><span class=\"p\">(</span><span class=\"n\">otherHeader</span><span class=\"p\">,</span> <span class=\"n\">topic</span><span class=\"p\">);</span>\n<span class=\"n\">buffer</span><span class=\"p\">.</span><span class=\"n\">resize</span><span class=\"p\">(</span><span class=\"n\">subMsg</span><span class=\"p\">.</span><span class=\"n\">MsgLength</span><span class=\"p\">());</span>\n<span class=\"n\">bytes</span> <span class=\"o\">=</span> <span class=\"n\">subMsg</span><span class=\"p\">.</span><span class=\"n\">Pack</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]);</span>\n<span class=\"n\">EXPECT_EQ</span><span class=\"p\">(</span><span class=\"n\">bytes</span><span class=\"p\">,</span> <span class=\"n\">subMsg</span><span class=\"p\">.</span><span class=\"n\">MsgLength</span><span class=\"p\">());</span>\n</pre></div>\n\n\n<p>Manually modify the <code>topicLength</code> field of the serialized <code>SubscriptionMsg</code> before calling <code>Unpack()</code>:</p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"c1\">// Unpack a SubscriptionMsg with a long topic.</span>\n<span class=\"n\">SubscriptionMsg</span> <span class=\"n\">otherSubMsg</span><span class=\"p\">;</span>\n<span class=\"n\">headerBytes</span> <span class=\"o\">=</span> <span class=\"n\">header</span><span class=\"p\">.</span><span class=\"n\">Unpack</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]);</span>\n<span class=\"n\">EXPECT_EQ</span><span class=\"p\">(</span><span class=\"n\">headerBytes</span><span class=\"p\">,</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"kt\">size_t</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">header</span><span class=\"p\">.</span><span class=\"n\">HeaderLength</span><span class=\"p\">()));</span>\n<span class=\"n\">otherSubMsg</span><span class=\"p\">.</span><span class=\"n\">SetHeader</span><span class=\"p\">(</span><span class=\"n\">header</span><span class=\"p\">);</span>\n<span class=\"n\">pBody</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">header</span><span class=\"p\">.</span><span class=\"n\">HeaderLength</span><span class=\"p\">();</span>\n\n<span class=\"c1\">// Set the topic length to an illegal value.</span>\n<span class=\"kt\">uint64_t</span> <span class=\"n\">topicLength</span> <span class=\"o\">=</span> <span class=\"n\">maxTopicLength</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"n\">pBody</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">topicLength</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">topicLength</span><span class=\"p\">));</span>\n\n<span class=\"n\">EXPECT_EQ</span><span class=\"p\">(</span><span class=\"n\">otherSubMsg</span><span class=\"p\">.</span><span class=\"n\">Unpack</span><span class=\"p\">(</span><span class=\"n\">pBody</span><span class=\"p\">),</span> <span class=\"mi\">0u</span><span class=\"p\">);</span>\n</pre></div>", "type": "rendered"}, "created_on": "2016-06-05T17:53:36.989077+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "updated_on": "2016-06-05T22:04:24.375768+00:00", "type": "issue_comment", "id": 28285290}