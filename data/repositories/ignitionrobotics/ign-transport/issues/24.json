{"priority": "minor", "kind": "proposal", "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-transport.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport"}, "avatar": {"href": "data/bytebucket.org/ravatar/{4249390a-7f55-404b-990d-817ba94cc7ac}ts=1533306"}}, "type": "repository", "name": "ign-transport", "full_name": "ignitionrobotics/ign-transport", "uuid": "{4249390a-7f55-404b-990d-817ba94cc7ac}"}, "links": {"attachments": {"href": "data/repositories/ignitionrobotics/ign-transport/issues/24/attachments_page=1.json"}, "self": {"href": "data/repositories/ignitionrobotics/ign-transport/issues/24.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-transport/issues/24/watch"}, "comments": {"href": "data/repositories/ignitionrobotics/ign-transport/issues/24/comments_page=1.json"}, "html": {"href": "#!/ignitionrobotics/ign-transport/issues/24/circular-buffers"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-transport/issues/24/vote"}}, "reporter": {"display_name": "Andrew Hundt", "uuid": "{1e508588-c010-4693-87e5-4923df91390d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B1e508588-c010-4693-87e5-4923df91390d%7D"}, "html": {"href": "https://bitbucket.org/%7B1e508588-c010-4693-87e5-4923df91390d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fb975596131ce08ea7e7472f09b8209dd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsAH-1.png"}}, "nickname": "ahundt", "type": "user", "account_id": "557058:f565cbf4-e097-4b3f-b4db-4889856f7417"}, "title": "Circular Buffers", "component": null, "votes": 0, "watches": 1, "content": {"raw": "One key element for communication in robotics applications that I have substantial experience with is the use of circular buffers rather than queues when processing messages. Typically the latest sensor data coming in matters more than the oldest, so if you can only process half the images or laser scans, the most recent are more important. \r\n\r\nA circular buffer facilitates this by automatically dropping data that is too old to matter. Additionally it has the side effect that it becomes impossible for the data to fill up all of the memory and cause a crash, which is something that is very possible with a queue. \r\n\r\nThis is a field tested technique that has been proven crucial across several generations of high performance robots developed for multiple commercial customers.  \r\n\r\nHere are a couple pages with images I found that illustrate the idea. The linked library is not actually something you would want to utilize because it appears to be a Java library. Nonetheless, the images are useful to convey the point.\r\n\r\nhttps://fabric3.atlassian.net/wiki/display/FABRIC/Ring+Buffer+%28Disruptor%29+Channels\r\n\r\nhttps://fabric3.atlassian.net/wiki/display/FABRIC/ZeroMQ+and+Ring+Buffer+(Disruptor)+Channels\r\n\r\n\r\nThe fundamentals of the system you are implementing look amazing at a high level. However circular buffers, a higher performance protocol, and prioritization are killer features for a system that can span beyond research projects into high performance commercial products on inexpensive hardware. ", "markup": "markdown", "html": "<p>One key element for communication in robotics applications that I have substantial experience with is the use of circular buffers rather than queues when processing messages. Typically the latest sensor data coming in matters more than the oldest, so if you can only process half the images or laser scans, the most recent are more important. </p>\n<p>A circular buffer facilitates this by automatically dropping data that is too old to matter. Additionally it has the side effect that it becomes impossible for the data to fill up all of the memory and cause a crash, which is something that is very possible with a queue. </p>\n<p>This is a field tested technique that has been proven crucial across several generations of high performance robots developed for multiple commercial customers.  </p>\n<p>Here are a couple pages with images I found that illustrate the idea. The linked library is not actually something you would want to utilize because it appears to be a Java library. Nonetheless, the images are useful to convey the point.</p>\n<p><a href=\"https://fabric3.atlassian.net/wiki/display/FABRIC/Ring+Buffer+%28Disruptor%29+Channels\" rel=\"nofollow\" class=\"ap-connect-link\">https://fabric3.atlassian.net/wiki/display/FABRIC/Ring+Buffer+%28Disruptor%29+Channels</a></p>\n<p><a href=\"https://fabric3.atlassian.net/wiki/display/FABRIC/ZeroMQ+and+Ring+Buffer+(Disruptor)+Channels\" rel=\"nofollow\" class=\"ap-connect-link\">https://fabric3.atlassian.net/wiki/display/FABRIC/ZeroMQ+and+Ring+Buffer+(Disruptor)+Channels</a></p>\n<p>The fundamentals of the system you are implementing look amazing at a high level. However circular buffers, a higher performance protocol, and prioritization are killer features for a system that can span beyond research projects into high performance commercial products on inexpensive hardware. </p>", "type": "rendered"}, "assignee": null, "state": "new", "version": null, "edited_on": null, "created_on": "2015-01-20T07:17:32.137818+00:00", "milestone": null, "updated_on": "2015-01-20T07:23:02.658346+00:00", "type": "issue", "id": 24}