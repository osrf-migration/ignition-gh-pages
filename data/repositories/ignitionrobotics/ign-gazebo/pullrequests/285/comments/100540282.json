{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/285/comments/100540282.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/285/_/diff#comment-100540282"}}, "parent": {"id": 100536056, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/285/comments/100536056.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/285/_/diff#comment-100536056"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 285, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/285.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/285"}}, "title": "[Blueprint] Entity tree UI"}, "content": {"raw": "tl;dr there may not be a way to do it from cmake without much hacking. We could try detecting it in C++ and printing a runtime error that is more informative than the one Qt is printing.\n\n---\n\nI couldn't find a straightforward way of doing this. The qml modules themselves install very little:\n\n~~~\n$ dpkg-query -L qml-module-qtqml-models2\n/.\n/usr\n/usr/lib\n/usr/lib/x86_64-linux-gnu\n/usr/lib/x86_64-linux-gnu/qt5\n/usr/lib/x86_64-linux-gnu/qt5/qml\n/usr/lib/x86_64-linux-gnu/qt5/qml/QtQml\n/usr/lib/x86_64-linux-gnu/qt5/qml/QtQml/Models.2\n/usr/lib/x86_64-linux-gnu/qt5/qml/QtQml/Models.2/libmodelsplugin.so\n/usr/lib/x86_64-linux-gnu/qt5/qml/QtQml/Models.2/plugins.qmltypes\n/usr/lib/x86_64-linux-gnu/qt5/qml/QtQml/Models.2/qmldir\n/usr/share\n/usr/share/doc\n/usr/share/doc/qml-module-qtqml-models2\n/usr/share/doc/qml-module-qtqml-models2/copyright\n/usr/share/doc/qml-module-qtqml-models2/changelog.Debian.gz\n~~~\n\nQt is crawling the `/usr/lib/x86_64-linux-gnu/qt5/qml` directory to find modules when importing. I found a way to get that path from C++ like this:\n\n~~~\ndiff -r 969dce894062 src/gui/plugins/EntityTree.cc\n--- a/src/gui/plugins/EntityTree.cc     Mon Apr 29 18:21:07 2019 -0700\n+++ b/src/gui/plugins/EntityTree.cc     Tue Apr 30 17:07:44 2019 -0700\n@@ -124,6 +124,10 @@\n EntityTree::EntityTree()\n   : GuiSystem(), dataPtr(std::make_unique<EntityTreePrivate>())\n {\n+  auto paths = gui::App()->Engine()->importPathList();\n+  for (auto p : paths)\n+    igndbg << p.toStdString() << std::endl;\n+\n   // Connect model\n   gui::App()->Engine()->rootContext()->setContextProperty(\"EntityTreeModel\",\n       &this->dataPtr->treeModel);\n~~~\n\nwhich prints this:\n\n~~~\n[GUI] [Dbg] [EntityTree.cc:129] /home/developer/ws/install/ignition-gazebo2/bin\n[GUI] [Dbg] [EntityTree.cc:129] qrc:/qt-project.org/imports\n[GUI] [Dbg] [EntityTree.cc:129] /usr/lib/x86_64-linux-gnu/qt5/qml\n~~~\n\nI didn't figure out how to get the same path from cmake, it's possible that it's only available at runtime. We should be able to append paths with cmake though, setting the `QML_IMPORT_PATH` variable.\n\nBut getting the path is just the first step, as we'd have to crawl the directory looking for what we need. That may be a bad idea. In any case, [this page](https://doc.qt.io/qt-5/qtqml-syntax-imports.html#qml-import-path) has some helpful info on how QML searches for imports. A handy trick is using the `QML_IMPORT_TRACE` env var for debugging.\n\nAnother possible runtime solution could be trying to use [QQmlImports::resolveType](https://code.woboq.org/qt5/qtdeclarative/src/qml/qml/qqmlimport_p.h.html#_ZNK11QQmlImports11resolveTypeERK16QHashedStringRefP8QQmlTypePiS5_PP19QQmlImportNamespaceP5QListI9QQmlErrorENS3_16RegistrationTypeEN10QQmlImport20RecursionRestrictionE), but the lack of official documentation for that class is a bad sign.\n\n\n\n", "markup": "markdown", "html": "<p>tl;dr there may not be a way to do it from cmake without much hacking. We could try detecting it in C++ and printing a runtime error that is more informative than the one Qt is printing.</p>\n<hr />\n<p>I couldn't find a straightforward way of doing this. The qml modules themselves install very little:</p>\n<div class=\"codehilite\"><pre><span></span>$ dpkg-query -L qml-module-qtqml-models2\n/.\n/usr\n/usr/lib\n/usr/lib/x86_64-linux-gnu\n/usr/lib/x86_64-linux-gnu/qt5\n/usr/lib/x86_64-linux-gnu/qt5/qml\n/usr/lib/x86_64-linux-gnu/qt5/qml/QtQml\n/usr/lib/x86_64-linux-gnu/qt5/qml/QtQml/Models.2\n/usr/lib/x86_64-linux-gnu/qt5/qml/QtQml/Models.2/libmodelsplugin.so\n/usr/lib/x86_64-linux-gnu/qt5/qml/QtQml/Models.2/plugins.qmltypes\n/usr/lib/x86_64-linux-gnu/qt5/qml/QtQml/Models.2/qmldir\n/usr/share\n/usr/share/doc\n/usr/share/doc/qml-module-qtqml-models2\n/usr/share/doc/qml-module-qtqml-models2/copyright\n/usr/share/doc/qml-module-qtqml-models2/changelog.Debian.gz\n</pre></div>\n\n\n<p>Qt is crawling the <code>/usr/lib/x86_64-linux-gnu/qt5/qml</code> directory to find modules when importing. I found a way to get that path from C++ like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"gh\">diff -r 969dce894062 src/gui/plugins/EntityTree.cc</span>\n<span class=\"gd\">--- a/src/gui/plugins/EntityTree.cc     Mon Apr 29 18:21:07 2019 -0700</span>\n<span class=\"gi\">+++ b/src/gui/plugins/EntityTree.cc     Tue Apr 30 17:07:44 2019 -0700</span>\n<span class=\"gu\">@@ -124,6 +124,10 @@</span>\n EntityTree::EntityTree()\n   : GuiSystem(), dataPtr(std::make_unique&lt;EntityTreePrivate&gt;())\n {\n<span class=\"gi\">+  auto paths = gui::App()-&gt;Engine()-&gt;importPathList();</span>\n<span class=\"gi\">+  for (auto p : paths)</span>\n<span class=\"gi\">+    igndbg &lt;&lt; p.toStdString() &lt;&lt; std::endl;</span>\n<span class=\"gi\">+</span>\n   // Connect model\n   gui::App()-&gt;Engine()-&gt;rootContext()-&gt;setContextProperty(&quot;EntityTreeModel&quot;,\n       &amp;this-&gt;dataPtr-&gt;treeModel);\n</pre></div>\n\n\n<p>which prints this:</p>\n<div class=\"codehilite\"><pre><span></span>[GUI] [Dbg] [EntityTree.cc:129] /home/developer/ws/install/ignition-gazebo2/bin\n[GUI] [Dbg] [EntityTree.cc:129] qrc:/qt-project.org/imports\n[GUI] [Dbg] [EntityTree.cc:129] /usr/lib/x86_64-linux-gnu/qt5/qml\n</pre></div>\n\n\n<p>I didn't figure out how to get the same path from cmake, it's possible that it's only available at runtime. We should be able to append paths with cmake though, setting the <code>QML_IMPORT_PATH</code> variable.</p>\n<p>But getting the path is just the first step, as we'd have to crawl the directory looking for what we need. That may be a bad idea. In any case, <a data-is-external-link=\"true\" href=\"https://doc.qt.io/qt-5/qtqml-syntax-imports.html#qml-import-path\" rel=\"nofollow\">this page</a> has some helpful info on how QML searches for imports. A handy trick is using the <code>QML_IMPORT_TRACE</code> env var for debugging.</p>\n<p>Another possible runtime solution could be trying to use <a data-is-external-link=\"true\" href=\"https://code.woboq.org/qt5/qtdeclarative/src/qml/qml/qqmlimport_p.h.html#_ZNK11QQmlImports11resolveTypeERK16QHashedStringRefP8QQmlTypePiS5_PP19QQmlImportNamespaceP5QListI9QQmlErrorENS3_16RegistrationTypeEN10QQmlImport20RecursionRestrictionE\" rel=\"nofollow\">QQmlImports::resolveType</a>, but the lack of official documentation for that class is a bad sign.</p>", "type": "rendered"}, "created_on": "2019-05-01T00:29:20.524387+00:00", "user": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}, "updated_on": "2019-05-01T00:29:20.536388+00:00", "type": "pullrequest_comment", "id": 100540282}