{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72562102.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72562102"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "@mxgrey Can you give me a sanity check if this is how you inteded `ign-plugin` to be used?", "markup": "markdown", "html": "<p>@mxgrey Can you give me a sanity check if this is how you inteded <code>ign-plugin</code> to be used?</p>", "type": "rendered"}, "created_on": "2018-08-09T22:16:02.360228+00:00", "user": {"display_name": "Michael Carroll", "uuid": "{17dbbc15-cbc0-42f0-a985-cde9061c78a0}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D"}, "html": {"href": "https://bitbucket.org/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:65740f22-cc56-4418-9608-7e17d0ed47b7/2aa259f5-4de1-4f68-9156-eded72041d84/128"}}, "nickname": "Michael Carroll", "type": "user", "account_id": "557058:65740f22-cc56-4418-9608-7e17d0ed47b7"}, "updated_on": "2018-08-09T22:16:02.393615+00:00", "type": "pullrequest_comment", "id": 72562102}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72562234.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72562234"}}, "parent": {"id": 72562102, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72562102.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72562102"}}, "depth": 1}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "Well, I just found your PR, let me update this accordingly.", "markup": "markdown", "html": "<p>Well, I just found your PR, let me update this accordingly.</p>", "type": "rendered"}, "created_on": "2018-08-09T22:18:25.018274+00:00", "user": {"display_name": "Michael Carroll", "uuid": "{17dbbc15-cbc0-42f0-a985-cde9061c78a0}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D"}, "html": {"href": "https://bitbucket.org/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:65740f22-cc56-4418-9608-7e17d0ed47b7/2aa259f5-4de1-4f68-9156-eded72041d84/128"}}, "nickname": "Michael Carroll", "type": "user", "account_id": "557058:65740f22-cc56-4418-9608-7e17d0ed47b7"}, "updated_on": "2018-08-09T22:18:25.026282+00:00", "type": "pullrequest_comment", "id": 72562234}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72562126.json"}, "code": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-gazebo/diff/ignitionrobotics/ign-gazebo:b454d2e1c19d..9e0ab5d62e8b?path=include%2Fignition%2Fgazebo%2FSystem.hh"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72562126"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "This is a rough list for now, we can flesh it out or change how this is managed in the System plugins.", "markup": "markdown", "html": "<p>This is a rough list for now, we can flesh it out or change how this is managed in the System plugins.</p>", "type": "rendered"}, "created_on": "2018-08-09T22:16:23.812302+00:00", "user": {"display_name": "Michael Carroll", "uuid": "{17dbbc15-cbc0-42f0-a985-cde9061c78a0}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D"}, "html": {"href": "https://bitbucket.org/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:65740f22-cc56-4418-9608-7e17d0ed47b7/2aa259f5-4de1-4f68-9156-eded72041d84/128"}}, "nickname": "Michael Carroll", "type": "user", "account_id": "557058:65740f22-cc56-4418-9608-7e17d0ed47b7"}, "inline": {"to": 38, "from": null, "path": "include/ignition/gazebo/System.hh"}, "updated_on": "2018-08-09T22:16:23.818635+00:00", "type": "pullrequest_comment", "id": 72562126}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72562160.json"}, "code": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-gazebo/diff/ignitionrobotics/ign-gazebo:b454d2e1c19d..9e0ab5d62e8b?path=src%2FSystemPluginManager.cc"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72562160"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "@mxgrey Is there some other registration information that we could add so that we wouldn\u2019t have to instantiate to check the system type?", "markup": "markdown", "html": "<p>@mxgrey Is there some other registration information that we could add so that we wouldn\u2019t have to instantiate to check the system type?</p>", "type": "rendered"}, "created_on": "2018-08-09T22:17:00.982744+00:00", "user": {"display_name": "Michael Carroll", "uuid": "{17dbbc15-cbc0-42f0-a985-cde9061c78a0}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D"}, "html": {"href": "https://bitbucket.org/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:65740f22-cc56-4418-9608-7e17d0ed47b7/2aa259f5-4de1-4f68-9156-eded72041d84/128"}}, "nickname": "Michael Carroll", "type": "user", "account_id": "557058:65740f22-cc56-4418-9608-7e17d0ed47b7"}, "inline": {"to": 73, "from": null, "path": "src/SystemPluginManager.cc"}, "updated_on": "2018-08-09T22:17:00.997031+00:00", "type": "pullrequest_comment", "id": 72562160}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72595478.json"}, "code": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-gazebo/diff/ignitionrobotics/ign-gazebo:b454d2e1c19d..9e0ab5d62e8b?path=src%2FSystemPluginManager.cc"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72595478"}}, "parent": {"id": 72562160, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72562160.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72562160"}}, "depth": 1}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "It seems right now the current concept of a \"system type\" is determined during runtime, and is even able to change for any given `System` instance during runtime.\n\nPlugin registration happens at compile time, so right now there\u2019s a conceptual issue with trying to identify the \u201csystem type\u201d of a plugin before loading it.\n\nI've started implementing the ability to give plugins \"aliases\" \\(or we could call them \"labels\" instead if anyone would prefer\\), which could accomplish what you're looking for here. But I do have some higher level concerns about the `System` interface that I\u2019ll try to articulate in a comment on the main thread.", "markup": "markdown", "html": "<p>It seems right now the current concept of a \"system type\" is determined during runtime, and is even able to change for any given <code>System</code> instance during runtime.</p>\n<p>Plugin registration happens at compile time, so right now there\u2019s a conceptual issue with trying to identify the \u201csystem type\u201d of a plugin before loading it.</p>\n<p>I've started implementing the ability to give plugins \"aliases\" (or we could call them \"labels\" instead if anyone would prefer), which could accomplish what you're looking for here. But I do have some higher level concerns about the <code>System</code> interface that I\u2019ll try to articulate in a comment on the main thread.</p>", "type": "rendered"}, "created_on": "2018-08-10T08:22:22.376276+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {"to": null, "from": null, "path": "src/SystemPluginManager.cc"}, "updated_on": "2018-08-10T08:22:22.386712+00:00", "type": "pullrequest_comment", "id": 72595478}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72589285.json"}, "code": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-gazebo/diff/ignitionrobotics/ign-gazebo:b454d2e1c19d..9e0ab5d62e8b?path=CMakeLists.txt"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72589285"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "Instead you can do\n\n    ign_find_package(ignition-plugin0 REQUIRED COMPONENTS loader)\n\nand then leave out the next line.", "markup": "markdown", "html": "<p>Instead you can do</p>\n<div class=\"codehilite\"><pre><span></span>ign_find_package(ignition-plugin0 REQUIRED COMPONENTS loader)\n</pre></div>\n\n\n<p>and then leave out the next line.</p>", "type": "rendered"}, "created_on": "2018-08-10T07:30:54.939647+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {"to": 34, "from": null, "path": "CMakeLists.txt"}, "updated_on": "2018-08-10T07:30:54.948713+00:00", "type": "pullrequest_comment", "id": 72589285}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72592868.json"}, "code": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-gazebo/diff/ignitionrobotics/ign-gazebo:b454d2e1c19d..9e0ab5d62e8b?path=include%2Fignition%2Fgazebo%2FSystem.hh"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72592868"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "Is the system type really something that we want to be able to change publicly? Presumably this is something that would be determined by the underlying implementation of the `System`, and not something that could be modified externally \\(or perhaps ever\\).\n\nSince this seems to be an interface class that's meant to be inherited by plugins, I would very strongly recommend that we make the `Name()`, `SystemType()`, and `Init(~)` functions pure virtual and do not have any `dataPtr` PIMPL object. That also means getting rid of the constructor. Inheriting a PIMPL class typically does not work well.", "markup": "markdown", "html": "<p>Is the system type really something that we want to be able to change publicly? Presumably this is something that would be determined by the underlying implementation of the <code>System</code>, and not something that could be modified externally (or perhaps ever).</p>\n<p>Since this seems to be an interface class that's meant to be inherited by plugins, I would very strongly recommend that we make the <code>Name()</code>, <code>SystemType()</code>, and <code>Init(~)</code> functions pure virtual and do not have any <code>dataPtr</code> PIMPL object. That also means getting rid of the constructor. Inheriting a PIMPL class typically does not work well.</p>", "type": "rendered"}, "created_on": "2018-08-10T08:00:31.421601+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {"to": 75, "from": null, "path": "include/ignition/gazebo/System.hh"}, "updated_on": "2018-08-10T08:01:50.563978+00:00", "type": "pullrequest_comment", "id": 72592868}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72597871.json"}, "code": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-gazebo/diff/ignitionrobotics/ign-gazebo:b454d2e1c19d..9e0ab5d62e8b?path=include%2Fignition%2Fgazebo%2FSystem.hh"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72597871"}}, "parent": {"id": 72592868, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72592868.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72592868"}}, "depth": 1}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "Follow-up: after looking at the code a little more, it seems like this class is actually meant to be inherited by internal classes, e.g. `PhysicsSystem`, rather than being inherited by plugins.\n\nEven so, I would still recommend pure virtual functions instead of inheriting a PIMPL class.", "markup": "markdown", "html": "<p>Follow-up: after looking at the code a little more, it seems like this class is actually meant to be inherited by internal classes, e.g. <code>PhysicsSystem</code>, rather than being inherited by plugins.</p>\n<p>Even so, I would still recommend pure virtual functions instead of inheriting a PIMPL class.</p>", "type": "rendered"}, "created_on": "2018-08-10T08:40:22.373244+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {"to": null, "from": null, "path": "include/ignition/gazebo/System.hh"}, "updated_on": "2018-08-10T08:40:22.381945+00:00", "type": "pullrequest_comment", "id": 72597871}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72610483.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72610483"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "Based on what I'm seeing of the ECS implementation here in `ign-gazebo`, I don't think the `System` class should be the \"entry point\" \\(so to speak\\) interface for the plugins that are being coordinated by `ign-gazebo`. And an enumeration is not what I\u2019d recommend for distinguishing between different plugin types, but that\u2019s a somewhat orthogonal \\(and probably much less important\\) matter.\n\nUsing the `System` class as the interface for plugging in different systems results in a critical dependency issue. `ign-gazebo` is meant to be dependent on the various upstream ignition libraries \\(e.g. `ign-gui`, `ign-rendering`, `ign-physics`\\) while those other libraries shouldn't have any dependency on `ign-gazebo`. If the `ignition::gazebo::System` class is meant to be the interface class for speaking to the various system plugins, then those plugins will need to depend on `ign-gazebo` in order to inherit and expose the `ignition::gazebo::System` class. That means the packages providing the plugins \\(i.e. `ign-gui`, `ign-rendering`, `ign-physics`\\) will need to depend on `ign-gazebo`, leaving us with circular dependencies.\n\nInstead, it looks to me like the `System` class is a base class for other `ign-gazebo` system classes, each of which will be responsible for interfacing with the plugins that are provided by the upstream ignition libraries. Currently it looks like only `ignition::gazebo::PhysicsSystem` exists, but we could also create `ignition::gazebo::GuiSystem`, `ignition::gazebo::RenderSystem`, `ignition::gazebo::LogSystem`, etc.\n\nThose more-derived System classes should be responsible for knowing what interfaces to use from each library that they're designed to interface with. So instead of asking the `System` interface for what its type is, I would recommend something more like this \\(this is conceptual code, so some details might be missing and style might be lazy\\):\n\n    class System\n    {\n    public:\n    \n      // Tell this system which plugin to use\n      // Returns false if the plugin doesn't have the interface(s) needed by this system\n      virtual bool UsePlugin(const ignition::plugin::PluginPtr &_plugin) = 0;\n    \n      // Initialize the system\n      // Note: maybe this should be combined with UsePlugin, e.g.:\n      // virtual void Init(const ignition::plugin::PluginPtr &_plugin, EntityQueryRegistrar &_register) = 0;\n      // That might depend on how/if we want to support hotswapping of system plugins.\n      virtual void Init(EntityQueryRegistrar &_register) = 0;\n    \n      // Identify usable plugins. Feel free to change this function name.\n      virtual std::set<std::string> IdentifyPlugins(const ignition::plugin::Loader &_loader) const = 0;\n    \n      // I would recommend a string for describing system types, since I expect this information\n      // is most relevant to humans using the Gazebo application. That also doesn't lock us in to\n      // a specific set of System types.\n      virtual std::string SystemType() const = 0;\n    };\n\nEach different `System` type, \\(e.g. `PhysicsSystem`, `RenderSystem`, `GuiSystem`, `LogSystem`\\) would only be instantiated once at startup and put into the `SystemManager` \\(or maybe `SystemPluginManager` if that's what we want to call it\\). To discover the relevant plugins for each type of system, the `SystemManager` would call the `IdentifyPlugins(~)` function on the system of interest, passing in the `ignition::plugin::Loader` instance that has already been filled with libraries. The `IdentifyPlugins(~)` function would then pass back a set of the names of the plugins within the loader that have the necessary interface\\(s\\).\n\nIn order to create a basic prototype skeleton, you could consider creating barebones `RenderSystem` and `GuiSystem` classes. I don't know if `ign-rendering` or `ign-gui` has any plugin interfaces to query for, although I do believe that `ign-gui` has been using the plugin system for a while now, so `ign-gui` might have some good interfaces for the `GuiSystem` to \"depend\" on \\(if only for testing purposes\\). But `ign-gui` will need to be updated to the [NewRegistrationScheme](#!/ignitionrobotics/ign-plugin/pull-requests/2) branch of `ign-plugin` to work with this PR.\n\nFor the `PhysicsSystem`, you could consider testing against the [sdf\\_component](#!/ignitionrobotics/ign-physics/pull-requests/29) branch of `ign-physics` and use the `ForwardStep` class as the \"necessary interface\" for `PhysicsSystem` plugins. However, you'd have to use something like: `_loader.PluginsImplementing<ignition::physics::ForwardStep::Implementation<ignition::physics::FeaturePolicy3d>>()` to check for that interface which is kind of gross. Some time soon I'll make some `ign-physics` utilities to make it easier to look for plugins that match a set of features. Note that the `sdf_component` branch is still a WIP, so I haven't done any tests on loading its `ignition-physics0-dartsim` plugin yet.\n\nI apologize for the wall of text, but please let me know if anything I said was confusing or unclear in any way.", "markup": "markdown", "html": "<p>Based on what I'm seeing of the ECS implementation here in <code>ign-gazebo</code>, I don't think the <code>System</code> class should be the \"entry point\" (so to speak) interface for the plugins that are being coordinated by <code>ign-gazebo</code>. And an enumeration is not what I\u2019d recommend for distinguishing between different plugin types, but that\u2019s a somewhat orthogonal (and probably much less important) matter.</p>\n<p>Using the <code>System</code> class as the interface for plugging in different systems results in a critical dependency issue. <code>ign-gazebo</code> is meant to be dependent on the various upstream ignition libraries (e.g. <code>ign-gui</code>, <code>ign-rendering</code>, <code>ign-physics</code>) while those other libraries shouldn't have any dependency on <code>ign-gazebo</code>. If the <code>ignition::gazebo::System</code> class is meant to be the interface class for speaking to the various system plugins, then those plugins will need to depend on <code>ign-gazebo</code> in order to inherit and expose the <code>ignition::gazebo::System</code> class. That means the packages providing the plugins (i.e. <code>ign-gui</code>, <code>ign-rendering</code>, <code>ign-physics</code>) will need to depend on <code>ign-gazebo</code>, leaving us with circular dependencies.</p>\n<p>Instead, it looks to me like the <code>System</code> class is a base class for other <code>ign-gazebo</code> system classes, each of which will be responsible for interfacing with the plugins that are provided by the upstream ignition libraries. Currently it looks like only <code>ignition::gazebo::PhysicsSystem</code> exists, but we could also create <code>ignition::gazebo::GuiSystem</code>, <code>ignition::gazebo::RenderSystem</code>, <code>ignition::gazebo::LogSystem</code>, etc.</p>\n<p>Those more-derived System classes should be responsible for knowing what interfaces to use from each library that they're designed to interface with. So instead of asking the <code>System</code> interface for what its type is, I would recommend something more like this (this is conceptual code, so some details might be missing and style might be lazy):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kr\">class</span> <span class=\"nx\">System</span>\n<span class=\"p\">{</span>\n<span class=\"kr\">public</span><span class=\"o\">:</span>\n\n  <span class=\"c1\">// Tell this system which plugin to use</span>\n  <span class=\"c1\">// Returns false if the plugin doesn&#39;t have the interface(s) needed by this system</span>\n  <span class=\"nx\">virtual</span> <span class=\"kt\">bool</span> <span class=\"nx\">UsePlugin</span><span class=\"p\">(</span><span class=\"kr\">const</span> <span class=\"nx\">ignition</span><span class=\"o\">::</span><span class=\"nx\">plugin</span><span class=\"o\">::</span><span class=\"nx\">PluginPtr</span> <span class=\"o\">&amp;</span><span class=\"nx\">_plugin</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n  <span class=\"c1\">// Initialize the system</span>\n  <span class=\"c1\">// Note: maybe this should be combined with UsePlugin, e.g.:</span>\n  <span class=\"c1\">// virtual void Init(const ignition::plugin::PluginPtr &amp;_plugin, EntityQueryRegistrar &amp;_register) = 0;</span>\n  <span class=\"c1\">// That might depend on how/if we want to support hotswapping of system plugins.</span>\n  <span class=\"nx\">virtual</span> <span class=\"k\">void</span> <span class=\"nx\">Init</span><span class=\"p\">(</span><span class=\"nx\">EntityQueryRegistrar</span> <span class=\"o\">&amp;</span><span class=\"nx\">_register</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n  <span class=\"c1\">// Identify usable plugins. Feel free to change this function name.</span>\n  <span class=\"nx\">virtual</span> <span class=\"nx\">std</span><span class=\"o\">::</span><span class=\"nx\">set</span><span class=\"o\">&lt;</span><span class=\"nx\">std</span><span class=\"o\">::</span><span class=\"kt\">string</span><span class=\"o\">&gt;</span> <span class=\"nx\">IdentifyPlugins</span><span class=\"p\">(</span><span class=\"kr\">const</span> <span class=\"nx\">ignition</span><span class=\"o\">::</span><span class=\"nx\">plugin</span><span class=\"o\">::</span><span class=\"nx\">Loader</span> <span class=\"o\">&amp;</span><span class=\"nx\">_loader</span><span class=\"p\">)</span> <span class=\"kr\">const</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n  <span class=\"c1\">// I would recommend a string for describing system types, since I expect this information</span>\n  <span class=\"c1\">// is most relevant to humans using the Gazebo application. That also doesn&#39;t lock us in to</span>\n  <span class=\"c1\">// a specific set of System types.</span>\n  <span class=\"nx\">virtual</span> <span class=\"nx\">std</span><span class=\"o\">::</span><span class=\"kt\">string</span> <span class=\"nx\">SystemType</span><span class=\"p\">()</span> <span class=\"kr\">const</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</pre></div>\n\n\n<p>Each different <code>System</code> type, (e.g. <code>PhysicsSystem</code>, <code>RenderSystem</code>, <code>GuiSystem</code>, <code>LogSystem</code>) would only be instantiated once at startup and put into the <code>SystemManager</code> (or maybe <code>SystemPluginManager</code> if that's what we want to call it). To discover the relevant plugins for each type of system, the <code>SystemManager</code> would call the <code>IdentifyPlugins(~)</code> function on the system of interest, passing in the <code>ignition::plugin::Loader</code> instance that has already been filled with libraries. The <code>IdentifyPlugins(~)</code> function would then pass back a set of the names of the plugins within the loader that have the necessary interface(s).</p>\n<p>In order to create a basic prototype skeleton, you could consider creating barebones <code>RenderSystem</code> and <code>GuiSystem</code> classes. I don't know if <code>ign-rendering</code> or <code>ign-gui</code> has any plugin interfaces to query for, although I do believe that <code>ign-gui</code> has been using the plugin system for a while now, so <code>ign-gui</code> might have some good interfaces for the <code>GuiSystem</code> to \"depend\" on (if only for testing purposes). But <code>ign-gui</code> will need to be updated to the <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-plugin/pull-requests/2\" rel=\"nofollow\">NewRegistrationScheme</a> branch of <code>ign-plugin</code> to work with this PR.</p>\n<p>For the <code>PhysicsSystem</code>, you could consider testing against the <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/pull-requests/29\" rel=\"nofollow\">sdf_component</a> branch of <code>ign-physics</code> and use the <code>ForwardStep</code> class as the \"necessary interface\" for <code>PhysicsSystem</code> plugins. However, you'd have to use something like: <code>_loader.PluginsImplementing&lt;ignition::physics::ForwardStep::Implementation&lt;ignition::physics::FeaturePolicy3d&gt;&gt;()</code> to check for that interface which is kind of gross. Some time soon I'll make some <code>ign-physics</code> utilities to make it easier to look for plugins that match a set of features. Note that the <code>sdf_component</code> branch is still a WIP, so I haven't done any tests on loading its <code>ignition-physics0-dartsim</code> plugin yet.</p>\n<p>I apologize for the wall of text, but please let me know if anything I said was confusing or unclear in any way.</p>", "type": "rendered"}, "created_on": "2018-08-10T10:15:18.079187+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-08-10T10:18:45.355525+00:00", "type": "pullrequest_comment", "id": 72610483}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72611391.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72611391"}}, "parent": {"id": 72610483, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72610483.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72610483"}}, "depth": 1}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "By the way, `ignition::plugin::Loader::PluginsImplementing<InterfaceT>()` is the recommended way of checking which plugins within a `Loader` instance are able to implement a given interface, and it does not involve actually loading any plugin instances.", "markup": "markdown", "html": "<p>By the way, <code>ignition::plugin::Loader::PluginsImplementing&lt;InterfaceT&gt;()</code> is the recommended way of checking which plugins within a <code>Loader</code> instance are able to implement a given interface, and it does not involve actually loading any plugin instances.</p>", "type": "rendered"}, "created_on": "2018-08-10T10:23:49.495671+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-08-10T10:23:49.502225+00:00", "type": "pullrequest_comment", "id": 72611391}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72656233.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72656233"}}, "parent": {"id": 72610483, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72610483.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72610483"}}, "depth": 1}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "That all makes sense, however I've been thinking of systems in a different manner. \n\nUpstream packages wouldn't provide system plugins. Instead, a system plugin would use an upstream library. This would keep gazebo specific code out of the upstream libraries, and would allow a system plugin to use multiple libraries. For example, a system plugin may need to use `ign-rendering`, `ign-physics` , and `ign-transport`. Some systems plugins would ship with `ign-gazebo`, and a downstream user could build their own custom system plugins.\n\nDoes that make sense?", "markup": "markdown", "html": "<p>That all makes sense, however I've been thinking of systems in a different manner. </p>\n<p>Upstream packages wouldn't provide system plugins. Instead, a system plugin would use an upstream library. This would keep gazebo specific code out of the upstream libraries, and would allow a system plugin to use multiple libraries. For example, a system plugin may need to use <code>ign-rendering</code>, <code>ign-physics</code> , and <code>ign-transport</code>. Some systems plugins would ship with <code>ign-gazebo</code>, and a downstream user could build their own custom system plugins.</p>\n<p>Does that make sense?</p>", "type": "rendered"}, "created_on": "2018-08-10T16:23:28.543084+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2018-08-10T16:23:28.549954+00:00", "type": "pullrequest_comment", "id": 72656233}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72786920.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72786920"}}, "parent": {"id": 72656233, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72656233.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72656233"}}, "depth": 2}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "> Upstream packages wouldn't provide system plugins. Instead, a system plugin would use an upstream library.\n\nRight, we\u2019re totally on the same page for this. I think the only thing that\u2019s hairy is the implementation detail in how exactly a System uses the upstream libraries. My recommendation would be that the specific role of a System is to do the following:\n\n1. Inspect the interfaces provided by the plugins that are available, and identify which plugin\\(s\\) satisfy its own interface requirements. \\(e.g. a PhysicsSystem would look for plugins that provide the `ignition::physics::ForwardStep` interface, while a GuiSystem would look for plugin\\(s\\) that provide some kind of `ignition::gui::Widget` interface\\)\n2. Accept an instance of a satisfactory plugin and use that plugin\u2019s relevant interfaces while interacting with the Entity-Component System of Gazebo.\n\nThis allows the \u201cplugin\u201d classes used by Gazebo to be less tied to Gazebo specifically, which increases their reusability and gives greater incentive for third parties to develop them.\n\nThe alternative, where implementations of the `System` class use the upstream libraries directly, would imply that each unique plugin class used by Gazebo has to be dependent directly on `ign-gazebo`. I see two disadvantages to this:\n\n1. As we saw in this PR, you can\u2019t really know what a `System` is for until you instantiate it.\n2. If a user wants to create a custom plugin \\(e.g. for physics, for rendering, for custom GUI widgets\\) they need to create their own `System` class and interface directly with the `ign-gazebo` ECS, which might not be very appealing.\n\nThis sort of concept is probably better described with a whiteboard and diagrams, but in lieu of that, here are the key bullet points on the breakdown of roles, according to my recommendation:\n\n* Upstream ignition libraries \\(specifically gui, rendering, and physics for right now\\) should define generally useful interface classes and provide \\(at least one\\) plugin class that implements each of those interfaces\n* Each class that extends `ignition::gazebo::System` is able to use the interfaces defined in one of the upstream ignition libraries. It can inspect an `ignition::plugin::Loader` to look for plugin classes that are relevant to itself.\n* Users can create their own plugin classes that implement the interfaces of one \\(or more\\) of the upstream ignition libraries. If that plugin provides all the interfaces required by a `System`, then it can be loaded into that `System`.\n* Users could also create their own `System` plugins that extend the `System` interface. A `System` plugin would allow users to extend Gazebo so that it can use plugin interfaces that we didn't anticipate. A `System` plugin would need to have a dependency on `ign-gazebo`, but other plugins \\(which get _used by_ Systems\\) wouldn\u2019t need that dependency.\n\nWe're going to need a scheme were Systems can load plugins if we want to support things like multiple physics engines and multiple rendering engines. IMO the `System` class interface is the perfect place to put that functionality. Otherwise we\u2019ll need to repeatedly implement custom machinery for each System that wants to be able to support multiple implementations of its functionality \\(and I think that\u2019ll be most---if not all---of the Systems we create\\).", "markup": "markdown", "html": "<blockquote>\n<p>Upstream packages wouldn't provide system plugins. Instead, a system plugin would use an upstream library.</p>\n</blockquote>\n<p>Right, we\u2019re totally on the same page for this. I think the only thing that\u2019s hairy is the implementation detail in how exactly a System uses the upstream libraries. My recommendation would be that the specific role of a System is to do the following:</p>\n<ol>\n<li>Inspect the interfaces provided by the plugins that are available, and identify which plugin(s) satisfy its own interface requirements. (e.g. a PhysicsSystem would look for plugins that provide the <code>ignition::physics::ForwardStep</code> interface, while a GuiSystem would look for plugin(s) that provide some kind of <code>ignition::gui::Widget</code> interface)</li>\n<li>Accept an instance of a satisfactory plugin and use that plugin\u2019s relevant interfaces while interacting with the Entity-Component System of Gazebo.</li>\n</ol>\n<p>This allows the \u201cplugin\u201d classes used by Gazebo to be less tied to Gazebo specifically, which increases their reusability and gives greater incentive for third parties to develop them.</p>\n<p>The alternative, where implementations of the <code>System</code> class use the upstream libraries directly, would imply that each unique plugin class used by Gazebo has to be dependent directly on <code>ign-gazebo</code>. I see two disadvantages to this:</p>\n<ol>\n<li>As we saw in this PR, you can\u2019t really know what a <code>System</code> is for until you instantiate it.</li>\n<li>If a user wants to create a custom plugin (e.g. for physics, for rendering, for custom GUI widgets) they need to create their own <code>System</code> class and interface directly with the <code>ign-gazebo</code> ECS, which might not be very appealing.</li>\n</ol>\n<p>This sort of concept is probably better described with a whiteboard and diagrams, but in lieu of that, here are the key bullet points on the breakdown of roles, according to my recommendation:</p>\n<ul>\n<li>Upstream ignition libraries (specifically gui, rendering, and physics for right now) should define generally useful interface classes and provide (at least one) plugin class that implements each of those interfaces</li>\n<li>Each class that extends <code>ignition::gazebo::System</code> is able to use the interfaces defined in one of the upstream ignition libraries. It can inspect an <code>ignition::plugin::Loader</code> to look for plugin classes that are relevant to itself.</li>\n<li>Users can create their own plugin classes that implement the interfaces of one (or more) of the upstream ignition libraries. If that plugin provides all the interfaces required by a <code>System</code>, then it can be loaded into that <code>System</code>.</li>\n<li>Users could also create their own <code>System</code> plugins that extend the <code>System</code> interface. A <code>System</code> plugin would allow users to extend Gazebo so that it can use plugin interfaces that we didn't anticipate. A <code>System</code> plugin would need to have a dependency on <code>ign-gazebo</code>, but other plugins (which get <em>used by</em> Systems) wouldn\u2019t need that dependency.</li>\n</ul>\n<p>We're going to need a scheme were Systems can load plugins if we want to support things like multiple physics engines and multiple rendering engines. IMO the <code>System</code> class interface is the perfect place to put that functionality. Otherwise we\u2019ll need to repeatedly implement custom machinery for each System that wants to be able to support multiple implementations of its functionality (and I think that\u2019ll be most---if not all---of the Systems we create).</p>", "type": "rendered"}, "created_on": "2018-08-13T14:52:14.128540+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-08-13T14:56:03.918720+00:00", "type": "pullrequest_comment", "id": 72786920}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72835795.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72835795"}}, "parent": {"id": 72786920, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72786920.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72786920"}}, "depth": 3}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "I'm on board with upstream libraries \\(\\+ sensors, transport, msgs, common\\) providing useful interfaces. I believe gazebo should treat every system as a plugin. A system plugin only has to adhere to a fairly minimal `ign-gazebo` interface. These plugins could load other plugins, if they desire.\n\nThere are going to be many types of Systems, including many one-off systems, and we can\u2019t create a concrete interface for each system type. The user is going to tell gazebo what systems to run, and we really do not need to know what a system is for.\n\nI also want to keep this as dead simple as possible. Ignition gazebo can just load the specified system plugins, and it\u2019s up to the author of each plugin to do the right thing.", "markup": "markdown", "html": "<p>I'm on board with upstream libraries (+ sensors, transport, msgs, common) providing useful interfaces. I believe gazebo should treat every system as a plugin. A system plugin only has to adhere to a fairly minimal <code>ign-gazebo</code> interface. These plugins could load other plugins, if they desire.</p>\n<p>There are going to be many types of Systems, including many one-off systems, and we can\u2019t create a concrete interface for each system type. The user is going to tell gazebo what systems to run, and we really do not need to know what a system is for.</p>\n<p>I also want to keep this as dead simple as possible. Ignition gazebo can just load the specified system plugins, and it\u2019s up to the author of each plugin to do the right thing.</p>", "type": "rendered"}, "created_on": "2018-08-13T23:44:00.313472+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2018-08-13T23:44:00.321842+00:00", "type": "pullrequest_comment", "id": 72835795}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72847741.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72847741"}}, "parent": {"id": 72835795, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72835795.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72835795"}}, "depth": 4}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "If we want every single System to be a complete blackbox, that can work, but then we have to forego the concept of \u201csystem types\u201d, because there wouldn\u2019t be any good way for a System to communicate its role before being instantiated. That leaves us \\(and therefore also end-users\\) without an effective way to inspect the role or purpose of a System.\n\nThat also means that any plugins used by the System \\(e.g. a plugin which provides a physics engine implementation\\) need to be expressed as a Component belonging to an Entity within the ECS, because that\u2019s the only method we\u2019ll have for communicating with a System. So then we\u2019ll have plugins as Components, which may be awkward to serialize and communicate. \\(But then again, maybe we do want plugins to be Components, if that would make it possible to log and communicate the configuration of plugins that are being used?\\)\n\nI guess my conclusion is that we can minimize the `System` interface, but then:\n\n* We should throw away the concept of a system \"type\" and \"name\", because these can\u2019t be known until the System is instantiated anyway. Instead we\u2019ll need to solely categorize Systems by the name of the plugin class that provides the implementation of the `System` interface.\n\n    * \\(Plus if Systems are supposed to be completely blackboxes, then it doesn\u2019t make sense to try to categorize them or allow them to have names besides the unique name of the class that provides its implementation\\)\n    \n* We should figure out what kind of machinery we can devise so that we don\u2019t need each System to re-implement the inspection and loading of plugins that it needs to use internally.\n* We\u2019ll need to somehow componentize the plugins-used-by-systems, because we won\u2019t have any other way to communicate to Systems about what kinds of plugins they should be using internally, besides passing them entities with components attached.\n\n\u200c\n\nEdit:\n\nBut to expand on my comment\n\n> We should throw away the concept of a system \"type\" and \"name\", because these can\u2019t be known until the System is instantiated anyway\n\nWe do have a WIP concept in `ign-plugin` of an \u201calias\u201d for plugins. You\u2019ll be able to register an \u201calias\u201d for your plugin, which effectively becomes an alternative label or name that can be used to identify or instantiate your plugin. Multiple plugins could use the same alias, but if there is more than one plugin with the same alias in the loader at a time, then that alias can no longer be used to instantiate a plugin, and the more specific \\(unique\\) plugin name must be used.\n\nThat feature hasn't been fully developed yet, but if it would be helpful for `ign-gazebo` in managing System plugins, then I can focus on finishing it.", "markup": "markdown", "html": "<p>If we want every single System to be a complete blackbox, that can work, but then we have to forego the concept of \u201csystem types\u201d, because there wouldn\u2019t be any good way for a System to communicate its role before being instantiated. That leaves us (and therefore also end-users) without an effective way to inspect the role or purpose of a System.</p>\n<p>That also means that any plugins used by the System (e.g. a plugin which provides a physics engine implementation) need to be expressed as a Component belonging to an Entity within the ECS, because that\u2019s the only method we\u2019ll have for communicating with a System. So then we\u2019ll have plugins as Components, which may be awkward to serialize and communicate. (But then again, maybe we do want plugins to be Components, if that would make it possible to log and communicate the configuration of plugins that are being used?)</p>\n<p>I guess my conclusion is that we can minimize the <code>System</code> interface, but then:</p>\n<ul>\n<li>\n<p>We should throw away the concept of a system \"type\" and \"name\", because these can\u2019t be known until the System is instantiated anyway. Instead we\u2019ll need to solely categorize Systems by the name of the plugin class that provides the implementation of the <code>System</code> interface.</p>\n<ul>\n<li>(Plus if Systems are supposed to be completely blackboxes, then it doesn\u2019t make sense to try to categorize them or allow them to have names besides the unique name of the class that provides its implementation)</li>\n</ul>\n</li>\n<li>\n<p>We should figure out what kind of machinery we can devise so that we don\u2019t need each System to re-implement the inspection and loading of plugins that it needs to use internally.</p>\n</li>\n<li>We\u2019ll need to somehow componentize the plugins-used-by-systems, because we won\u2019t have any other way to communicate to Systems about what kinds of plugins they should be using internally, besides passing them entities with components attached.</li>\n</ul>\n<p>\u200c</p>\n<p>Edit:</p>\n<p>But to expand on my comment</p>\n<blockquote>\n<p>We should throw away the concept of a system \"type\" and \"name\", because these can\u2019t be known until the System is instantiated anyway</p>\n</blockquote>\n<p>We do have a WIP concept in <code>ign-plugin</code> of an \u201calias\u201d for plugins. You\u2019ll be able to register an \u201calias\u201d for your plugin, which effectively becomes an alternative label or name that can be used to identify or instantiate your plugin. Multiple plugins could use the same alias, but if there is more than one plugin with the same alias in the loader at a time, then that alias can no longer be used to instantiate a plugin, and the more specific (unique) plugin name must be used.</p>\n<p>That feature hasn't been fully developed yet, but if it would be helpful for <code>ign-gazebo</code> in managing System plugins, then I can focus on finishing it.</p>", "type": "rendered"}, "created_on": "2018-08-14T04:57:26.840516+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-08-14T08:24:16.015026+00:00", "type": "pullrequest_comment", "id": 72847741}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72931928.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72931928"}}, "parent": {"id": 72847741, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72847741.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72847741"}}, "depth": 5}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "> \\(Plus if Systems are supposed to be completely blackboxes, then it doesn\u2019t make sense to try to categorize them or allow them to have names besides the unique name of the class that provides its implementation\\)\n\nMy only concern with this is being able to maintain a system execution order.  We definitely want to be able to guarantee that systems \\(or types of systems\\) execute in a particular order and that syncronization happens appropriately.  I would think that the easiest way to enforce this would be via system types.", "markup": "markdown", "html": "<blockquote>\n<p>(Plus if Systems are supposed to be completely blackboxes, then it doesn\u2019t make sense to try to categorize them or allow them to have names besides the unique name of the class that provides its implementation)</p>\n</blockquote>\n<p>My only concern with this is being able to maintain a system execution order.  We definitely want to be able to guarantee that systems (or types of systems) execute in a particular order and that syncronization happens appropriately.  I would think that the easiest way to enforce this would be via system types.</p>", "type": "rendered"}, "created_on": "2018-08-14T15:42:26.511587+00:00", "user": {"display_name": "Michael Carroll", "uuid": "{17dbbc15-cbc0-42f0-a985-cde9061c78a0}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D"}, "html": {"href": "https://bitbucket.org/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:65740f22-cc56-4418-9608-7e17d0ed47b7/2aa259f5-4de1-4f68-9156-eded72041d84/128"}}, "nickname": "Michael Carroll", "type": "user", "account_id": "557058:65740f22-cc56-4418-9608-7e17d0ed47b7"}, "updated_on": "2018-08-14T15:42:26.520468+00:00", "type": "pullrequest_comment", "id": 72931928}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72969047.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72969047"}}, "parent": {"id": 72847741, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72847741.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72847741"}}, "depth": 5}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "Okay, we need to get this moving forward so that we can hit our milestones and unblock people.  \n\nGrey, you have good points and we may very well end up with your proposal. Right now I\u2019m going to side with the approach of treating all Systems as plugins. There is less infrastructure and prescribed methodology for this approach, and we will need the blackbox approach to handle systems that do not fall into a specific category. We can always add system types later down the line. \n\nI\u2019d also like to get some experience using an ECS before creating a lot of code around systems and how they are used.\n\nFor now, let\u2019s ditch system types all together. I\u2019m not 100% certain we need them, and I\u2019d rather implement types when we have a concrete use case. The initial reason to have system types was to structure the order in which systems execute to prevent \\(for example\\) a pose-publisher-system from sending out pose information before the physics update. Instead of types, we really should have a two-step update loop, where all systems update operate on static components. The second step would apply component modifications generated by systems. This would look like:\n\nStep 1: Instantiate the entities, components, and systems.\n\nStep 2: Store component state in two states, StateA and StateB.\n\nStep 3: Update the systems. Systems can read StateA, and write to StateB.\n\nStep 4: Swap StateA, and StateB\n\nStep 5: Goto Step3.", "markup": "markdown", "html": "<p>Okay, we need to get this moving forward so that we can hit our milestones and unblock people.  </p>\n<p>Grey, you have good points and we may very well end up with your proposal. Right now I\u2019m going to side with the approach of treating all Systems as plugins. There is less infrastructure and prescribed methodology for this approach, and we will need the blackbox approach to handle systems that do not fall into a specific category. We can always add system types later down the line. </p>\n<p>I\u2019d also like to get some experience using an ECS before creating a lot of code around systems and how they are used.</p>\n<p>For now, let\u2019s ditch system types all together. I\u2019m not 100% certain we need them, and I\u2019d rather implement types when we have a concrete use case. The initial reason to have system types was to structure the order in which systems execute to prevent (for example) a pose-publisher-system from sending out pose information before the physics update. Instead of types, we really should have a two-step update loop, where all systems update operate on static components. The second step would apply component modifications generated by systems. This would look like:</p>\n<p>Step 1: Instantiate the entities, components, and systems.</p>\n<p>Step 2: Store component state in two states, StateA and StateB.</p>\n<p>Step 3: Update the systems. Systems can read StateA, and write to StateB.</p>\n<p>Step 4: Swap StateA, and StateB</p>\n<p>Step 5: Goto Step3.</p>", "type": "rendered"}, "created_on": "2018-08-14T22:05:51.434266+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2018-08-14T22:05:51.447035+00:00", "type": "pullrequest_comment", "id": 72969047}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72980882.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72980882"}}, "parent": {"id": 72969047, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72969047.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72969047"}}, "depth": 6}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "A two-step update seems like a reasonable way to move forward for now, if only to get a working prototype of an ECS without needing to worry about how to configure the systems.\n\nIf I\u2019m understanding correctly, this might have one pitfall: anything pertaining to feedback \\(e.g. sensors and controllers\\) will be one timestep behind the update loop. In principle, most real-world controllers should be okay with this kind of \u201clatency\u201d, but often a simulation might want to use feedback to emulate a mechanical actuator or a physical phenomenon \\(e.g. wind or magnetic fields\\), and that kind of latency can result in dynamic instability.\n\nBut since we aren\u2019t concerned with those types of Systems yet, the two-step update should meet our needs for right now, and we can spend time on figuring out something without edge cases later.", "markup": "markdown", "html": "<p>A two-step update seems like a reasonable way to move forward for now, if only to get a working prototype of an ECS without needing to worry about how to configure the systems.</p>\n<p>If I\u2019m understanding correctly, this might have one pitfall: anything pertaining to feedback (e.g. sensors and controllers) will be one timestep behind the update loop. In principle, most real-world controllers should be okay with this kind of \u201clatency\u201d, but often a simulation might want to use feedback to emulate a mechanical actuator or a physical phenomenon (e.g. wind or magnetic fields), and that kind of latency can result in dynamic instability.</p>\n<p>But since we aren\u2019t concerned with those types of Systems yet, the two-step update should meet our needs for right now, and we can spend time on figuring out something without edge cases later.</p>", "type": "rendered"}, "created_on": "2018-08-15T02:38:25.364217+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-08-15T02:39:08.905461+00:00", "type": "pullrequest_comment", "id": 72980882}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/73041998.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-73041998"}}, "parent": {"id": 72980882, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72980882.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72980882"}}, "depth": 7}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "Thanks, I hadn\u2019t sat down and worked out simtime, state updates, sensor updates, and application of control commands.\n\nFor the record, the original proposal was this:\n\n1. Load the world into stateA\n2. Iteration #1\n\n    1. Transmit simtime == 0.0\n    2. Transmit stateA\n    3. Systems \\(physics, sensors, gui, etc\\) update based on stateA and modify stateB\n    4. External controllers should receive StateA and any sensor data, which represent StateA, in conjunction with simtime == 0.0\n    \n3. Iteration #2\n\n    1. Transmit simtime == 1.0\n    2. Transmit stateB\n    3.  Systems \\(physics, sensors, gui, etc\\) update based on stateB and modify stateA\n    4. External controllers should receive StateB and any sensor data, which represent StateB, in conjunction with simtime == 1.0\n    \n4. Repeat.\n\nWith this, the exposed simulation state and sensor data are in sync. However, an external controller receives StateA in Iteration#1, and then sends back a control command. In iteration #2 StateB is transmitted **without** the effects of the control command. Only in interation #3 will the control command effects be seen by the external controller.\n\nWhat I think Grey is proposing, and what looks better, is:\n\n1. Load the world into stateA\n2. Iteration #1\n\n    1. Update all **modifying** systems, such as physics and controllers. This should be a no-op on iteration #1.\n    2. Transmit simtime == 0.0\n    3. Transmit stateA\n    4. Update **non-modifying** systems such as sensors and GUI based on StateA\n    5. External controllers should receive StateA and any sensor data, which represent StateA, in conjunction with simtime == 0.0\n    \n3. Iteration #2\n\n    1. Update all **modifying** systems, such as physics and controllers. State updates are applied to StateA.\n    2. Transmit simtime == 1.0\n    3. Transmit stateA\n    4. Update **non-modifying** systems such as sensors and GUI based on StateA\n    5. External controllers should receive StateA and any sensor data, which represent StateA, in conjunction with simtime == 1.0\n    \n4. Repeat\n\nThis second approach relies on only one state, stateA. It will require knowledge of what systems modify state, and what system do not modify state. So, we could start there. We have just two classes of systems, one that can modify state data and one that cannot. We can enforce that at the EntityComponentManager level by preventing one type of system access to mutable components. \n\nDoes all of this sound correct?", "markup": "markdown", "html": "<p>Thanks, I hadn\u2019t sat down and worked out simtime, state updates, sensor updates, and application of control commands.</p>\n<p>For the record, the original proposal was this:</p>\n<ol>\n<li>Load the world into stateA</li>\n<li>\n<p>Iteration <a href=\"#!/ignitionrobotics/ign-gazebo/issues/1/weird-sphere-movement\" rel=\"nofollow\" title=\"Weird sphere movement\" class=\"ap-connect-link\"><s>#1</s></a></p>\n<ol>\n<li>Transmit simtime == 0.0</li>\n<li>Transmit stateA</li>\n<li>Systems (physics, sensors, gui, etc) update based on stateA and modify stateB</li>\n<li>External controllers should receive StateA and any sensor data, which represent StateA, in conjunction with simtime == 0.0</li>\n</ol>\n</li>\n<li>\n<p>Iteration <a href=\"#!/ignitionrobotics/ign-gazebo/issues/2/transport-segfault-on-shutdown\" rel=\"nofollow\" title=\"Transport segfault on shutdown\" class=\"ap-connect-link\"><s>#2</s></a></p>\n<ol>\n<li>Transmit simtime == 1.0</li>\n<li>Transmit stateB</li>\n<li>Systems (physics, sensors, gui, etc) update based on stateB and modify stateA</li>\n<li>External controllers should receive StateB and any sensor data, which represent StateB, in conjunction with simtime == 1.0</li>\n</ol>\n</li>\n<li>\n<p>Repeat.</p>\n</li>\n</ol>\n<p>With this, the exposed simulation state and sensor data are in sync. However, an external controller receives StateA in Iteration<a href=\"#!/ignitionrobotics/ign-gazebo/issues/1/weird-sphere-movement\" rel=\"nofollow\" title=\"Weird sphere movement\" class=\"ap-connect-link\"><s>#1</s></a>, and then sends back a control command. In iteration <a href=\"#!/ignitionrobotics/ign-gazebo/issues/2/transport-segfault-on-shutdown\" rel=\"nofollow\" title=\"Transport segfault on shutdown\" class=\"ap-connect-link\"><s>#2</s></a> StateB is transmitted <strong>without</strong> the effects of the control command. Only in interation <a href=\"#!/ignitionrobotics/ign-gazebo/issues/3/pose-components\" rel=\"nofollow\" title=\"Pose components\" class=\"ap-connect-link\">#3</a> will the control command effects be seen by the external controller.</p>\n<p>What I think Grey is proposing, and what looks better, is:</p>\n<ol>\n<li>Load the world into stateA</li>\n<li>\n<p>Iteration <a href=\"#!/ignitionrobotics/ign-gazebo/issues/1/weird-sphere-movement\" rel=\"nofollow\" title=\"Weird sphere movement\" class=\"ap-connect-link\"><s>#1</s></a></p>\n<ol>\n<li>Update all <strong>modifying</strong> systems, such as physics and controllers. This should be a no-op on iteration <a href=\"#!/ignitionrobotics/ign-gazebo/issues/1/weird-sphere-movement\" rel=\"nofollow\" title=\"Weird sphere movement\" class=\"ap-connect-link\"><s>#1</s></a>.</li>\n<li>Transmit simtime == 0.0</li>\n<li>Transmit stateA</li>\n<li>Update <strong>non-modifying</strong> systems such as sensors and GUI based on StateA</li>\n<li>External controllers should receive StateA and any sensor data, which represent StateA, in conjunction with simtime == 0.0</li>\n</ol>\n</li>\n<li>\n<p>Iteration <a href=\"#!/ignitionrobotics/ign-gazebo/issues/2/transport-segfault-on-shutdown\" rel=\"nofollow\" title=\"Transport segfault on shutdown\" class=\"ap-connect-link\"><s>#2</s></a></p>\n<ol>\n<li>Update all <strong>modifying</strong> systems, such as physics and controllers. State updates are applied to StateA.</li>\n<li>Transmit simtime == 1.0</li>\n<li>Transmit stateA</li>\n<li>Update <strong>non-modifying</strong> systems such as sensors and GUI based on StateA</li>\n<li>External controllers should receive StateA and any sensor data, which represent StateA, in conjunction with simtime == 1.0</li>\n</ol>\n</li>\n<li>\n<p>Repeat</p>\n</li>\n</ol>\n<p>This second approach relies on only one state, stateA. It will require knowledge of what systems modify state, and what system do not modify state. So, we could start there. We have just two classes of systems, one that can modify state data and one that cannot. We can enforce that at the EntityComponentManager level by preventing one type of system access to mutable components. </p>\n<p>Does all of this sound correct?</p>", "type": "rendered"}, "created_on": "2018-08-15T14:48:42.580727+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2018-08-15T14:48:42.589978+00:00", "type": "pullrequest_comment", "id": 73041998}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/73054875.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-73054875"}}, "parent": {"id": 73041998, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/73041998.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-73041998"}}, "depth": 8}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "This all makes sense.\n\nDo we want to treat these as separate systems or multiple methods on the same system that would be unimplemented in places where they aren\u2019t used?", "markup": "markdown", "html": "<p>This all makes sense.</p>\n<p>Do we want to treat these as separate systems or multiple methods on the same system that would be unimplemented in places where they aren\u2019t used?</p>", "type": "rendered"}, "created_on": "2018-08-15T16:27:50.109669+00:00", "user": {"display_name": "Michael Carroll", "uuid": "{17dbbc15-cbc0-42f0-a985-cde9061c78a0}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D"}, "html": {"href": "https://bitbucket.org/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:65740f22-cc56-4418-9608-7e17d0ed47b7/2aa259f5-4de1-4f68-9156-eded72041d84/128"}}, "nickname": "Michael Carroll", "type": "user", "account_id": "557058:65740f22-cc56-4418-9608-7e17d0ed47b7"}, "updated_on": "2018-08-15T16:27:50.116624+00:00", "type": "pullrequest_comment", "id": 73054875}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/73058215.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-73058215"}}, "parent": {"id": 73054875, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/73054875.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-73054875"}}, "depth": 9}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "Good idea. I like two different methods, one for modifications and one that prevents modifications.", "markup": "markdown", "html": "<p>Good idea. I like two different methods, one for modifications and one that prevents modifications.</p>", "type": "rendered"}, "created_on": "2018-08-15T17:03:42.751474+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2018-08-15T17:03:42.759271+00:00", "type": "pullrequest_comment", "id": 73058215}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/73095704.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-73095704"}}, "parent": {"id": 73054875, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/73054875.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-73054875"}}, "depth": 9}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "It would be pretty straightforward to define two interface classes: one for modifying systems and one for non-modifying systems. Then the plugin loader can be used to inspect which interface is provided by any given system. If both interfaces are provided, then maybe query the system in both phases.\n\nThat would allow the systems to express what type of system they are, and we don\u2019t need to worry about dangling no-op virtual functions.\n\nEdit: Note that each of the interface classes could virtually inherit the base `System` class, so all Systems would have the same `Init(~)` function, whether they\u2019re a modifying system or a non-modifying system.", "markup": "markdown", "html": "<p>It would be pretty straightforward to define two interface classes: one for modifying systems and one for non-modifying systems. Then the plugin loader can be used to inspect which interface is provided by any given system. If both interfaces are provided, then maybe query the system in both phases.</p>\n<p>That would allow the systems to express what type of system they are, and we don\u2019t need to worry about dangling no-op virtual functions.</p>\n<p>Edit: Note that each of the interface classes could virtually inherit the base <code>System</code> class, so all Systems would have the same <code>Init(~)</code> function, whether they\u2019re a modifying system or a non-modifying system.</p>", "type": "rendered"}, "created_on": "2018-08-16T01:57:54.496616+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-08-16T04:45:56.242647+00:00", "type": "pullrequest_comment", "id": 73095704}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/73095414.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-73095414"}}, "parent": {"id": 73041998, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/73041998.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-73041998"}}, "depth": 8}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "That all sounds like a good start.\n\nOne thing to consider: Do we make a distinction between input and output with respect to the ECS state? Because if input and output are both rolled into the state, then GUI would qualify as a modifying system if it\u2019s able to send commands to the physics engine \\(or to other systems\\) through the ECS state.\n\nI suspect at some point what we\u2019ll need is a way to allow users to configure the execution order of systems, possibly by specifying it in a new version of SDF. That\u2019ll be important for ensuring that controllers do their update after the physics engine \\(or potentially _before_ the physics engine, depending on the nature of the controller\\). But that would take some heavy lifting and isn\u2019t immediately necessary, so in the meantime a distinction between modifying vs non-modifying systems should get us most of what we need.", "markup": "markdown", "html": "<p>That all sounds like a good start.</p>\n<p>One thing to consider: Do we make a distinction between input and output with respect to the ECS state? Because if input and output are both rolled into the state, then GUI would qualify as a modifying system if it\u2019s able to send commands to the physics engine (or to other systems) through the ECS state.</p>\n<p>I suspect at some point what we\u2019ll need is a way to allow users to configure the execution order of systems, possibly by specifying it in a new version of SDF. That\u2019ll be important for ensuring that controllers do their update after the physics engine (or potentially <em>before</em> the physics engine, depending on the nature of the controller). But that would take some heavy lifting and isn\u2019t immediately necessary, so in the meantime a distinction between modifying vs non-modifying systems should get us most of what we need.</p>", "type": "rendered"}, "created_on": "2018-08-16T01:53:00.158405+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-08-16T01:53:00.164913+00:00", "type": "pullrequest_comment", "id": 73095414}], "page": 1, "size": 22}