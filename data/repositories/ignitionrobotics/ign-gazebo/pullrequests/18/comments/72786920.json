{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72786920.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72786920"}}, "parent": {"id": 72656233, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72656233.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72656233"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "> Upstream packages wouldn't provide system plugins. Instead, a system plugin would use an upstream library.\n\nRight, we\u2019re totally on the same page for this. I think the only thing that\u2019s hairy is the implementation detail in how exactly a System uses the upstream libraries. My recommendation would be that the specific role of a System is to do the following:\n\n1. Inspect the interfaces provided by the plugins that are available, and identify which plugin\\(s\\) satisfy its own interface requirements. \\(e.g. a PhysicsSystem would look for plugins that provide the `ignition::physics::ForwardStep` interface, while a GuiSystem would look for plugin\\(s\\) that provide some kind of `ignition::gui::Widget` interface\\)\n2. Accept an instance of a satisfactory plugin and use that plugin\u2019s relevant interfaces while interacting with the Entity-Component System of Gazebo.\n\nThis allows the \u201cplugin\u201d classes used by Gazebo to be less tied to Gazebo specifically, which increases their reusability and gives greater incentive for third parties to develop them.\n\nThe alternative, where implementations of the `System` class use the upstream libraries directly, would imply that each unique plugin class used by Gazebo has to be dependent directly on `ign-gazebo`. I see two disadvantages to this:\n\n1. As we saw in this PR, you can\u2019t really know what a `System` is for until you instantiate it.\n2. If a user wants to create a custom plugin \\(e.g. for physics, for rendering, for custom GUI widgets\\) they need to create their own `System` class and interface directly with the `ign-gazebo` ECS, which might not be very appealing.\n\nThis sort of concept is probably better described with a whiteboard and diagrams, but in lieu of that, here are the key bullet points on the breakdown of roles, according to my recommendation:\n\n* Upstream ignition libraries \\(specifically gui, rendering, and physics for right now\\) should define generally useful interface classes and provide \\(at least one\\) plugin class that implements each of those interfaces\n* Each class that extends `ignition::gazebo::System` is able to use the interfaces defined in one of the upstream ignition libraries. It can inspect an `ignition::plugin::Loader` to look for plugin classes that are relevant to itself.\n* Users can create their own plugin classes that implement the interfaces of one \\(or more\\) of the upstream ignition libraries. If that plugin provides all the interfaces required by a `System`, then it can be loaded into that `System`.\n* Users could also create their own `System` plugins that extend the `System` interface. A `System` plugin would allow users to extend Gazebo so that it can use plugin interfaces that we didn't anticipate. A `System` plugin would need to have a dependency on `ign-gazebo`, but other plugins \\(which get _used by_ Systems\\) wouldn\u2019t need that dependency.\n\nWe're going to need a scheme were Systems can load plugins if we want to support things like multiple physics engines and multiple rendering engines. IMO the `System` class interface is the perfect place to put that functionality. Otherwise we\u2019ll need to repeatedly implement custom machinery for each System that wants to be able to support multiple implementations of its functionality \\(and I think that\u2019ll be most---if not all---of the Systems we create\\).", "markup": "markdown", "html": "<blockquote>\n<p>Upstream packages wouldn't provide system plugins. Instead, a system plugin would use an upstream library.</p>\n</blockquote>\n<p>Right, we\u2019re totally on the same page for this. I think the only thing that\u2019s hairy is the implementation detail in how exactly a System uses the upstream libraries. My recommendation would be that the specific role of a System is to do the following:</p>\n<ol>\n<li>Inspect the interfaces provided by the plugins that are available, and identify which plugin(s) satisfy its own interface requirements. (e.g. a PhysicsSystem would look for plugins that provide the <code>ignition::physics::ForwardStep</code> interface, while a GuiSystem would look for plugin(s) that provide some kind of <code>ignition::gui::Widget</code> interface)</li>\n<li>Accept an instance of a satisfactory plugin and use that plugin\u2019s relevant interfaces while interacting with the Entity-Component System of Gazebo.</li>\n</ol>\n<p>This allows the \u201cplugin\u201d classes used by Gazebo to be less tied to Gazebo specifically, which increases their reusability and gives greater incentive for third parties to develop them.</p>\n<p>The alternative, where implementations of the <code>System</code> class use the upstream libraries directly, would imply that each unique plugin class used by Gazebo has to be dependent directly on <code>ign-gazebo</code>. I see two disadvantages to this:</p>\n<ol>\n<li>As we saw in this PR, you can\u2019t really know what a <code>System</code> is for until you instantiate it.</li>\n<li>If a user wants to create a custom plugin (e.g. for physics, for rendering, for custom GUI widgets) they need to create their own <code>System</code> class and interface directly with the <code>ign-gazebo</code> ECS, which might not be very appealing.</li>\n</ol>\n<p>This sort of concept is probably better described with a whiteboard and diagrams, but in lieu of that, here are the key bullet points on the breakdown of roles, according to my recommendation:</p>\n<ul>\n<li>Upstream ignition libraries (specifically gui, rendering, and physics for right now) should define generally useful interface classes and provide (at least one) plugin class that implements each of those interfaces</li>\n<li>Each class that extends <code>ignition::gazebo::System</code> is able to use the interfaces defined in one of the upstream ignition libraries. It can inspect an <code>ignition::plugin::Loader</code> to look for plugin classes that are relevant to itself.</li>\n<li>Users can create their own plugin classes that implement the interfaces of one (or more) of the upstream ignition libraries. If that plugin provides all the interfaces required by a <code>System</code>, then it can be loaded into that <code>System</code>.</li>\n<li>Users could also create their own <code>System</code> plugins that extend the <code>System</code> interface. A <code>System</code> plugin would allow users to extend Gazebo so that it can use plugin interfaces that we didn't anticipate. A <code>System</code> plugin would need to have a dependency on <code>ign-gazebo</code>, but other plugins (which get <em>used by</em> Systems) wouldn\u2019t need that dependency.</li>\n</ul>\n<p>We're going to need a scheme were Systems can load plugins if we want to support things like multiple physics engines and multiple rendering engines. IMO the <code>System</code> class interface is the perfect place to put that functionality. Otherwise we\u2019ll need to repeatedly implement custom machinery for each System that wants to be able to support multiple implementations of its functionality (and I think that\u2019ll be most---if not all---of the Systems we create).</p>", "type": "rendered"}, "created_on": "2018-08-13T14:52:14.128540+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-08-13T14:56:03.918720+00:00", "type": "pullrequest_comment", "id": 72786920}