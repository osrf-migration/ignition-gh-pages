{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/73041998.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-73041998"}}, "parent": {"id": 72980882, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72980882.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72980882"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "Thanks, I hadn\u2019t sat down and worked out simtime, state updates, sensor updates, and application of control commands.\n\nFor the record, the original proposal was this:\n\n1. Load the world into stateA\n2. Iteration #1\n\n    1. Transmit simtime == 0.0\n    2. Transmit stateA\n    3. Systems \\(physics, sensors, gui, etc\\) update based on stateA and modify stateB\n    4. External controllers should receive StateA and any sensor data, which represent StateA, in conjunction with simtime == 0.0\n    \n3. Iteration #2\n\n    1. Transmit simtime == 1.0\n    2. Transmit stateB\n    3.  Systems \\(physics, sensors, gui, etc\\) update based on stateB and modify stateA\n    4. External controllers should receive StateB and any sensor data, which represent StateB, in conjunction with simtime == 1.0\n    \n4. Repeat.\n\nWith this, the exposed simulation state and sensor data are in sync. However, an external controller receives StateA in Iteration#1, and then sends back a control command. In iteration #2 StateB is transmitted **without** the effects of the control command. Only in interation #3 will the control command effects be seen by the external controller.\n\nWhat I think Grey is proposing, and what looks better, is:\n\n1. Load the world into stateA\n2. Iteration #1\n\n    1. Update all **modifying** systems, such as physics and controllers. This should be a no-op on iteration #1.\n    2. Transmit simtime == 0.0\n    3. Transmit stateA\n    4. Update **non-modifying** systems such as sensors and GUI based on StateA\n    5. External controllers should receive StateA and any sensor data, which represent StateA, in conjunction with simtime == 0.0\n    \n3. Iteration #2\n\n    1. Update all **modifying** systems, such as physics and controllers. State updates are applied to StateA.\n    2. Transmit simtime == 1.0\n    3. Transmit stateA\n    4. Update **non-modifying** systems such as sensors and GUI based on StateA\n    5. External controllers should receive StateA and any sensor data, which represent StateA, in conjunction with simtime == 1.0\n    \n4. Repeat\n\nThis second approach relies on only one state, stateA. It will require knowledge of what systems modify state, and what system do not modify state. So, we could start there. We have just two classes of systems, one that can modify state data and one that cannot. We can enforce that at the EntityComponentManager level by preventing one type of system access to mutable components. \n\nDoes all of this sound correct?", "markup": "markdown", "html": "<p>Thanks, I hadn\u2019t sat down and worked out simtime, state updates, sensor updates, and application of control commands.</p>\n<p>For the record, the original proposal was this:</p>\n<ol>\n<li>Load the world into stateA</li>\n<li>\n<p>Iteration <a href=\"#!/ignitionrobotics/ign-gazebo/issues/1/weird-sphere-movement\" rel=\"nofollow\" title=\"Weird sphere movement\" class=\"ap-connect-link\"><s>#1</s></a></p>\n<ol>\n<li>Transmit simtime == 0.0</li>\n<li>Transmit stateA</li>\n<li>Systems (physics, sensors, gui, etc) update based on stateA and modify stateB</li>\n<li>External controllers should receive StateA and any sensor data, which represent StateA, in conjunction with simtime == 0.0</li>\n</ol>\n</li>\n<li>\n<p>Iteration <a href=\"#!/ignitionrobotics/ign-gazebo/issues/2/transport-segfault-on-shutdown\" rel=\"nofollow\" title=\"Transport segfault on shutdown\" class=\"ap-connect-link\"><s>#2</s></a></p>\n<ol>\n<li>Transmit simtime == 1.0</li>\n<li>Transmit stateB</li>\n<li>Systems (physics, sensors, gui, etc) update based on stateB and modify stateA</li>\n<li>External controllers should receive StateB and any sensor data, which represent StateB, in conjunction with simtime == 1.0</li>\n</ol>\n</li>\n<li>\n<p>Repeat.</p>\n</li>\n</ol>\n<p>With this, the exposed simulation state and sensor data are in sync. However, an external controller receives StateA in Iteration<a href=\"#!/ignitionrobotics/ign-gazebo/issues/1/weird-sphere-movement\" rel=\"nofollow\" title=\"Weird sphere movement\" class=\"ap-connect-link\"><s>#1</s></a>, and then sends back a control command. In iteration <a href=\"#!/ignitionrobotics/ign-gazebo/issues/2/transport-segfault-on-shutdown\" rel=\"nofollow\" title=\"Transport segfault on shutdown\" class=\"ap-connect-link\"><s>#2</s></a> StateB is transmitted <strong>without</strong> the effects of the control command. Only in interation <a href=\"#!/ignitionrobotics/ign-gazebo/issues/3/pose-components\" rel=\"nofollow\" title=\"Pose components\" class=\"ap-connect-link\">#3</a> will the control command effects be seen by the external controller.</p>\n<p>What I think Grey is proposing, and what looks better, is:</p>\n<ol>\n<li>Load the world into stateA</li>\n<li>\n<p>Iteration <a href=\"#!/ignitionrobotics/ign-gazebo/issues/1/weird-sphere-movement\" rel=\"nofollow\" title=\"Weird sphere movement\" class=\"ap-connect-link\"><s>#1</s></a></p>\n<ol>\n<li>Update all <strong>modifying</strong> systems, such as physics and controllers. This should be a no-op on iteration <a href=\"#!/ignitionrobotics/ign-gazebo/issues/1/weird-sphere-movement\" rel=\"nofollow\" title=\"Weird sphere movement\" class=\"ap-connect-link\"><s>#1</s></a>.</li>\n<li>Transmit simtime == 0.0</li>\n<li>Transmit stateA</li>\n<li>Update <strong>non-modifying</strong> systems such as sensors and GUI based on StateA</li>\n<li>External controllers should receive StateA and any sensor data, which represent StateA, in conjunction with simtime == 0.0</li>\n</ol>\n</li>\n<li>\n<p>Iteration <a href=\"#!/ignitionrobotics/ign-gazebo/issues/2/transport-segfault-on-shutdown\" rel=\"nofollow\" title=\"Transport segfault on shutdown\" class=\"ap-connect-link\"><s>#2</s></a></p>\n<ol>\n<li>Update all <strong>modifying</strong> systems, such as physics and controllers. State updates are applied to StateA.</li>\n<li>Transmit simtime == 1.0</li>\n<li>Transmit stateA</li>\n<li>Update <strong>non-modifying</strong> systems such as sensors and GUI based on StateA</li>\n<li>External controllers should receive StateA and any sensor data, which represent StateA, in conjunction with simtime == 1.0</li>\n</ol>\n</li>\n<li>\n<p>Repeat</p>\n</li>\n</ol>\n<p>This second approach relies on only one state, stateA. It will require knowledge of what systems modify state, and what system do not modify state. So, we could start there. We have just two classes of systems, one that can modify state data and one that cannot. We can enforce that at the EntityComponentManager level by preventing one type of system access to mutable components. </p>\n<p>Does all of this sound correct?</p>", "type": "rendered"}, "created_on": "2018-08-15T14:48:42.580727+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2018-08-15T14:48:42.589978+00:00", "type": "pullrequest_comment", "id": 73041998}