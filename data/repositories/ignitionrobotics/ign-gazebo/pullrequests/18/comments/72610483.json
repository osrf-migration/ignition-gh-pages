{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72610483.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72610483"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "Based on what I'm seeing of the ECS implementation here in `ign-gazebo`, I don't think the `System` class should be the \"entry point\" \\(so to speak\\) interface for the plugins that are being coordinated by `ign-gazebo`. And an enumeration is not what I\u2019d recommend for distinguishing between different plugin types, but that\u2019s a somewhat orthogonal \\(and probably much less important\\) matter.\n\nUsing the `System` class as the interface for plugging in different systems results in a critical dependency issue. `ign-gazebo` is meant to be dependent on the various upstream ignition libraries \\(e.g. `ign-gui`, `ign-rendering`, `ign-physics`\\) while those other libraries shouldn't have any dependency on `ign-gazebo`. If the `ignition::gazebo::System` class is meant to be the interface class for speaking to the various system plugins, then those plugins will need to depend on `ign-gazebo` in order to inherit and expose the `ignition::gazebo::System` class. That means the packages providing the plugins \\(i.e. `ign-gui`, `ign-rendering`, `ign-physics`\\) will need to depend on `ign-gazebo`, leaving us with circular dependencies.\n\nInstead, it looks to me like the `System` class is a base class for other `ign-gazebo` system classes, each of which will be responsible for interfacing with the plugins that are provided by the upstream ignition libraries. Currently it looks like only `ignition::gazebo::PhysicsSystem` exists, but we could also create `ignition::gazebo::GuiSystem`, `ignition::gazebo::RenderSystem`, `ignition::gazebo::LogSystem`, etc.\n\nThose more-derived System classes should be responsible for knowing what interfaces to use from each library that they're designed to interface with. So instead of asking the `System` interface for what its type is, I would recommend something more like this \\(this is conceptual code, so some details might be missing and style might be lazy\\):\n\n    class System\n    {\n    public:\n    \n      // Tell this system which plugin to use\n      // Returns false if the plugin doesn't have the interface(s) needed by this system\n      virtual bool UsePlugin(const ignition::plugin::PluginPtr &_plugin) = 0;\n    \n      // Initialize the system\n      // Note: maybe this should be combined with UsePlugin, e.g.:\n      // virtual void Init(const ignition::plugin::PluginPtr &_plugin, EntityQueryRegistrar &_register) = 0;\n      // That might depend on how/if we want to support hotswapping of system plugins.\n      virtual void Init(EntityQueryRegistrar &_register) = 0;\n    \n      // Identify usable plugins. Feel free to change this function name.\n      virtual std::set<std::string> IdentifyPlugins(const ignition::plugin::Loader &_loader) const = 0;\n    \n      // I would recommend a string for describing system types, since I expect this information\n      // is most relevant to humans using the Gazebo application. That also doesn't lock us in to\n      // a specific set of System types.\n      virtual std::string SystemType() const = 0;\n    };\n\nEach different `System` type, \\(e.g. `PhysicsSystem`, `RenderSystem`, `GuiSystem`, `LogSystem`\\) would only be instantiated once at startup and put into the `SystemManager` \\(or maybe `SystemPluginManager` if that's what we want to call it\\). To discover the relevant plugins for each type of system, the `SystemManager` would call the `IdentifyPlugins(~)` function on the system of interest, passing in the `ignition::plugin::Loader` instance that has already been filled with libraries. The `IdentifyPlugins(~)` function would then pass back a set of the names of the plugins within the loader that have the necessary interface\\(s\\).\n\nIn order to create a basic prototype skeleton, you could consider creating barebones `RenderSystem` and `GuiSystem` classes. I don't know if `ign-rendering` or `ign-gui` has any plugin interfaces to query for, although I do believe that `ign-gui` has been using the plugin system for a while now, so `ign-gui` might have some good interfaces for the `GuiSystem` to \"depend\" on \\(if only for testing purposes\\). But `ign-gui` will need to be updated to the [NewRegistrationScheme](#!/ignitionrobotics/ign-plugin/pull-requests/2) branch of `ign-plugin` to work with this PR.\n\nFor the `PhysicsSystem`, you could consider testing against the [sdf\\_component](#!/ignitionrobotics/ign-physics/pull-requests/29) branch of `ign-physics` and use the `ForwardStep` class as the \"necessary interface\" for `PhysicsSystem` plugins. However, you'd have to use something like: `_loader.PluginsImplementing<ignition::physics::ForwardStep::Implementation<ignition::physics::FeaturePolicy3d>>()` to check for that interface which is kind of gross. Some time soon I'll make some `ign-physics` utilities to make it easier to look for plugins that match a set of features. Note that the `sdf_component` branch is still a WIP, so I haven't done any tests on loading its `ignition-physics0-dartsim` plugin yet.\n\nI apologize for the wall of text, but please let me know if anything I said was confusing or unclear in any way.", "markup": "markdown", "html": "<p>Based on what I'm seeing of the ECS implementation here in <code>ign-gazebo</code>, I don't think the <code>System</code> class should be the \"entry point\" (so to speak) interface for the plugins that are being coordinated by <code>ign-gazebo</code>. And an enumeration is not what I\u2019d recommend for distinguishing between different plugin types, but that\u2019s a somewhat orthogonal (and probably much less important) matter.</p>\n<p>Using the <code>System</code> class as the interface for plugging in different systems results in a critical dependency issue. <code>ign-gazebo</code> is meant to be dependent on the various upstream ignition libraries (e.g. <code>ign-gui</code>, <code>ign-rendering</code>, <code>ign-physics</code>) while those other libraries shouldn't have any dependency on <code>ign-gazebo</code>. If the <code>ignition::gazebo::System</code> class is meant to be the interface class for speaking to the various system plugins, then those plugins will need to depend on <code>ign-gazebo</code> in order to inherit and expose the <code>ignition::gazebo::System</code> class. That means the packages providing the plugins (i.e. <code>ign-gui</code>, <code>ign-rendering</code>, <code>ign-physics</code>) will need to depend on <code>ign-gazebo</code>, leaving us with circular dependencies.</p>\n<p>Instead, it looks to me like the <code>System</code> class is a base class for other <code>ign-gazebo</code> system classes, each of which will be responsible for interfacing with the plugins that are provided by the upstream ignition libraries. Currently it looks like only <code>ignition::gazebo::PhysicsSystem</code> exists, but we could also create <code>ignition::gazebo::GuiSystem</code>, <code>ignition::gazebo::RenderSystem</code>, <code>ignition::gazebo::LogSystem</code>, etc.</p>\n<p>Those more-derived System classes should be responsible for knowing what interfaces to use from each library that they're designed to interface with. So instead of asking the <code>System</code> interface for what its type is, I would recommend something more like this (this is conceptual code, so some details might be missing and style might be lazy):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kr\">class</span> <span class=\"nx\">System</span>\n<span class=\"p\">{</span>\n<span class=\"kr\">public</span><span class=\"o\">:</span>\n\n  <span class=\"c1\">// Tell this system which plugin to use</span>\n  <span class=\"c1\">// Returns false if the plugin doesn&#39;t have the interface(s) needed by this system</span>\n  <span class=\"nx\">virtual</span> <span class=\"kt\">bool</span> <span class=\"nx\">UsePlugin</span><span class=\"p\">(</span><span class=\"kr\">const</span> <span class=\"nx\">ignition</span><span class=\"o\">::</span><span class=\"nx\">plugin</span><span class=\"o\">::</span><span class=\"nx\">PluginPtr</span> <span class=\"o\">&amp;</span><span class=\"nx\">_plugin</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n  <span class=\"c1\">// Initialize the system</span>\n  <span class=\"c1\">// Note: maybe this should be combined with UsePlugin, e.g.:</span>\n  <span class=\"c1\">// virtual void Init(const ignition::plugin::PluginPtr &amp;_plugin, EntityQueryRegistrar &amp;_register) = 0;</span>\n  <span class=\"c1\">// That might depend on how/if we want to support hotswapping of system plugins.</span>\n  <span class=\"nx\">virtual</span> <span class=\"k\">void</span> <span class=\"nx\">Init</span><span class=\"p\">(</span><span class=\"nx\">EntityQueryRegistrar</span> <span class=\"o\">&amp;</span><span class=\"nx\">_register</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n  <span class=\"c1\">// Identify usable plugins. Feel free to change this function name.</span>\n  <span class=\"nx\">virtual</span> <span class=\"nx\">std</span><span class=\"o\">::</span><span class=\"nx\">set</span><span class=\"o\">&lt;</span><span class=\"nx\">std</span><span class=\"o\">::</span><span class=\"kt\">string</span><span class=\"o\">&gt;</span> <span class=\"nx\">IdentifyPlugins</span><span class=\"p\">(</span><span class=\"kr\">const</span> <span class=\"nx\">ignition</span><span class=\"o\">::</span><span class=\"nx\">plugin</span><span class=\"o\">::</span><span class=\"nx\">Loader</span> <span class=\"o\">&amp;</span><span class=\"nx\">_loader</span><span class=\"p\">)</span> <span class=\"kr\">const</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n  <span class=\"c1\">// I would recommend a string for describing system types, since I expect this information</span>\n  <span class=\"c1\">// is most relevant to humans using the Gazebo application. That also doesn&#39;t lock us in to</span>\n  <span class=\"c1\">// a specific set of System types.</span>\n  <span class=\"nx\">virtual</span> <span class=\"nx\">std</span><span class=\"o\">::</span><span class=\"kt\">string</span> <span class=\"nx\">SystemType</span><span class=\"p\">()</span> <span class=\"kr\">const</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</pre></div>\n\n\n<p>Each different <code>System</code> type, (e.g. <code>PhysicsSystem</code>, <code>RenderSystem</code>, <code>GuiSystem</code>, <code>LogSystem</code>) would only be instantiated once at startup and put into the <code>SystemManager</code> (or maybe <code>SystemPluginManager</code> if that's what we want to call it). To discover the relevant plugins for each type of system, the <code>SystemManager</code> would call the <code>IdentifyPlugins(~)</code> function on the system of interest, passing in the <code>ignition::plugin::Loader</code> instance that has already been filled with libraries. The <code>IdentifyPlugins(~)</code> function would then pass back a set of the names of the plugins within the loader that have the necessary interface(s).</p>\n<p>In order to create a basic prototype skeleton, you could consider creating barebones <code>RenderSystem</code> and <code>GuiSystem</code> classes. I don't know if <code>ign-rendering</code> or <code>ign-gui</code> has any plugin interfaces to query for, although I do believe that <code>ign-gui</code> has been using the plugin system for a while now, so <code>ign-gui</code> might have some good interfaces for the <code>GuiSystem</code> to \"depend\" on (if only for testing purposes). But <code>ign-gui</code> will need to be updated to the <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-plugin/pull-requests/2\" rel=\"nofollow\">NewRegistrationScheme</a> branch of <code>ign-plugin</code> to work with this PR.</p>\n<p>For the <code>PhysicsSystem</code>, you could consider testing against the <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/pull-requests/29\" rel=\"nofollow\">sdf_component</a> branch of <code>ign-physics</code> and use the <code>ForwardStep</code> class as the \"necessary interface\" for <code>PhysicsSystem</code> plugins. However, you'd have to use something like: <code>_loader.PluginsImplementing&lt;ignition::physics::ForwardStep::Implementation&lt;ignition::physics::FeaturePolicy3d&gt;&gt;()</code> to check for that interface which is kind of gross. Some time soon I'll make some <code>ign-physics</code> utilities to make it easier to look for plugins that match a set of features. Note that the <code>sdf_component</code> branch is still a WIP, so I haven't done any tests on loading its <code>ignition-physics0-dartsim</code> plugin yet.</p>\n<p>I apologize for the wall of text, but please let me know if anything I said was confusing or unclear in any way.</p>", "type": "rendered"}, "created_on": "2018-08-10T10:15:18.079187+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-08-10T10:18:45.355525+00:00", "type": "pullrequest_comment", "id": 72610483}