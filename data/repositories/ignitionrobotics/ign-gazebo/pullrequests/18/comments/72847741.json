{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72847741.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72847741"}}, "parent": {"id": 72835795, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18/comments/72835795.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18/_/diff#comment-72835795"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/18.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/18"}}, "title": "Implementation of System Plugins"}, "content": {"raw": "If we want every single System to be a complete blackbox, that can work, but then we have to forego the concept of \u201csystem types\u201d, because there wouldn\u2019t be any good way for a System to communicate its role before being instantiated. That leaves us \\(and therefore also end-users\\) without an effective way to inspect the role or purpose of a System.\n\nThat also means that any plugins used by the System \\(e.g. a plugin which provides a physics engine implementation\\) need to be expressed as a Component belonging to an Entity within the ECS, because that\u2019s the only method we\u2019ll have for communicating with a System. So then we\u2019ll have plugins as Components, which may be awkward to serialize and communicate. \\(But then again, maybe we do want plugins to be Components, if that would make it possible to log and communicate the configuration of plugins that are being used?\\)\n\nI guess my conclusion is that we can minimize the `System` interface, but then:\n\n* We should throw away the concept of a system \"type\" and \"name\", because these can\u2019t be known until the System is instantiated anyway. Instead we\u2019ll need to solely categorize Systems by the name of the plugin class that provides the implementation of the `System` interface.\n\n    * \\(Plus if Systems are supposed to be completely blackboxes, then it doesn\u2019t make sense to try to categorize them or allow them to have names besides the unique name of the class that provides its implementation\\)\n    \n* We should figure out what kind of machinery we can devise so that we don\u2019t need each System to re-implement the inspection and loading of plugins that it needs to use internally.\n* We\u2019ll need to somehow componentize the plugins-used-by-systems, because we won\u2019t have any other way to communicate to Systems about what kinds of plugins they should be using internally, besides passing them entities with components attached.\n\n\u200c\n\nEdit:\n\nBut to expand on my comment\n\n> We should throw away the concept of a system \"type\" and \"name\", because these can\u2019t be known until the System is instantiated anyway\n\nWe do have a WIP concept in `ign-plugin` of an \u201calias\u201d for plugins. You\u2019ll be able to register an \u201calias\u201d for your plugin, which effectively becomes an alternative label or name that can be used to identify or instantiate your plugin. Multiple plugins could use the same alias, but if there is more than one plugin with the same alias in the loader at a time, then that alias can no longer be used to instantiate a plugin, and the more specific \\(unique\\) plugin name must be used.\n\nThat feature hasn't been fully developed yet, but if it would be helpful for `ign-gazebo` in managing System plugins, then I can focus on finishing it.", "markup": "markdown", "html": "<p>If we want every single System to be a complete blackbox, that can work, but then we have to forego the concept of \u201csystem types\u201d, because there wouldn\u2019t be any good way for a System to communicate its role before being instantiated. That leaves us (and therefore also end-users) without an effective way to inspect the role or purpose of a System.</p>\n<p>That also means that any plugins used by the System (e.g. a plugin which provides a physics engine implementation) need to be expressed as a Component belonging to an Entity within the ECS, because that\u2019s the only method we\u2019ll have for communicating with a System. So then we\u2019ll have plugins as Components, which may be awkward to serialize and communicate. (But then again, maybe we do want plugins to be Components, if that would make it possible to log and communicate the configuration of plugins that are being used?)</p>\n<p>I guess my conclusion is that we can minimize the <code>System</code> interface, but then:</p>\n<ul>\n<li>\n<p>We should throw away the concept of a system \"type\" and \"name\", because these can\u2019t be known until the System is instantiated anyway. Instead we\u2019ll need to solely categorize Systems by the name of the plugin class that provides the implementation of the <code>System</code> interface.</p>\n<ul>\n<li>(Plus if Systems are supposed to be completely blackboxes, then it doesn\u2019t make sense to try to categorize them or allow them to have names besides the unique name of the class that provides its implementation)</li>\n</ul>\n</li>\n<li>\n<p>We should figure out what kind of machinery we can devise so that we don\u2019t need each System to re-implement the inspection and loading of plugins that it needs to use internally.</p>\n</li>\n<li>We\u2019ll need to somehow componentize the plugins-used-by-systems, because we won\u2019t have any other way to communicate to Systems about what kinds of plugins they should be using internally, besides passing them entities with components attached.</li>\n</ul>\n<p>\u200c</p>\n<p>Edit:</p>\n<p>But to expand on my comment</p>\n<blockquote>\n<p>We should throw away the concept of a system \"type\" and \"name\", because these can\u2019t be known until the System is instantiated anyway</p>\n</blockquote>\n<p>We do have a WIP concept in <code>ign-plugin</code> of an \u201calias\u201d for plugins. You\u2019ll be able to register an \u201calias\u201d for your plugin, which effectively becomes an alternative label or name that can be used to identify or instantiate your plugin. Multiple plugins could use the same alias, but if there is more than one plugin with the same alias in the loader at a time, then that alias can no longer be used to instantiate a plugin, and the more specific (unique) plugin name must be used.</p>\n<p>That feature hasn't been fully developed yet, but if it would be helpful for <code>ign-gazebo</code> in managing System plugins, then I can focus on finishing it.</p>", "type": "rendered"}, "created_on": "2018-08-14T04:57:26.840516+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-08-14T08:24:16.015026+00:00", "type": "pullrequest_comment", "id": 72847741}