{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/314/comments/100905562.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/314/_/diff#comment-100905562"}}, "parent": {"id": 100904617, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/314/comments/100904617.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/314/_/diff#comment-100904617"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 314, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/314.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/314"}}, "title": "[Blueprint] Battery tweaks"}, "content": {"raw": "I took a look at the printouts for different power loads. I think the simplification of SoC by `q/c` is not a correct representation of the charge, even though the equation looks very similar to the integrated one. The only difference is that `q` is the instantaneous charge, whereas the integrated one depends on the history of how the battery has been draining. With the instantaneous charge, the voltage almost decreases linearly to 0 as the charge goes to 0. But according to [plots of SoC vs. voltage online](https://pveducation.com/solar-concepts/battery-state-of-charge-vs-open-circuit-battery-voltage/), that\u2019s not what batteries actually do. At SoC = 0, the voltage is usually only a little lower than the initial voltage.\n\nI tried reverting to the [integrated calculation](#!/ignitionrobotics/ign-gazebo/commits/ae31092febc830d4cba601d17c8de7a23a27147d?at=ign-gazebo1) that uses the historic window of current and time interval, and that produced closer to the real trend, where at SoC = 0, voltage is just a little lower than initially \\(12.592\\):\n\npower load 10:\n\n```\n[Dbg] [LinearBatteryPlugin.cc:307] Battery: linear_battery\n[Dbg] [LinearBatteryPlugin.cc:308] PowerLoads().size(): 1\n[Dbg] [LinearBatteryPlugin.cc:310] voltage: 12.5234\n[Dbg] [LinearBatteryPlugin.cc:311] state of charge: -5.70632e-06 (q 1.15448)\n```\n\npower load 100:\n\n```\n[Dbg] [LinearBatteryPlugin.cc:307] Battery: linear_battery\n[Dbg] [LinearBatteryPlugin.cc:308] PowerLoads().size(): 1\n[Dbg] [LinearBatteryPlugin.cc:310] voltage: 12.0771\n[Dbg] [LinearBatteryPlugin.cc:311] state of charge: -8.6373e-06 (q 1.15438)\n```\n\npower load 200:\n\n```\n[Dbg] [LinearBatteryPlugin.cc:307] Battery: linear_battery\n[Dbg] [LinearBatteryPlugin.cc:308] PowerLoads().size(): 1\n[Dbg] [LinearBatteryPlugin.cc:310] voltage: 11.6405\n[Dbg] [LinearBatteryPlugin.cc:311] state of charge: -0.000174951 (q 1.15428)\n```\n\npower load 500:\n\n```\n[Dbg] [LinearBatteryPlugin.cc:307] Battery: linear_battery\n[Dbg] [LinearBatteryPlugin.cc:308] PowerLoads().size(): 1\n[Dbg] [LinearBatteryPlugin.cc:310] voltage: 10.6182\n[Dbg] [LinearBatteryPlugin.cc:311] state of charge: -0.000488123 (q 1.15405)\n```\n\nWith this calculation, since the SoC always goes to 0 long before the voltage does, we don\u2019t have the negative voltage problem.\n\nThe voltage drops lower as the power load goes higher.\n\nThe only cons, other than it uses more memory and loops, is that it drains a lot faster than `q/c`, but the numbers are closer to real batteries. The rate of drainage is probably affected by the other battery properties. I don\u2019t know where they came from and how real they are. I kept all the numbers the same except bumped the power load - the original is 6.6, and that took 1 minute 22 seconds to drain.\n\nSo, we can either keep the `q/c` and add a heuristic check for negative voltage, or do the integrated calculation which is closer to real batteries but drains faster \\(which might be okay with a bigger battery\\).", "markup": "markdown", "html": "<p>I took a look at the printouts for different power loads. I think the simplification of SoC by <code>q/c</code> is not a correct representation of the charge, even though the equation looks very similar to the integrated one. The only difference is that <code>q</code> is the instantaneous charge, whereas the integrated one depends on the history of how the battery has been draining. With the instantaneous charge, the voltage almost decreases linearly to 0 as the charge goes to 0. But according to <a data-is-external-link=\"true\" href=\"https://pveducation.com/solar-concepts/battery-state-of-charge-vs-open-circuit-battery-voltage/\" rel=\"nofollow\">plots of SoC vs. voltage online</a>, that\u2019s not what batteries actually do. At SoC = 0, the voltage is usually only a little lower than the initial voltage.</p>\n<p>I tried reverting to the <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-gazebo/commits/ae31092febc830d4cba601d17c8de7a23a27147d?at=ign-gazebo1\" rel=\"nofollow\">integrated calculation</a> that uses the historic window of current and time interval, and that produced closer to the real trend, where at SoC = 0, voltage is just a little lower than initially (12.592):</p>\n<p>power load 10:</p>\n<div class=\"codehilite\"><pre><span></span>[Dbg] [LinearBatteryPlugin.cc:307] Battery: linear_battery\n[Dbg] [LinearBatteryPlugin.cc:308] PowerLoads().size(): 1\n[Dbg] [LinearBatteryPlugin.cc:310] voltage: 12.5234\n[Dbg] [LinearBatteryPlugin.cc:311] state of charge: -5.70632e-06 (q 1.15448)\n</pre></div>\n\n\n<p>power load 100:</p>\n<div class=\"codehilite\"><pre><span></span>[Dbg] [LinearBatteryPlugin.cc:307] Battery: linear_battery\n[Dbg] [LinearBatteryPlugin.cc:308] PowerLoads().size(): 1\n[Dbg] [LinearBatteryPlugin.cc:310] voltage: 12.0771\n[Dbg] [LinearBatteryPlugin.cc:311] state of charge: -8.6373e-06 (q 1.15438)\n</pre></div>\n\n\n<p>power load 200:</p>\n<div class=\"codehilite\"><pre><span></span>[Dbg] [LinearBatteryPlugin.cc:307] Battery: linear_battery\n[Dbg] [LinearBatteryPlugin.cc:308] PowerLoads().size(): 1\n[Dbg] [LinearBatteryPlugin.cc:310] voltage: 11.6405\n[Dbg] [LinearBatteryPlugin.cc:311] state of charge: -0.000174951 (q 1.15428)\n</pre></div>\n\n\n<p>power load 500:</p>\n<div class=\"codehilite\"><pre><span></span>[Dbg] [LinearBatteryPlugin.cc:307] Battery: linear_battery\n[Dbg] [LinearBatteryPlugin.cc:308] PowerLoads().size(): 1\n[Dbg] [LinearBatteryPlugin.cc:310] voltage: 10.6182\n[Dbg] [LinearBatteryPlugin.cc:311] state of charge: -0.000488123 (q 1.15405)\n</pre></div>\n\n\n<p>With this calculation, since the SoC always goes to 0 long before the voltage does, we don\u2019t have the negative voltage problem.</p>\n<p>The voltage drops lower as the power load goes higher.</p>\n<p>The only cons, other than it uses more memory and loops, is that it drains a lot faster than <code>q/c</code>, but the numbers are closer to real batteries. The rate of drainage is probably affected by the other battery properties. I don\u2019t know where they came from and how real they are. I kept all the numbers the same except bumped the power load - the original is 6.6, and that took 1 minute 22 seconds to drain.</p>\n<p>So, we can either keep the <code>q/c</code> and add a heuristic check for negative voltage, or do the integrated calculation which is closer to real batteries but drains faster (which might be okay with a bigger battery).</p>", "type": "rendered"}, "created_on": "2019-05-04T04:10:03.329250+00:00", "user": {"display_name": "Mabel Zhang", "uuid": "{4b0e38fb-bf50-45c0-a496-61147518b2bf}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B4b0e38fb-bf50-45c0-a496-61147518b2bf%7D"}, "html": {"href": "https://bitbucket.org/%7B4b0e38fb-bf50-45c0-a496-61147518b2bf%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:ceb5942c-6843-408c-8550-3ce4899d299b/4d48e5ea-cf28-4fa7-9715-8fc9e315d831/128"}}, "nickname": "mabelmzhang", "type": "user", "account_id": "557058:ceb5942c-6843-408c-8550-3ce4899d299b"}, "updated_on": "2019-05-04T04:10:03.342617+00:00", "type": "pullrequest_comment", "id": 100905562}