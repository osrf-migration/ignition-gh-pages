{"rendered": {"description": {"raw": "The general idea here is put each of the `PostUpdate` calls \\(for systems that implement them\\) in their own worker thread. They are syncronized via two barriers \\(which isn\u2019t in the C\\+\\+ standard yet\\).\r\n\r\nCreating a thread and using a barrier ends up being slightly more efficient than the ign::common::WorkerPool, because we aren\u2019t creating and destroying WorkOrders in each loop. This is only really possible because we\u2019re making the same function calls repeatedly.\r\n\r\nThe barriers will block until all threads have reached the `barrier.wait()` call. This is why the barriers are constructed with a count of `number of postupdates + 1 (for the main thread)`\r\n\r\nEdit:\r\n\r\nThis now includes a worker thread for rendering sensors, causing rendering updates to happen in parallel with the main thread.  In the case that a new rendering operation is required, the main thread will block until the previous one is complete.  \r\n\r\nThis generally eliminates frames that substantially overran their allotted time \\(a rendering update could take 30-60x the allotted time\\).", "markup": "markdown", "html": "<p>The general idea here is put each of the <code>PostUpdate</code> calls (for systems that implement them) in their own worker thread. They are syncronized via two barriers (which isn\u2019t in the C++ standard yet).</p>\n<p>Creating a thread and using a barrier ends up being slightly more efficient than the ign::common::WorkerPool, because we aren\u2019t creating and destroying WorkOrders in each loop. This is only really possible because we\u2019re making the same function calls repeatedly.</p>\n<p>The barriers will block until all threads have reached the <code>barrier.wait()</code> call. This is why the barriers are constructed with a count of <code>number of postupdates + 1 (for the main thread)</code></p>\n<p>Edit:</p>\n<p>This now includes a worker thread for rendering sensors, causing rendering updates to happen in parallel with the main thread.  In the case that a new rendering operation is required, the main thread will block until the previous one is complete.  </p>\n<p>This generally eliminates frames that substantially overran their allotted time (a rendering update could take 30-60x the allotted time).</p>", "type": "rendered"}, "title": {"raw": "Add worker threads for System PostUpdate phase", "markup": "markdown", "html": "<p>Add worker threads for System PostUpdate phase</p>", "type": "rendered"}}, "type": "pullrequest", "description": "The general idea here is put each of the `PostUpdate` calls \\(for systems that implement them\\) in their own worker thread. They are syncronized via two barriers \\(which isn\u2019t in the C\\+\\+ standard yet\\).\r\n\r\nCreating a thread and using a barrier ends up being slightly more efficient than the ign::common::WorkerPool, because we aren\u2019t creating and destroying WorkOrders in each loop. This is only really possible because we\u2019re making the same function calls repeatedly.\r\n\r\nThe barriers will block until all threads have reached the `barrier.wait()` call. This is why the barriers are constructed with a count of `number of postupdates + 1 (for the main thread)`\r\n\r\nEdit:\r\n\r\nThis now includes a worker thread for rendering sensors, causing rendering updates to happen in parallel with the main thread.  In the case that a new rendering operation is required, the main thread will block until the previous one is complete.  \r\n\r\nThis generally eliminates frames that substantially overran their allotted time \\(a rendering update could take 30-60x the allotted time\\).", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-gazebo/pullrequests/387/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-gazebo/diffstat/ignitionrobotics/ign-gazebo:14dfe2875236%0Dcc505203a1d8?from_pullrequest_id=387"}, "commits": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/387/commits.json"}, "self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/387.json"}, "comments": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/387/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-gazebo/pullrequests/387/merge"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/387"}, "activity": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/387/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-gazebo/diff/ignitionrobotics/ign-gazebo:14dfe2875236%0Dcc505203a1d8?from_pullrequest_id=387"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-gazebo/pullrequests/387/approve"}, "statuses": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/387/statuses_page=1.json"}}, "title": "Add worker threads for System PostUpdate phase", "close_source_branch": true, "reviewers": [{"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, {"display_name": "Addisu Z. Taddese", "uuid": "{9d7fdc68-d270-4080-bf03-4df0d0dbf635}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B9d7fdc68-d270-4080-bf03-4df0d0dbf635%7D"}, "html": {"href": "https://bitbucket.org/%7B9d7fdc68-d270-4080-bf03-4df0d0dbf635%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:90bc87b0-2886-4377-a17c-3a6629a697ff/afbf9be5-1e4c-4810-89d4-e58831f34b11/128"}}, "nickname": "azeey", "type": "user", "account_id": "557058:90bc87b0-2886-4377-a17c-3a6629a697ff"}], "id": 387, "destination": {"commit": {"hash": "cc505203a1d8", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/commit/cc505203a1d8.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/commits/cc505203a1d8"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f98d11fe-f287-4dfb-99c3-e2b76a13232e}ts=2082645"}}, "type": "repository", "name": "ign-gazebo", "full_name": "ignitionrobotics/ign-gazebo", "uuid": "{f98d11fe-f287-4dfb-99c3-e2b76a13232e}"}, "branch": {"name": "ign-gazebo2"}}, "created_on": "2019-07-18T21:03:47.022640+00:00", "summary": {"raw": "The general idea here is put each of the `PostUpdate` calls \\(for systems that implement them\\) in their own worker thread. They are syncronized via two barriers \\(which isn\u2019t in the C\\+\\+ standard yet\\).\r\n\r\nCreating a thread and using a barrier ends up being slightly more efficient than the ign::common::WorkerPool, because we aren\u2019t creating and destroying WorkOrders in each loop. This is only really possible because we\u2019re making the same function calls repeatedly.\r\n\r\nThe barriers will block until all threads have reached the `barrier.wait()` call. This is why the barriers are constructed with a count of `number of postupdates + 1 (for the main thread)`\r\n\r\nEdit:\r\n\r\nThis now includes a worker thread for rendering sensors, causing rendering updates to happen in parallel with the main thread.  In the case that a new rendering operation is required, the main thread will block until the previous one is complete.  \r\n\r\nThis generally eliminates frames that substantially overran their allotted time \\(a rendering update could take 30-60x the allotted time\\).", "markup": "markdown", "html": "<p>The general idea here is put each of the <code>PostUpdate</code> calls (for systems that implement them) in their own worker thread. They are syncronized via two barriers (which isn\u2019t in the C++ standard yet).</p>\n<p>Creating a thread and using a barrier ends up being slightly more efficient than the ign::common::WorkerPool, because we aren\u2019t creating and destroying WorkOrders in each loop. This is only really possible because we\u2019re making the same function calls repeatedly.</p>\n<p>The barriers will block until all threads have reached the <code>barrier.wait()</code> call. This is why the barriers are constructed with a count of <code>number of postupdates + 1 (for the main thread)</code></p>\n<p>Edit:</p>\n<p>This now includes a worker thread for rendering sensors, causing rendering updates to happen in parallel with the main thread.  In the case that a new rendering operation is required, the main thread will block until the previous one is complete.  </p>\n<p>This generally eliminates frames that substantially overran their allotted time (a rendering update could take 30-60x the allotted time).</p>", "type": "rendered"}, "source": {"commit": {"hash": "5fc2091317a6", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/commit/5fc2091317a6.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/commits/5fc2091317a6"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f98d11fe-f287-4dfb-99c3-e2b76a13232e}ts=2082645"}}, "type": "repository", "name": "ign-gazebo", "full_name": "ignitionrobotics/ign-gazebo", "uuid": "{f98d11fe-f287-4dfb-99c3-e2b76a13232e}"}, "branch": {"name": "thread_postupdate"}}, "comment_count": 42, "state": "MERGED", "task_count": 0, "participants": [{"role": "PARTICIPANT", "participated_on": "2019-07-31T20:49:32.528361+00:00", "type": "participant", "approved": false, "user": {"display_name": "Michael Carroll", "uuid": "{17dbbc15-cbc0-42f0-a985-cde9061c78a0}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D"}, "html": {"href": "https://bitbucket.org/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:65740f22-cc56-4418-9608-7e17d0ed47b7/2aa259f5-4de1-4f68-9156-eded72041d84/128"}}, "nickname": "Michael Carroll", "type": "user", "account_id": "557058:65740f22-cc56-4418-9608-7e17d0ed47b7"}}, {"role": "REVIEWER", "participated_on": "2019-07-31T22:59:59.714198+00:00", "type": "participant", "approved": true, "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}}, {"role": "PARTICIPANT", "participated_on": "2019-07-26T21:22:01.265752+00:00", "type": "participant", "approved": false, "user": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}}, {"role": "REVIEWER", "participated_on": "2019-08-02T17:02:50.232851+00:00", "type": "participant", "approved": true, "user": {"display_name": "Addisu Z. Taddese", "uuid": "{9d7fdc68-d270-4080-bf03-4df0d0dbf635}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B9d7fdc68-d270-4080-bf03-4df0d0dbf635%7D"}, "html": {"href": "https://bitbucket.org/%7B9d7fdc68-d270-4080-bf03-4df0d0dbf635%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:90bc87b0-2886-4377-a17c-3a6629a697ff/afbf9be5-1e4c-4810-89d4-e58831f34b11/128"}}, "nickname": "azeey", "type": "user", "account_id": "557058:90bc87b0-2886-4377-a17c-3a6629a697ff"}}], "reason": "", "updated_on": "2019-08-02T19:00:23.397695+00:00", "author": {"display_name": "Michael Carroll", "uuid": "{17dbbc15-cbc0-42f0-a985-cde9061c78a0}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D"}, "html": {"href": "https://bitbucket.org/%7B17dbbc15-cbc0-42f0-a985-cde9061c78a0%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:65740f22-cc56-4418-9608-7e17d0ed47b7/2aa259f5-4de1-4f68-9156-eded72041d84/128"}}, "nickname": "Michael Carroll", "type": "user", "account_id": "557058:65740f22-cc56-4418-9608-7e17d0ed47b7"}, "merge_commit": {"hash": "14dfe2875236", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/commit/14dfe2875236.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/commits/14dfe2875236"}}}, "closed_by": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}}