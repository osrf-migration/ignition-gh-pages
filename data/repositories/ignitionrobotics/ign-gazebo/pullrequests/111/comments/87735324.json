{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/111/comments/87735324.json"}, "code": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-gazebo/diff/ignitionrobotics/ign-gazebo:31ed21addf1f..6264cbd5eccc?path=src%2FLevelManager.cc"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/111/_/diff#comment-87735324"}}, "parent": {"id": 87692972, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/111/comments/87692972.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/111/_/diff#comment-87692972"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 111, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/pullrequests/111.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/pull-requests/111"}}, "title": "[A-1] Levels"}, "content": {"raw": "> **ign-gui/ign-rendering**: When entities are \"inactive\", should they be destroyed or hidden\u00a0\n\nI don\u2019t have enough experience with Ogre, but I know that for OpenSceneGraph something that\u2019s worked for me is to remove objects from the scene graph without deleting them. That improves rendering performance without completely deleting those graphics resources, so they could easily be added back into the scene graph when they\u2019re needed. The catch is, if you have really really super large/detailed environments, you could run out of RAM if the whole environment is too big to store all at once. This is basically what video games have loading screens for: changing what graphics asset information is currently being held in RAM.\n\nI think the choice between the two will depend a lot on the specific application. Ideally we could have a way to offer both behaviors, but I don\u2019t know exactly what that would look like. For now we should probably choose one to start with and see how it works for our use case.\n\n> **ign-physics**: I guess if the physics engine supports disabling entities, \"inactive\" would mean disable. Otherwise, we would remove the entity from the physics engine for both \"inactive\" and \"erased\".\n\nI completely agree with this. The hard part will be identifying which physics engines offer that behavior \\(because that information can\u2019t be inferred from the feature system alone\\). This shouldn\u2019t be any trouble once we have the \u201cBehavior System\u201d implemented, but that hasn\u2019t really made it to my TODO list at the moment \\(unfortunately\\).", "markup": "markdown", "html": "<blockquote>\n<p><strong>ign-gui/ign-rendering</strong>: When entities are \"inactive\", should they be destroyed or hidden\u00a0</p>\n</blockquote>\n<p>I don\u2019t have enough experience with Ogre, but I know that for OpenSceneGraph something that\u2019s worked for me is to remove objects from the scene graph without deleting them. That improves rendering performance without completely deleting those graphics resources, so they could easily be added back into the scene graph when they\u2019re needed. The catch is, if you have really really super large/detailed environments, you could run out of RAM if the whole environment is too big to store all at once. This is basically what video games have loading screens for: changing what graphics asset information is currently being held in RAM.</p>\n<p>I think the choice between the two will depend a lot on the specific application. Ideally we could have a way to offer both behaviors, but I don\u2019t know exactly what that would look like. For now we should probably choose one to start with and see how it works for our use case.</p>\n<blockquote>\n<p><strong>ign-physics</strong>: I guess if the physics engine supports disabling entities, \"inactive\" would mean disable. Otherwise, we would remove the entity from the physics engine for both \"inactive\" and \"erased\".</p>\n</blockquote>\n<p>I completely agree with this. The hard part will be identifying which physics engines offer that behavior (because that information can\u2019t be inferred from the feature system alone). This shouldn\u2019t be any trouble once we have the \u201cBehavior System\u201d implemented, but that hasn\u2019t really made it to my TODO list at the moment (unfortunately).</p>", "type": "rendered"}, "created_on": "2019-01-11T02:57:45.137304+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {"to": 444, "from": null, "outdated": true, "path": "src/LevelManager.cc"}, "updated_on": "2019-01-11T02:57:45.145560+00:00", "type": "pullrequest_comment", "id": 87735324}