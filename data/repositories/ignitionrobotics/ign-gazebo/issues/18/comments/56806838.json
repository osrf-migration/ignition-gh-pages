{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/18/comments/56806838.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/issues/18#comment-56806838"}}, "issue": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/18.json"}}, "type": "issue", "id": 18, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f98d11fe-f287-4dfb-99c3-e2b76a13232e}ts=2082645"}}, "type": "repository", "name": "ign-gazebo", "full_name": "ignitionrobotics/ign-gazebo", "uuid": "{f98d11fe-f287-4dfb-99c3-e2b76a13232e}"}, "title": "Support for multiple worlds"}, "content": {"raw": "Quick update. With fixed-base simple models like pendulum and cartpole the mutex workaround is effective as I reported in my last comment.\n\nHowever, with complex floating-base models like a humanoid robot with meshes both for visual and collisions, a multiworld setup still segfaults.\n\nI managed to \u201cisolate\u201d the problem, if we can say it. In `PhysicsPrivate::Step`, locking the same mutex in [this scope](#!/ignitionrobotics/ign-gazebo/src/8064b9eb40bec9b02d1417a7b252a6402ce32980/src/systems/physics/Physics.cc#lines-821:823) prevents the segfault. Though, this is _not_ a solution since it means that the real step of the world is not concurrently executed by the threads that handle the different worlds \\(one for each `SimulationRunner`\\). In other words, this mutex prevents stepping the worlds in parallel. I think that parallel execution within a single process is the main feature that triggers downstream users to use a multiworld setup.\n\nHere below the stack trace \\([text here](https://pastebin.com/BRC6NeLu)\\):\n\n![](data/bitbucket.org/repo/8zodKzn/images/370193615-Screenshot_20200406_094157.png)\n\u200c", "markup": "markdown", "html": "<p>Quick update. With fixed-base simple models like pendulum and cartpole the mutex workaround is effective as I reported in my last comment.</p>\n<p>However, with complex floating-base models like a humanoid robot with meshes both for visual and collisions, a multiworld setup still segfaults.</p>\n<p>I managed to \u201cisolate\u201d the problem, if we can say it. In <code>PhysicsPrivate::Step</code>, locking the same mutex in <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-gazebo/src/8064b9eb40bec9b02d1417a7b252a6402ce32980/src/systems/physics/Physics.cc#lines-821:823\" rel=\"nofollow\">this scope</a> prevents the segfault. Though, this is <em>not</em> a solution since it means that the real step of the world is not concurrently executed by the threads that handle the different worlds (one for each <code>SimulationRunner</code>). In other words, this mutex prevents stepping the worlds in parallel. I think that parallel execution within a single process is the main feature that triggers downstream users to use a multiworld setup.</p>\n<p>Here below the stack trace (<a data-is-external-link=\"true\" href=\"https://pastebin.com/BRC6NeLu\" rel=\"nofollow\">text here</a>):</p>\n<p><img alt=\"\" src=\"data/bitbucket.org/repo/8zodKzn/images/370193615-Screenshot_20200406_094157.png\" />\n\u200c</p>", "type": "rendered"}, "created_on": "2020-04-06T07:44:26.589131+00:00", "user": {"display_name": "Diego Ferigo", "uuid": "{994b27a5-7d6d-42b2-8aa7-2ea82fbe7bf6}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B994b27a5-7d6d-42b2-8aa7-2ea82fbe7bf6%7D"}, "html": {"href": "https://bitbucket.org/%7B994b27a5-7d6d-42b2-8aa7-2ea82fbe7bf6%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:054df869-5cda-48f2-8b4e-81a61c133346/130cd3bf-aa0a-4355-bec2-c90f195acc4c/128"}}, "nickname": "dgferigo", "type": "user", "account_id": "557058:054df869-5cda-48f2-8b4e-81a61c133346"}, "updated_on": null, "type": "issue_comment", "id": 56806838}