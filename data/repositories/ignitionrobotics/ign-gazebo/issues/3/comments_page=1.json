{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3/comments/48258925.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/issues/3#comment-48258925"}}, "issue": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3.json"}}, "type": "issue", "id": 3, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f98d11fe-f287-4dfb-99c3-e2b76a13232e}ts=2082645"}}, "type": "repository", "name": "ign-gazebo", "full_name": "ignitionrobotics/ign-gazebo", "uuid": "{f98d11fe-f287-4dfb-99c3-e2b76a13232e}"}, "title": "Pose components"}, "content": {"raw": "Following up on [this remark](#!/ignitionrobotics/ign-gazebo/pull-requests/57/ensure-correct-transform-for-canonical/diff#comment-78494909):\n\n> I'm not sure about the world frame being \"almost always the most useful frame of reference for systems\" though, lots of rendering frameworks position nodes relative to parent nodes.\n\nMany rendering engine APIs (e.g. Ogre and OpenSceneGraph) *allow* users to define tree structures and provide relative transforms because they assume that a tree structure is convenient for users when expressing the layout of objects, and most of the time this is definitely the case.\n\nHowever this means the rendering engine is performing forward kinematics computations, but in our ECS framework specifically we're already computing forward kinematics by necessity in the physics system. It would be wasteful and unnecessary for both systems to compute forward kinematics. In the `libdartsim-gui-osg` (which is DART integrated with OpenSceneGraph) we construct a \"scene graph\" where every object node is just a direct child of the root, and DART simply feeds in the object transforms with respect to the world which were already computed during the physics update. That saves the rendering engine from doing a whole ton of redundant matrix computations.\n\nIn general, the best possible way to be able to transform between different frames of reference is to have **all** transform data provided in the world frame and do a single inverse-matrix-multiply operation to switch between reference frames. We don't need the sophistication that TF has because TF assumes that there is no canonical \"world frame\", but as a simulation engine with full world knowledge, we have the benefit of a definitive world frame, and we should take advantage of that.\n\nThis world frame approach is essentially how Frame Semantics currently works in `ign-physics`. The Frame Semantics implementation assumes an underlying ECS framework because `ign-physics` is itself an ECS, so we could potentially adapt the frame semantics implementation for `ign-gazebo` by moving the core components upstream to `ign-math`. The overall implementation was intended for Eigen, but the core templates like [RelativeQuantity](#!/ignitionrobotics/ign-physics/src/default/include/ignition/physics/RelativeQuantity.hh) and classes like [FrameID](#!/ignitionrobotics/ign-physics/src/default/include/ignition/physics/FrameID.hh) can use `ign-gazebo` as its ECS and `ign-math` as its arithmetic library.\n\nNote that we can represent pose information in the world frame while still maintaining a \"parent\" concept as a separate component. Then if the \"pose relative to parent\" of a child is requested, it would simply be `P.inverse() * C` where `P` is the parent pose in the world while `C` is the child pose in the world.", "markup": "markdown", "html": "<p>Following up on <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-gazebo/pull-requests/57/ensure-correct-transform-for-canonical/diff#comment-78494909\" rel=\"nofollow\">this remark</a>:</p>\n<blockquote>\n<p>I'm not sure about the world frame being \"almost always the most useful frame of reference for systems\" though, lots of rendering frameworks position nodes relative to parent nodes.</p>\n</blockquote>\n<p>Many rendering engine APIs (e.g. Ogre and OpenSceneGraph) <em>allow</em> users to define tree structures and provide relative transforms because they assume that a tree structure is convenient for users when expressing the layout of objects, and most of the time this is definitely the case.</p>\n<p>However this means the rendering engine is performing forward kinematics computations, but in our ECS framework specifically we're already computing forward kinematics by necessity in the physics system. It would be wasteful and unnecessary for both systems to compute forward kinematics. In the <code>libdartsim-gui-osg</code> (which is DART integrated with OpenSceneGraph) we construct a \"scene graph\" where every object node is just a direct child of the root, and DART simply feeds in the object transforms with respect to the world which were already computed during the physics update. That saves the rendering engine from doing a whole ton of redundant matrix computations.</p>\n<p>In general, the best possible way to be able to transform between different frames of reference is to have <strong>all</strong> transform data provided in the world frame and do a single inverse-matrix-multiply operation to switch between reference frames. We don't need the sophistication that TF has because TF assumes that there is no canonical \"world frame\", but as a simulation engine with full world knowledge, we have the benefit of a definitive world frame, and we should take advantage of that.</p>\n<p>This world frame approach is essentially how Frame Semantics currently works in <code>ign-physics</code>. The Frame Semantics implementation assumes an underlying ECS framework because <code>ign-physics</code> is itself an ECS, so we could potentially adapt the frame semantics implementation for <code>ign-gazebo</code> by moving the core components upstream to <code>ign-math</code>. The overall implementation was intended for Eigen, but the core templates like <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/src/default/include/ignition/physics/RelativeQuantity.hh\" rel=\"nofollow\">RelativeQuantity</a> and classes like <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-physics/src/default/include/ignition/physics/FrameID.hh\" rel=\"nofollow\">FrameID</a> can use <code>ign-gazebo</code> as its ECS and <code>ign-math</code> as its arithmetic library.</p>\n<p>Note that we can represent pose information in the world frame while still maintaining a \"parent\" concept as a separate component. Then if the \"pose relative to parent\" of a child is requested, it would simply be <code>P.inverse() * C</code> where <code>P</code> is the parent pose in the world while <code>C</code> is the child pose in the world.</p>", "type": "rendered"}, "created_on": "2018-10-10T03:25:10.323120+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-10-10T03:32:05.294710+00:00", "type": "issue_comment", "id": 48258925}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3/comments/48258950.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/issues/3#comment-48258950"}}, "issue": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3.json"}}, "type": "issue", "id": 3, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f98d11fe-f287-4dfb-99c3-e2b76a13232e}ts=2082645"}}, "type": "repository", "name": "ign-gazebo", "full_name": "ignitionrobotics/ign-gazebo", "uuid": "{f98d11fe-f287-4dfb-99c3-e2b76a13232e}"}, "title": "Pose components"}, "content": {"raw": "> Who is the parent of a joint entity and how does its pose get defined?\n\nThis is a really tough question to be honest, since there are two transforms that could be considered:\n\n1. The transform from the parent link to the joint assuming zeroed-out joint positions\n\n2. The transform of (1) multiplied by the transform produced by the current set of joint positions\n\nI think (1) is the more common convention for trying to define a \"joint pose\".\n\nAlthough I would definitely say that the parent link should be considered the \"parent\" of a joint.", "markup": "markdown", "html": "<blockquote>\n<p>Who is the parent of a joint entity and how does its pose get defined?</p>\n</blockquote>\n<p>This is a really tough question to be honest, since there are two transforms that could be considered:</p>\n<ol>\n<li>\n<p>The transform from the parent link to the joint assuming zeroed-out joint positions</p>\n</li>\n<li>\n<p>The transform of (1) multiplied by the transform produced by the current set of joint positions</p>\n</li>\n</ol>\n<p>I think (1) is the more common convention for trying to define a \"joint pose\".</p>\n<p>Although I would definitely say that the parent link should be considered the \"parent\" of a joint.</p>", "type": "rendered"}, "created_on": "2018-10-10T03:29:27.537316+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-10-10T03:30:09.383078+00:00", "type": "issue_comment", "id": 48258950}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3/comments/48260363.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/issues/3#comment-48260363"}}, "issue": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3.json"}}, "type": "issue", "id": 3, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f98d11fe-f287-4dfb-99c3-e2b76a13232e}ts=2082645"}}, "type": "repository", "name": "ign-gazebo", "full_name": "ignitionrobotics/ign-gazebo", "uuid": "{f98d11fe-f287-4dfb-99c3-e2b76a13232e}"}, "title": "Pose components"}, "content": {"raw": "> I lean towards the pose always being expressed w.r.t. the parent entity, as opposed to any other ancestor closer to the root (like the world or the root model). The main reason being that an entity knows who their immediate parent entity is, but it would necessary to crawl the entity tree to figure our who the other descendant would be.\n\nThis makes the ability to convert between different frames of reference strictly more difficult and more expensive. This means we always need to climb a tree and compute a chain of matrix transforms (including matrix inversions) in order to transform to a different arbitrary reference frame. However, if poses are always expressed in the world frame (e.g. `T_A` is the pose of body `A` in the world and `T_B` is the pose of body `B` in the world) then the transform of `B` relative to `A` (i.e. `A_T_B`) would always simply be `A_T_B = T_A.inverse() * T_B`. This is true for **any** two bodies `A` and `B`, no matter what kind of parent/child relationship they might or might not have.", "markup": "markdown", "html": "<blockquote>\n<p>I lean towards the pose always being expressed w.r.t. the parent entity, as opposed to any other ancestor closer to the root (like the world or the root model). The main reason being that an entity knows who their immediate parent entity is, but it would necessary to crawl the entity tree to figure our who the other descendant would be.</p>\n</blockquote>\n<p>This makes the ability to convert between different frames of reference strictly more difficult and more expensive. This means we always need to climb a tree and compute a chain of matrix transforms (including matrix inversions) in order to transform to a different arbitrary reference frame. However, if poses are always expressed in the world frame (e.g. <code>T_A</code> is the pose of body <code>A</code> in the world and <code>T_B</code> is the pose of body <code>B</code> in the world) then the transform of <code>B</code> relative to <code>A</code> (i.e. <code>A_T_B</code>) would always simply be <code>A_T_B = T_A.inverse() * T_B</code>. This is true for <strong>any</strong> two bodies <code>A</code> and <code>B</code>, no matter what kind of parent/child relationship they might or might not have.</p>", "type": "rendered"}, "created_on": "2018-10-10T05:59:27.642827+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": null, "type": "issue_comment", "id": 48260363}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3/comments/48271785.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/issues/3#comment-48271785"}}, "issue": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3.json"}}, "type": "issue", "id": 3, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f98d11fe-f287-4dfb-99c3-e2b76a13232e}ts=2082645"}}, "type": "repository", "name": "ign-gazebo", "full_name": "ignitionrobotics/ign-gazebo", "uuid": "{f98d11fe-f287-4dfb-99c3-e2b76a13232e}"}, "title": "Pose components"}, "content": {"raw": "There are a couple topics here:\n\n1) How is frame information represented on disk, such as in SDF and log files.\n\n2) How is frame information represented in memory.\n\n3) How is frame information communicated between libraries, and across the wire.\n\nThanks for opening this issue Louise, but I'm now feeling that this topic will grow sufficiently complex that we need a new (and final) design document. See pull request #58.", "markup": "markdown", "html": "<p>There are a couple topics here:</p>\n<p>1) How is frame information represented on disk, such as in SDF and log files.</p>\n<p>2) How is frame information represented in memory.</p>\n<p>3) How is frame information communicated between libraries, and across the wire.</p>\n<p>Thanks for opening this issue Louise, but I'm now feeling that this topic will grow sufficiently complex that we need a new (and final) design document. See <a href=\"#!/ignitionrobotics/ign-gazebo/pull-requests/58/wip-frame-design-document\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #58</a>.</p>", "type": "rendered"}, "created_on": "2018-10-10T15:33:28.553155+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2018-10-10T15:39:44.356426+00:00", "type": "issue_comment", "id": 48271785}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3/comments/48273893.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/issues/3#comment-48273893"}}, "issue": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3.json"}}, "type": "issue", "id": 3, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f98d11fe-f287-4dfb-99c3-e2b76a13232e}ts=2082645"}}, "type": "repository", "name": "ign-gazebo", "full_name": "ignitionrobotics/ign-gazebo", "uuid": "{f98d11fe-f287-4dfb-99c3-e2b76a13232e}"}, "title": "Pose components"}, "content": {"raw": "I agree with most of your points, @mxgrey , and I agree they make sense for a physics engine, but I think you're not taking a few characteristics of `ign-gazebo` into account. Having all nodes expressed w.r.t. the world frame is convenient when all frames are always being updated. But this is not the case here (at least for now). Think of this scenario:\n\nConsider the following SDF:\n\n~~~\n<model ...>\n  <link ...>\n    <visual ...>\n   <collision ...>\n   <sensor...>\n      <imu...>\n   </sensor>\n</model>\n~~~\n\nWhen loaded, the following entities are created in the ECS, each with its own pose component: `model`, `link`, `visual`, `collision`, `imu`.\n\nThe physics system will handle `model`, `link` and `collision`, but it is unaware of `visual` and `imu`.\n\nThe rendering system builds a tree for `model`, `link` and `visual`, and an IMU system handles `imu`.\n\nThe next time-step, the model is supposed to move, but the link and collision poses w.r.t. the model remained the same (a very common situation).\n\nLet's see what each system will need to do in each approach:\n\n### World as reference\n\n* Physics will need to update the `model`, `link` and `collision` poses, because they all changed w.r.t. the world.\n* Rendering will need to crawl the tree to find `visual`'s parent `link`, and add the visual pose offset to update the node on ign-rendering that is attached to the world.\n* IMU system will need to find the IMU's parent `link`, add `imu`'s pose offset, and then perform calculations.\n\n### Parent as reference\n\n* Physics only updates the `model` pose.\n* Rendering will update `model`'s pose, and `ign-rendering` takes care of moving all descendants accordingly.\n* IMU system will need to compute FK all the way down to `imu`, and then perform calculations.\n\nSummarizing the advantages of the 2nd approach:\n\n1. Offsets which are fixed most of the time don't need to be continuously updated through the ECS - which means less data flying around.\n1. Systems can delegate FK computation to other libraries, like `ign-rendering`, to take advantage of their scene graph.", "markup": "markdown", "html": "<p>I agree with most of your points, @mxgrey , and I agree they make sense for a physics engine, but I think you're not taking a few characteristics of <code>ign-gazebo</code> into account. Having all nodes expressed w.r.t. the world frame is convenient when all frames are always being updated. But this is not the case here (at least for now). Think of this scenario:</p>\n<p>Consider the following SDF:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"nt\">&lt;model</span> <span class=\"err\">...</span><span class=\"nt\">&gt;</span>\n  <span class=\"nt\">&lt;link</span> <span class=\"err\">...</span><span class=\"nt\">&gt;</span>\n    <span class=\"nt\">&lt;visual</span> <span class=\"err\">...</span><span class=\"nt\">&gt;</span>\n   <span class=\"nt\">&lt;collision</span> <span class=\"err\">...</span><span class=\"nt\">&gt;</span>\n   <span class=\"nt\">&lt;sensor...&gt;</span>\n      <span class=\"nt\">&lt;imu...&gt;</span>\n   <span class=\"nt\">&lt;/sensor&gt;</span>\n<span class=\"nt\">&lt;/model&gt;</span>\n</pre></div>\n\n\n<p>When loaded, the following entities are created in the ECS, each with its own pose component: <code>model</code>, <code>link</code>, <code>visual</code>, <code>collision</code>, <code>imu</code>.</p>\n<p>The physics system will handle <code>model</code>, <code>link</code> and <code>collision</code>, but it is unaware of <code>visual</code> and <code>imu</code>.</p>\n<p>The rendering system builds a tree for <code>model</code>, <code>link</code> and <code>visual</code>, and an IMU system handles <code>imu</code>.</p>\n<p>The next time-step, the model is supposed to move, but the link and collision poses w.r.t. the model remained the same (a very common situation).</p>\n<p>Let's see what each system will need to do in each approach:</p>\n<h3 id=\"markdown-header-world-as-reference\">World as reference</h3>\n<ul>\n<li>Physics will need to update the <code>model</code>, <code>link</code> and <code>collision</code> poses, because they all changed w.r.t. the world.</li>\n<li>Rendering will need to crawl the tree to find <code>visual</code>'s parent <code>link</code>, and add the visual pose offset to update the node on ign-rendering that is attached to the world.</li>\n<li>IMU system will need to find the IMU's parent <code>link</code>, add <code>imu</code>'s pose offset, and then perform calculations.</li>\n</ul>\n<h3 id=\"markdown-header-parent-as-reference\">Parent as reference</h3>\n<ul>\n<li>Physics only updates the <code>model</code> pose.</li>\n<li>Rendering will update <code>model</code>'s pose, and <code>ign-rendering</code> takes care of moving all descendants accordingly.</li>\n<li>IMU system will need to compute FK all the way down to <code>imu</code>, and then perform calculations.</li>\n</ul>\n<p>Summarizing the advantages of the 2nd approach:</p>\n<ol>\n<li>Offsets which are fixed most of the time don't need to be continuously updated through the ECS - which means less data flying around.</li>\n<li>Systems can delegate FK computation to other libraries, like <code>ign-rendering</code>, to take advantage of their scene graph.</li>\n</ol>", "type": "rendered"}, "created_on": "2018-10-10T17:32:59.488796+00:00", "user": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}, "updated_on": null, "type": "issue_comment", "id": 48273893}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3/comments/48280359.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/issues/3#comment-48280359"}}, "issue": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3.json"}}, "type": "issue", "id": 3, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f98d11fe-f287-4dfb-99c3-e2b76a13232e}ts=2082645"}}, "type": "repository", "name": "ign-gazebo", "full_name": "ignitionrobotics/ign-gazebo", "uuid": "{f98d11fe-f287-4dfb-99c3-e2b76a13232e}"}, "title": "Pose components"}, "content": {"raw": "Updating the transform of non-physical entities is a great point! That definitely rules out the assumption that the physics system can be singularly responsible for all FK computation.\n\n### Parent as a reference\n\n> Physics only updates the model pose.\n\nI assume in this approach, physics will also update the relative poses of all physical entities. Note that in most cases (like ODE), this means the physics system will additionally have to compute `T_P.inverse() * T_E` for each entity `E` (where `T_P` is the world transform of the entity's parent and `T_E` is the world transform of the entity) and put this into the ECS. This isn't a terrible cost, but it's wasteful when the alternative is for it to just copy each `T_E` directly into the ECS and let rendering (and other systems) leverage world transforms of entities instead of recomputing the FK.\n\n> Offsets which are fixed most of the time don't need to be continuously updated through the ECS - which means less data flying around.\n\nAnything that is relevant to physics or that gets rendered will need to have its FK computed somewhere at some point on each ECS cycle. I believe this is going to be the case for *all* entities that we consider to be frames. By making the relative pose the authoritative data in the ECS, all we're doing is forcing many redundant FK computations. It's worth noting that outside of collision detection and collision handling, FK is the most computationally expensive stage of most simulations.\n\n> Systems can delegate FK computation to other libraries, like ign-rendering, to take advantage of their scene graph.\n\nI don't see how this is an advantage. The 2nd approach *forces* systems to rely on other libraries for FK, but I don't see how that's a positive thing.\n\n### Existing conventions\n\nThe conventional approach for most physics engines is to have one phase of the simulation cycle where the whole FK is authoritatively computed, and it never needs to be computed again until the next cycle.\n\nAs a counter-example to the conventional approach, dartsim does lazy evaluation for the FK, where it does some bookkeeping under the hood to keep track of when relative transforms are modified, and then if a user requests a transform that requires an FK computation, then dartsim will automatically update FK as needed and cache the results for later use.\n\nThe worst case scenario is when FK needs to be repeatedly recomputed multiple times in each simulation cycle. Each matrix multiplication involves a significant number of arithmetic operations, and the costs of those operations adds up quickly when performed redundantly on long chains. Physics engines typically avoid this aggressively, and I would urge us to do likewise.\n\n### Possible compromise?\n\nI can't refute the inherent issue that not all possible frames will be physical, so the conventional approach of depending entirely on the physics engine might not be an option.\n\nIf we're willing to add a small amount of complexity, we may be able to do a lite version of what dartsim does. What I'm thinking is we would have a `Pose` component which is a bit more complex than a simple `ignition::math::Pose3d` object. It would **privately** store both a `math::Pose3d` value and an entity index that indicates the frame of reference for that `math::Pose3d` data. The only way to get information out of the component is to pass it through a function such as `ignition::math::Pose3d FrameSemantics::Resolve(poseComponent, referenceFrame)` where you explicitly specify what reference frame you want the result to be expressed in (default being world frame). The frame semantics object will identify whether FK is needed based on the current frame of reference ID cached inside the component. Any time the frame semantics computes FK, it will update the component's cache with the newly computed world transform.\n\nThis means the way data is stored within the pose component is opaque to systems. Systems that write to pose components would do something like\n\n```\n*poseComponent = PoseComponent(pose3d, referenceFrameID);\n```\n\nwhile systems that read from them would do\n\n```\npose3d_relativeToSomeFrame = frameSemantics->Resolve(poseComponent, someFrameID);\n```\n\nSo physics systems that are already computing things in the world frame can just pass in world frame data:\n\n```\n*poseComponent = PoseComponent(poseRelativeToWorld, WorldID());\n```\n\nwhile other systems can pass in poses with respect to any frame:\n\n```\n*poseComponent = PoseComponent(poseRelativeToParent, parentEntityID);\n```\n\nand these representations will be opaque to anyone who reads from the component later. Any request for information will always do the most efficient thing possible.\n\n### Assumptions of this proposal\n\nFor that proposal to always work correctly, it relies on three assumptions:\n\n1. The pose component of each entity will always be updated on *each* ECS cycle\n\n2. The pose component will always be updated *before* being read from\n\nI think assumption (2) is a perfectly reasonable and unavoidable assumption. We already know that we're required to design the ECS so that components get written to before they're read from.\n\nAssumption (1) might be more controversial, because there may be entities that are static with respect to their parents, and it might be desirable to \"set and forget\" their relative transform (i.e. we'll tell the ECS what the entity's relative transform is one time and then never write to the entity or component again, ever, and just let systems read from it). I think I would push back against this and say that we shouldn't have stale entities or components. The existence and management of entities should be an active process, or else we risk leaking entities and components into the ECS even when they're not needed anymore.\n\nTo satisfy assumption (1), I might propose something like a Static Transform System to manage abstract non-physical frames that aren't managed by any other system (e.g. markers? abstract reference frames?) whose transforms are static with respect to their parent frames. On each ECS update, the Static Transform System would essentially \"remind\" the ECS of what the static entity's transform with respect to its parent is. This would be analogous to the static transform publisher of ROS's TF. Entities like visuals or IMUs would still get updated by the Rendering or Sensors systems respectively. The Static Transform System would just be a catch-all for any reference frame entity that doesn't neatly fall under the jurisdiction of an existing system. (I don't know if this Static Transform System idea will even be necessary, but at least it offers us a guaranteed way to satisfy assumption [1] if we find any conceptual outliers.)\n\n#### Side note\n\nI'm not totally clear: Should we be moving this conversation to [this PR](#!/ignitionrobotics/ign-gazebo/pull-requests/58/), or should we migrate to there once we've determined what approach to take?", "markup": "markdown", "html": "<p>Updating the transform of non-physical entities is a great point! That definitely rules out the assumption that the physics system can be singularly responsible for all FK computation.</p>\n<h3 id=\"markdown-header-parent-as-a-reference\">Parent as a reference</h3>\n<blockquote>\n<p>Physics only updates the model pose.</p>\n</blockquote>\n<p>I assume in this approach, physics will also update the relative poses of all physical entities. Note that in most cases (like ODE), this means the physics system will additionally have to compute <code>T_P.inverse() * T_E</code> for each entity <code>E</code> (where <code>T_P</code> is the world transform of the entity's parent and <code>T_E</code> is the world transform of the entity) and put this into the ECS. This isn't a terrible cost, but it's wasteful when the alternative is for it to just copy each <code>T_E</code> directly into the ECS and let rendering (and other systems) leverage world transforms of entities instead of recomputing the FK.</p>\n<blockquote>\n<p>Offsets which are fixed most of the time don't need to be continuously updated through the ECS - which means less data flying around.</p>\n</blockquote>\n<p>Anything that is relevant to physics or that gets rendered will need to have its FK computed somewhere at some point on each ECS cycle. I believe this is going to be the case for <em>all</em> entities that we consider to be frames. By making the relative pose the authoritative data in the ECS, all we're doing is forcing many redundant FK computations. It's worth noting that outside of collision detection and collision handling, FK is the most computationally expensive stage of most simulations.</p>\n<blockquote>\n<p>Systems can delegate FK computation to other libraries, like ign-rendering, to take advantage of their scene graph.</p>\n</blockquote>\n<p>I don't see how this is an advantage. The 2nd approach <em>forces</em> systems to rely on other libraries for FK, but I don't see how that's a positive thing.</p>\n<h3 id=\"markdown-header-existing-conventions\">Existing conventions</h3>\n<p>The conventional approach for most physics engines is to have one phase of the simulation cycle where the whole FK is authoritatively computed, and it never needs to be computed again until the next cycle.</p>\n<p>As a counter-example to the conventional approach, dartsim does lazy evaluation for the FK, where it does some bookkeeping under the hood to keep track of when relative transforms are modified, and then if a user requests a transform that requires an FK computation, then dartsim will automatically update FK as needed and cache the results for later use.</p>\n<p>The worst case scenario is when FK needs to be repeatedly recomputed multiple times in each simulation cycle. Each matrix multiplication involves a significant number of arithmetic operations, and the costs of those operations adds up quickly when performed redundantly on long chains. Physics engines typically avoid this aggressively, and I would urge us to do likewise.</p>\n<h3 id=\"markdown-header-possible-compromise\">Possible compromise?</h3>\n<p>I can't refute the inherent issue that not all possible frames will be physical, so the conventional approach of depending entirely on the physics engine might not be an option.</p>\n<p>If we're willing to add a small amount of complexity, we may be able to do a lite version of what dartsim does. What I'm thinking is we would have a <code>Pose</code> component which is a bit more complex than a simple <code>ignition::math::Pose3d</code> object. It would <strong>privately</strong> store both a <code>math::Pose3d</code> value and an entity index that indicates the frame of reference for that <code>math::Pose3d</code> data. The only way to get information out of the component is to pass it through a function such as <code>ignition::math::Pose3d FrameSemantics::Resolve(poseComponent, referenceFrame)</code> where you explicitly specify what reference frame you want the result to be expressed in (default being world frame). The frame semantics object will identify whether FK is needed based on the current frame of reference ID cached inside the component. Any time the frame semantics computes FK, it will update the component's cache with the newly computed world transform.</p>\n<p>This means the way data is stored within the pose component is opaque to systems. Systems that write to pose components would do something like</p>\n<div class=\"codehilite\"><pre><span></span>*poseComponent = PoseComponent(pose3d, referenceFrameID);\n</pre></div>\n\n\n<p>while systems that read from them would do</p>\n<div class=\"codehilite\"><pre><span></span>pose3d_relativeToSomeFrame = frameSemantics-&gt;Resolve(poseComponent, someFrameID);\n</pre></div>\n\n\n<p>So physics systems that are already computing things in the world frame can just pass in world frame data:</p>\n<div class=\"codehilite\"><pre><span></span>*poseComponent = PoseComponent(poseRelativeToWorld, WorldID());\n</pre></div>\n\n\n<p>while other systems can pass in poses with respect to any frame:</p>\n<div class=\"codehilite\"><pre><span></span>*poseComponent = PoseComponent(poseRelativeToParent, parentEntityID);\n</pre></div>\n\n\n<p>and these representations will be opaque to anyone who reads from the component later. Any request for information will always do the most efficient thing possible.</p>\n<h3 id=\"markdown-header-assumptions-of-this-proposal\">Assumptions of this proposal</h3>\n<p>For that proposal to always work correctly, it relies on three assumptions:</p>\n<ol>\n<li>\n<p>The pose component of each entity will always be updated on <em>each</em> ECS cycle</p>\n</li>\n<li>\n<p>The pose component will always be updated <em>before</em> being read from</p>\n</li>\n</ol>\n<p>I think assumption (2) is a perfectly reasonable and unavoidable assumption. We already know that we're required to design the ECS so that components get written to before they're read from.</p>\n<p>Assumption (1) might be more controversial, because there may be entities that are static with respect to their parents, and it might be desirable to \"set and forget\" their relative transform (i.e. we'll tell the ECS what the entity's relative transform is one time and then never write to the entity or component again, ever, and just let systems read from it). I think I would push back against this and say that we shouldn't have stale entities or components. The existence and management of entities should be an active process, or else we risk leaking entities and components into the ECS even when they're not needed anymore.</p>\n<p>To satisfy assumption (1), I might propose something like a Static Transform System to manage abstract non-physical frames that aren't managed by any other system (e.g. markers? abstract reference frames?) whose transforms are static with respect to their parent frames. On each ECS update, the Static Transform System would essentially \"remind\" the ECS of what the static entity's transform with respect to its parent is. This would be analogous to the static transform publisher of ROS's TF. Entities like visuals or IMUs would still get updated by the Rendering or Sensors systems respectively. The Static Transform System would just be a catch-all for any reference frame entity that doesn't neatly fall under the jurisdiction of an existing system. (I don't know if this Static Transform System idea will even be necessary, but at least it offers us a guaranteed way to satisfy assumption [1] if we find any conceptual outliers.)</p>\n<h4 id=\"markdown-header-side-note\">Side note</h4>\n<p>I'm not totally clear: Should we be moving this conversation to <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-gazebo/pull-requests/58/\" rel=\"nofollow\">this PR</a>, or should we migrate to there once we've determined what approach to take?</p>", "type": "rendered"}, "created_on": "2018-10-11T03:58:04.220256+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-10-11T07:35:20.882103+00:00", "type": "issue_comment", "id": 48280359}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3/comments/48292095.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/issues/3#comment-48292095"}}, "issue": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3.json"}}, "type": "issue", "id": 3, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f98d11fe-f287-4dfb-99c3-e2b76a13232e}ts=2082645"}}, "type": "repository", "name": "ign-gazebo", "full_name": "ignitionrobotics/ign-gazebo", "uuid": "{f98d11fe-f287-4dfb-99c3-e2b76a13232e}"}, "title": "Pose components"}, "content": {"raw": "You can migrate to the PR when decisions are reached. The point of the PR is to have a place to store the conclusion.", "markup": "markdown", "html": "<p>You can migrate to the PR when decisions are reached. The point of the PR is to have a place to store the conclusion.</p>", "type": "rendered"}, "created_on": "2018-10-11T14:27:11.998367+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": null, "type": "issue_comment", "id": 48292095}, {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3/comments/48424659.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/issues/3#comment-48424659"}}, "issue": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3.json"}}, "type": "issue", "id": 3, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f98d11fe-f287-4dfb-99c3-e2b76a13232e}ts=2082645"}}, "type": "repository", "name": "ign-gazebo", "full_name": "ignitionrobotics/ign-gazebo", "uuid": "{f98d11fe-f287-4dfb-99c3-e2b76a13232e}"}, "title": "Pose components"}, "content": {"raw": "Related to this an SDF pull request that will handle pose and frame information:  https://bitbucket.org/osrf/sdformat/pull-requests/468/wip-pose-dom/diff", "markup": "markdown", "html": "<p>Related to this an SDF pull request that will handle pose and frame information:  <a href=\"https://bitbucket.org/osrf/sdformat/pull-requests/468/wip-pose-dom/diff\" rel=\"nofollow\" class=\"ap-connect-link\">https://bitbucket.org/osrf/sdformat/pull-requests/468/wip-pose-dom/diff</a></p>", "type": "rendered"}, "created_on": "2018-10-18T14:55:53.837003+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": null, "type": "issue_comment", "id": 48424659}], "page": 1, "size": 8}