{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3/comments/48280359.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo/issues/3#comment-48280359"}}, "issue": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo/issues/3.json"}}, "type": "issue", "id": 3, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-gazebo.json"}, "html": {"href": "#!/ignitionrobotics/ign-gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f98d11fe-f287-4dfb-99c3-e2b76a13232e}ts=2082645"}}, "type": "repository", "name": "ign-gazebo", "full_name": "ignitionrobotics/ign-gazebo", "uuid": "{f98d11fe-f287-4dfb-99c3-e2b76a13232e}"}, "title": "Pose components"}, "content": {"raw": "Updating the transform of non-physical entities is a great point! That definitely rules out the assumption that the physics system can be singularly responsible for all FK computation.\n\n### Parent as a reference\n\n> Physics only updates the model pose.\n\nI assume in this approach, physics will also update the relative poses of all physical entities. Note that in most cases (like ODE), this means the physics system will additionally have to compute `T_P.inverse() * T_E` for each entity `E` (where `T_P` is the world transform of the entity's parent and `T_E` is the world transform of the entity) and put this into the ECS. This isn't a terrible cost, but it's wasteful when the alternative is for it to just copy each `T_E` directly into the ECS and let rendering (and other systems) leverage world transforms of entities instead of recomputing the FK.\n\n> Offsets which are fixed most of the time don't need to be continuously updated through the ECS - which means less data flying around.\n\nAnything that is relevant to physics or that gets rendered will need to have its FK computed somewhere at some point on each ECS cycle. I believe this is going to be the case for *all* entities that we consider to be frames. By making the relative pose the authoritative data in the ECS, all we're doing is forcing many redundant FK computations. It's worth noting that outside of collision detection and collision handling, FK is the most computationally expensive stage of most simulations.\n\n> Systems can delegate FK computation to other libraries, like ign-rendering, to take advantage of their scene graph.\n\nI don't see how this is an advantage. The 2nd approach *forces* systems to rely on other libraries for FK, but I don't see how that's a positive thing.\n\n### Existing conventions\n\nThe conventional approach for most physics engines is to have one phase of the simulation cycle where the whole FK is authoritatively computed, and it never needs to be computed again until the next cycle.\n\nAs a counter-example to the conventional approach, dartsim does lazy evaluation for the FK, where it does some bookkeeping under the hood to keep track of when relative transforms are modified, and then if a user requests a transform that requires an FK computation, then dartsim will automatically update FK as needed and cache the results for later use.\n\nThe worst case scenario is when FK needs to be repeatedly recomputed multiple times in each simulation cycle. Each matrix multiplication involves a significant number of arithmetic operations, and the costs of those operations adds up quickly when performed redundantly on long chains. Physics engines typically avoid this aggressively, and I would urge us to do likewise.\n\n### Possible compromise?\n\nI can't refute the inherent issue that not all possible frames will be physical, so the conventional approach of depending entirely on the physics engine might not be an option.\n\nIf we're willing to add a small amount of complexity, we may be able to do a lite version of what dartsim does. What I'm thinking is we would have a `Pose` component which is a bit more complex than a simple `ignition::math::Pose3d` object. It would **privately** store both a `math::Pose3d` value and an entity index that indicates the frame of reference for that `math::Pose3d` data. The only way to get information out of the component is to pass it through a function such as `ignition::math::Pose3d FrameSemantics::Resolve(poseComponent, referenceFrame)` where you explicitly specify what reference frame you want the result to be expressed in (default being world frame). The frame semantics object will identify whether FK is needed based on the current frame of reference ID cached inside the component. Any time the frame semantics computes FK, it will update the component's cache with the newly computed world transform.\n\nThis means the way data is stored within the pose component is opaque to systems. Systems that write to pose components would do something like\n\n```\n*poseComponent = PoseComponent(pose3d, referenceFrameID);\n```\n\nwhile systems that read from them would do\n\n```\npose3d_relativeToSomeFrame = frameSemantics->Resolve(poseComponent, someFrameID);\n```\n\nSo physics systems that are already computing things in the world frame can just pass in world frame data:\n\n```\n*poseComponent = PoseComponent(poseRelativeToWorld, WorldID());\n```\n\nwhile other systems can pass in poses with respect to any frame:\n\n```\n*poseComponent = PoseComponent(poseRelativeToParent, parentEntityID);\n```\n\nand these representations will be opaque to anyone who reads from the component later. Any request for information will always do the most efficient thing possible.\n\n### Assumptions of this proposal\n\nFor that proposal to always work correctly, it relies on three assumptions:\n\n1. The pose component of each entity will always be updated on *each* ECS cycle\n\n2. The pose component will always be updated *before* being read from\n\nI think assumption (2) is a perfectly reasonable and unavoidable assumption. We already know that we're required to design the ECS so that components get written to before they're read from.\n\nAssumption (1) might be more controversial, because there may be entities that are static with respect to their parents, and it might be desirable to \"set and forget\" their relative transform (i.e. we'll tell the ECS what the entity's relative transform is one time and then never write to the entity or component again, ever, and just let systems read from it). I think I would push back against this and say that we shouldn't have stale entities or components. The existence and management of entities should be an active process, or else we risk leaking entities and components into the ECS even when they're not needed anymore.\n\nTo satisfy assumption (1), I might propose something like a Static Transform System to manage abstract non-physical frames that aren't managed by any other system (e.g. markers? abstract reference frames?) whose transforms are static with respect to their parent frames. On each ECS update, the Static Transform System would essentially \"remind\" the ECS of what the static entity's transform with respect to its parent is. This would be analogous to the static transform publisher of ROS's TF. Entities like visuals or IMUs would still get updated by the Rendering or Sensors systems respectively. The Static Transform System would just be a catch-all for any reference frame entity that doesn't neatly fall under the jurisdiction of an existing system. (I don't know if this Static Transform System idea will even be necessary, but at least it offers us a guaranteed way to satisfy assumption [1] if we find any conceptual outliers.)\n\n#### Side note\n\nI'm not totally clear: Should we be moving this conversation to [this PR](#!/ignitionrobotics/ign-gazebo/pull-requests/58/), or should we migrate to there once we've determined what approach to take?", "markup": "markdown", "html": "<p>Updating the transform of non-physical entities is a great point! That definitely rules out the assumption that the physics system can be singularly responsible for all FK computation.</p>\n<h3 id=\"markdown-header-parent-as-a-reference\">Parent as a reference</h3>\n<blockquote>\n<p>Physics only updates the model pose.</p>\n</blockquote>\n<p>I assume in this approach, physics will also update the relative poses of all physical entities. Note that in most cases (like ODE), this means the physics system will additionally have to compute <code>T_P.inverse() * T_E</code> for each entity <code>E</code> (where <code>T_P</code> is the world transform of the entity's parent and <code>T_E</code> is the world transform of the entity) and put this into the ECS. This isn't a terrible cost, but it's wasteful when the alternative is for it to just copy each <code>T_E</code> directly into the ECS and let rendering (and other systems) leverage world transforms of entities instead of recomputing the FK.</p>\n<blockquote>\n<p>Offsets which are fixed most of the time don't need to be continuously updated through the ECS - which means less data flying around.</p>\n</blockquote>\n<p>Anything that is relevant to physics or that gets rendered will need to have its FK computed somewhere at some point on each ECS cycle. I believe this is going to be the case for <em>all</em> entities that we consider to be frames. By making the relative pose the authoritative data in the ECS, all we're doing is forcing many redundant FK computations. It's worth noting that outside of collision detection and collision handling, FK is the most computationally expensive stage of most simulations.</p>\n<blockquote>\n<p>Systems can delegate FK computation to other libraries, like ign-rendering, to take advantage of their scene graph.</p>\n</blockquote>\n<p>I don't see how this is an advantage. The 2nd approach <em>forces</em> systems to rely on other libraries for FK, but I don't see how that's a positive thing.</p>\n<h3 id=\"markdown-header-existing-conventions\">Existing conventions</h3>\n<p>The conventional approach for most physics engines is to have one phase of the simulation cycle where the whole FK is authoritatively computed, and it never needs to be computed again until the next cycle.</p>\n<p>As a counter-example to the conventional approach, dartsim does lazy evaluation for the FK, where it does some bookkeeping under the hood to keep track of when relative transforms are modified, and then if a user requests a transform that requires an FK computation, then dartsim will automatically update FK as needed and cache the results for later use.</p>\n<p>The worst case scenario is when FK needs to be repeatedly recomputed multiple times in each simulation cycle. Each matrix multiplication involves a significant number of arithmetic operations, and the costs of those operations adds up quickly when performed redundantly on long chains. Physics engines typically avoid this aggressively, and I would urge us to do likewise.</p>\n<h3 id=\"markdown-header-possible-compromise\">Possible compromise?</h3>\n<p>I can't refute the inherent issue that not all possible frames will be physical, so the conventional approach of depending entirely on the physics engine might not be an option.</p>\n<p>If we're willing to add a small amount of complexity, we may be able to do a lite version of what dartsim does. What I'm thinking is we would have a <code>Pose</code> component which is a bit more complex than a simple <code>ignition::math::Pose3d</code> object. It would <strong>privately</strong> store both a <code>math::Pose3d</code> value and an entity index that indicates the frame of reference for that <code>math::Pose3d</code> data. The only way to get information out of the component is to pass it through a function such as <code>ignition::math::Pose3d FrameSemantics::Resolve(poseComponent, referenceFrame)</code> where you explicitly specify what reference frame you want the result to be expressed in (default being world frame). The frame semantics object will identify whether FK is needed based on the current frame of reference ID cached inside the component. Any time the frame semantics computes FK, it will update the component's cache with the newly computed world transform.</p>\n<p>This means the way data is stored within the pose component is opaque to systems. Systems that write to pose components would do something like</p>\n<div class=\"codehilite\"><pre><span></span>*poseComponent = PoseComponent(pose3d, referenceFrameID);\n</pre></div>\n\n\n<p>while systems that read from them would do</p>\n<div class=\"codehilite\"><pre><span></span>pose3d_relativeToSomeFrame = frameSemantics-&gt;Resolve(poseComponent, someFrameID);\n</pre></div>\n\n\n<p>So physics systems that are already computing things in the world frame can just pass in world frame data:</p>\n<div class=\"codehilite\"><pre><span></span>*poseComponent = PoseComponent(poseRelativeToWorld, WorldID());\n</pre></div>\n\n\n<p>while other systems can pass in poses with respect to any frame:</p>\n<div class=\"codehilite\"><pre><span></span>*poseComponent = PoseComponent(poseRelativeToParent, parentEntityID);\n</pre></div>\n\n\n<p>and these representations will be opaque to anyone who reads from the component later. Any request for information will always do the most efficient thing possible.</p>\n<h3 id=\"markdown-header-assumptions-of-this-proposal\">Assumptions of this proposal</h3>\n<p>For that proposal to always work correctly, it relies on three assumptions:</p>\n<ol>\n<li>\n<p>The pose component of each entity will always be updated on <em>each</em> ECS cycle</p>\n</li>\n<li>\n<p>The pose component will always be updated <em>before</em> being read from</p>\n</li>\n</ol>\n<p>I think assumption (2) is a perfectly reasonable and unavoidable assumption. We already know that we're required to design the ECS so that components get written to before they're read from.</p>\n<p>Assumption (1) might be more controversial, because there may be entities that are static with respect to their parents, and it might be desirable to \"set and forget\" their relative transform (i.e. we'll tell the ECS what the entity's relative transform is one time and then never write to the entity or component again, ever, and just let systems read from it). I think I would push back against this and say that we shouldn't have stale entities or components. The existence and management of entities should be an active process, or else we risk leaking entities and components into the ECS even when they're not needed anymore.</p>\n<p>To satisfy assumption (1), I might propose something like a Static Transform System to manage abstract non-physical frames that aren't managed by any other system (e.g. markers? abstract reference frames?) whose transforms are static with respect to their parent frames. On each ECS update, the Static Transform System would essentially \"remind\" the ECS of what the static entity's transform with respect to its parent is. This would be analogous to the static transform publisher of ROS's TF. Entities like visuals or IMUs would still get updated by the Rendering or Sensors systems respectively. The Static Transform System would just be a catch-all for any reference frame entity that doesn't neatly fall under the jurisdiction of an existing system. (I don't know if this Static Transform System idea will even be necessary, but at least it offers us a guaranteed way to satisfy assumption [1] if we find any conceptual outliers.)</p>\n<h4 id=\"markdown-header-side-note\">Side note</h4>\n<p>I'm not totally clear: Should we be moving this conversation to <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-gazebo/pull-requests/58/\" rel=\"nofollow\">this PR</a>, or should we migrate to there once we've determined what approach to take?</p>", "type": "rendered"}, "created_on": "2018-10-11T03:58:04.220256+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-10-11T07:35:20.882103+00:00", "type": "issue_comment", "id": 48280359}